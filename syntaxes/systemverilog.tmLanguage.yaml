name: SystemVerilog
scopeName: source-text.sv
variables:
  simpleIdentifier: \b[a-zA-Z_][a-zA-Z0-9_\$]*\b
  identifier: (?:(?<!\\|\$)\b[a-zA-Z_][a-zA-Z0-9_\$]*\b|\\\S+(?=\s|$)|`[a-zA-Z_][a-zA-Z0-9_\$]*\b(?:\(.*?\))?)(?<!\b(?:accept_on|alias|always|always_comb|always_ff|always_latch|and|assert|assign|assume|automatic|before|begin|bind|bins|binsof|bit|break|buf|bufif0|bufif1|byte|case|casex|casez|cell|chandle|checker|class|clocking|cmos|config|const|constraint|context|continue|cover|covergroup|coverpoint|cross|deassign|default|defparam|design|disable|dist|do|edge|else|end|endcase|endchecker|endclass|endclocking|endconfig|endfunction|endgenerate|endgroup|endinterface|endmodule|endpackage|endprimitive|endprogram|endproperty|endspecify|endsequence|endtable|endtask|enum|event|eventually|expect|export|extends|extern|final|first_match|for|force|foreach|forever|fork|forkjoin|function|generate|genvar|global|highz0|highz1|if|iff|ifnone|ignore_bins|illegal_bins|implements|implies|import|incdir|include|initial|inout|input|inside|instance|int|integer|interconnect|interface|intersect|join|join_any|join_none|large|let|liblist|library|local|localparam|logic|longint|macromodule|matches|medium|modport|module|nand|negedge|nettype|new|nexttime|nmos|nor|noshowcancelled|not|notif0|notif1|null|or|output|package|packed|parameter|pmos|posedge|primitive|priority|program|property|protected|pull0|pull1|pulldown|pullup|pulsestyle_ondetect|pulsestyle_onevent|pure|rand|randc|randcase|randsequence|rcmos|real|realtime|ref|reg|reject_on|release|repeat|restrict|return|rnmos|rpmos|rtran|rtranif0|rtranif1|s_always|s_eventually|s_nexttime|s_until|s_until_with|scalared|sequence|shortint|shortreal|showcancelled|signed|small|soft|solve|specify|specparam|static|string|strong|strong0|strong1|struct|super|supply0|supply1|sync_accept_on|sync_reject_on|table|tagged|task|this|throughout|time|timeprecision|timeunit|tran|tranif0|tranif1|tri|tri0|tri1|triand|trior|trireg|type|typedef|union|unique|unique0|unsigned|until|until_with|untyped|use|uwire|var|vectored|virtual|void|wait|wait_order|wand|weak|weak0|weak1|while|wildcard|wire|with|within|wor|xnor|xor)\b|`(?:__FILE__|__LINE__|begin_keywords|celldefine|default_nettype|define|else|elsif|end_keywords|endcelldefine|endif|ifdef|ifndef|include|line|nounconnected_drive|pragma|resetall|timescale|unconnected_drive|undef|undefineall)\b)
  macro: (?:`[a-zA-Z_][a-zA-Z0-9_\$]*\b(?:\(.*?\))?)(?<!`(?:__FILE__|__LINE__|begin_keywords|celldefine|default_nettype|define|else|elsif|end_keywords|endcelldefine|endif|ifdef|ifndef|include|line|nounconnected_drive|pragma|resetall|timescale|unconnected_drive|undef|undefineall)\b)
  # Remove array method name: unique, and, or, xor
  functionIdentifier: (?:(?<!\\|\$)(?:\b[a-zA-Z_]|\$)[a-zA-Z0-9_\$]*\b|\\\S+(?=\s|$))(?<!\b(?:accept_on|alias|always|always_comb|always_ff|always_latch|assert|assign|assume|automatic|before|begin|bind|bins|binsof|bit|break|buf|bufif0|bufif1|byte|case|casex|casez|cell|chandle|checker|class|clocking|cmos|config|const|constraint|context|continue|cover|covergroup|coverpoint|cross|deassign|default|defparam|design|disable|dist|do|edge|else|end|endcase|endchecker|endclass|endclocking|endconfig|endfunction|endgenerate|endgroup|endinterface|endmodule|endpackage|endprimitive|endprogram|endproperty|endspecify|endsequence|endtable|endtask|enum|event|eventually|expect|export|extends|extern|final|first_match|for|force|foreach|forever|fork|forkjoin|function|generate|genvar|global|highz0|highz1|if|iff|ifnone|ignore_bins|illegal_bins|implements|implies|import|incdir|include|initial|inout|input|inside|instance|int|integer|interconnect|interface|intersect|join|join_any|join_none|large|let|liblist|library|local|localparam|logic|longint|macromodule|matches|medium|modport|module|nand|negedge|nettype|new|nexttime|nmos|nor|noshowcancelled|not|notif0|notif1|null|output|package|packed|parameter|pmos|posedge|primitive|priority|program|property|protected|pull0|pull1|pulldown|pullup|pulsestyle_ondetect|pulsestyle_onevent|pure|rand|randc|randcase|randsequence|rcmos|real|realtime|ref|reg|reject_on|release|repeat|restrict|return|rnmos|rpmos|rtran|rtranif0|rtranif1|s_always|s_eventually|s_nexttime|s_until|s_until_with|scalared|sequence|shortint|shortreal|showcancelled|signed|small|soft|solve|specify|specparam|static|string|strong|strong0|strong1|struct|super|supply0|supply1|sync_accept_on|sync_reject_on|table|tagged|task|this|throughout|time|timeprecision|timeunit|tran|tranif0|tranif1|tri|tri0|tri1|triand|trior|trireg|type|typedef|union|unique0|unsigned|until|until_with|untyped|use|uwire|var|vectored|virtual|void|wait|wait_order|wand|weak|weak0|weak1|while|wildcard|wire|with|within|wor|xnor)\b)
  classScope: (?:${identifier}\s*(?:\#\(.*?\)\s*)?::\s*)+
  # Identifier can be followed by ":" (ternary statement, label, etc.)
  identifierEnd: (?!\s*(${identifier}|#|\(|\'|::|\s*\[.*\]\s*${identifier}))
  # Type identifier can be followed by "#" (class, module, etc.)
  typeIdentifierEnd: (?!\s*(\(|\.|\=|::|:))
  functionIdentifierStart: (?<!(?:\))\s+)
  functionIdentifierEnd: (?!\s*(\b\w+\b|\.|\[|#|::))
  classIdentifierEnd: (?!\s*(\(|\.|\=|:))
  assignmentEnd: (?=\,|\)|\;)
  psIdentifier: (?:(?:${identifier})\s*(?:::)\s*)?(?:${identifier})
patterns:
  - include: "#comment"
  - include: "#compiler-directive"
  - include: "#description"
repository:
  # A.1.2 SystemVerilog source text
  description:
    patterns:
      - include: "#attribute-instance"
      - include: "#module-declaration"
      - include: "#udp-declaration"
      - include: "#interface-declaration"
      - include: "#program-declaration"
      - include: "#package-declaration"
      - include: "#package-item"
      - include: "#bind-directive"
      - include: "#config-declaration"
  module-declaration:
    name: meta.module-declaration.sv
    begin: (?=\b(module|macromodule)\b)
    end: \b(endmodule)\b\s*(?:(\:)\s*(${identifier})\s*)?
    endCaptures:
      "1": { name: storage.type.module.sv }
      "2": { name: punctuation.separator.colon.sv }
      "3": { name: entity.name.type.module.sv }
    patterns:
      - name: meta.module-header.sv
        begin: \b(module|macromodule)\s+(?:(static|automatic)\s+)?(${identifier})\s*
        end: (\;)\s*
        beginCaptures:
          "1": { name: storage.type.$1.sv }
          "2": { name: storage.modifier.$2.sv }
          "3": { name: entity.name.type.module.sv }
        endCaptures:
          "1": { name: punctuation.terminator.semicolon.sv }
        patterns:
          - include: "#package-import-declaration"
          - include: "#parameter-port-list"
          - include: "#list-of-port-declarations"
      - name: meta.module-body.sv
        begin: (?<=\;\s*)
        end: (?=\b(endmodule)\b)
        patterns:
          - include: "#compiler-directive"
          - include: "#timeunits-declaration"
          - include: "#module-item"
          - include: "#non-port-module-item"
  class-declaration:
    begin: (?=\b(class)\b|\bvirtual\b\s+\bclass\b)
    end: \b(endclass)\b\s*(?:(\:)\s*(${identifier})\s*)?
    endCaptures:
      "1": { name: storage.type.class.sv }
      "2": { name: punctuation.separator.colon.sv }
      "3": { name: entity.name.type.sv }
    patterns:
      # Header
      - name: meta.class-header.sv
        begin: (?:\b(virtual)\b\s+)?\b(class)\b\s*
        end: (?=\;)
        beginCaptures:
          "1": { name: storage.modifier.virtual.sv }
          "2": { name: storage.type.$2.sv }
        patterns:
          - include: "#lifetime"
          - include: "#class-identifier"
          - include: "#parameter-port-list"
          # Extends
          - begin: \b(extends)\b\s*
            end: (?=\;|\b(implements)\b)
            beginCaptures:
              "1": { name: storage.modifier.$1.sv }
            patterns:
              - include: "#class-type"
              - include: "#list-of-arguments"
          # Implements
          - begin: \b(implements)\b\s*
            end: (?=\;)
            beginCaptures:
              "1": { name: storage.modifier.$1.sv }
            patterns:
              - include: "#interface-class-type"
              - include: "#comma"
      # Body
      - name: meta.class-body.sv
        begin: (\;)\s*
        end: (?=\b(endclass)\b)
        beginCaptures:
          "1": { name: punctuation.terminator.semicolon.sv }
        patterns:
          - include: "#class-item"
  interface-class-type:
    patterns:
      - include: "#ps-class-identifier"
      - include: "#parameter-value-assignment"
  # A.1.3 Module parameters and ports
  parameter-port-list:
    name: meta.parameter-port-list.sv
    begin: (\#\s*\()\s*
    end: (\))\s*
    beginCaptures:
      "1": { name: punctuation.section.group.begin.sv }
    endCaptures:
      "1": { name: punctuation.section.group.end.sv }
    patterns:
      - include: "#list-of-param-assignments"
      - include: "#parameter-port-declaration"
      - include: "#comma"
      - include: "#comment"
      - include: "#compiler-directive"
  parameter-port-declaration:
    patterns:
      - begin: \b(type)\b\s*
        end: (?=\;|\,|\))
        name: meta.parameter-port-declaration.sv
        beginCaptures:
          "1": { name: storage.type.type.sv }
        patterns:
          - include: "#list-of-type-assignments"
          - include: "#comment"
          - include: "#compiler-directive"
      - include: "#list-of-param-assignments"
      - include: "#parameter-declaration"
      - include: "#local-parameter-declaration"
      - include: "#data-type"
  list-of-port-declarations:
    name: meta.list-of-port-declarations.sv
    begin: (\()\s*(?!\*)
    end: (\))\s*
    beginCaptures:
      "1": { name: punctuation.section.group.begin.sv }
    endCaptures:
      "1": { name: punctuation.section.group.end.sv }
    patterns:
      - include: "#comment"
      - include: "#compiler-directive"
      - include: "#comma"
      - include: "#attribute-instance"
      - include: "#port"
      - include: "#ansi-port-declaration"
  port-declaration:
    patterns:
      - include: "#attribute-instance"
      - include: "#inout-declaration"
      - include: "#input-declaration"
      - include: "#output-declaration"
      - include: "#ref-declaration"
      - include: "#interface-port-declaration"
  port:
    patterns:
      - name: meta.port.sv
        begin: (\.)(${identifier})\s*(\()\s*
        end: (\))\s*
        beginCaptures:
          "1": { name: punctuation.definition.named-port.sv }
          "2": { name: variable.other.sv }
          "3": { name: punctuation.section.group.begin.sv }
        endCaptures:
          "1": { name: punctuation.section.group.end.sv }
        patterns:
          - include: "#port-expression"
      - include: "#port-expression"
  port-expression:
    patterns:
      - include: "#port-reference"
      - name: meta.port-expression.sv
        begin: \{
        end: \}
        beginCaptures:
          "0": { name: punctuation.section.group.begin.sv }
        endCaptures:
          "0": { name: punctuation.section.group.end.sv }
        patterns:
          - include: "#port-reference"
          - include: "#comma"
          - include: "#comment"
          - include: "#compiler-directive"
  port-reference:
    name: meta.port-reference.sv
    begin: (?<=(?:\{|\,|\()\s*|^)(${identifier})\s*(?=\[|\,|\}|\))
    beginCaptures:
      "1": { name: variable.other.sv }
    end: (?=,|\}|\))
    patterns:
      - include: "#port-identifier"
      - include: "#constant-select"
  port-direction:
    patterns:
      - match: \b(input|output|inout|ref)\b
        captures:
          "1": { name: storage.modifier.$1.sv }
  net-port-header:
    patterns:
      - include: "#port-direction"
      - include: "#net-port-type"
  variable-port-header:
    patterns:
      - include: "#port-direction"
      - include: "#variable-port-type"
  interface-port-header:
    patterns:
      - match: \b(interface)\b
        captures:
          "1": { name: storage.type.interface.sv }
      - match: \.
        captures:
          "0": { name: punctuation.accessor.dot.sv }
      - match: (${identifier})
        captures:
          "1": { name: entity.name.type.interface.sv }
  ansi-port-declaration:
    patterns:
      - include: "#port-identifier"
      - include: "#net-port-header"
      - include: "#interface-port-header"
      - include: "#variable-port-header"
      - include: "#dimension"
      - name: meta.ansi-port-declaration.sv
        begin: (\=)\s*(?!\=)
        end: ${assignmentEnd}
        beginCaptures:
          "1": { name: keyword.operator.assignment.sv }
        patterns:
          - include: "#constant-expression"
      - include: "#comma"
      - include: "#comment"
      - include: "#compiler-directive"
  # A.1.4 Module items
  module-common-item:
    patterns:
      # Conflict: The 'generate for' and 'for' statements have the same beginning. Therefore, they are combined here:
      - name: meta.for.sv
        begin: \b(for)\b\s*(\()\s*
        end: (\))\s*
        beginCaptures:
          "1": { name: keyword.control.for.sv }
          "2": { name: punctuation.section.group.begin.sv }
        endCaptures:
          "1": { name: punctuation.section.group.end.sv }
        patterns:
          - include: "#genvar-initialization"
          - include: "#genvar-iteration"
          - include: "#genvar-expression"
          - include: "#semicolon"
          - include: "#for-initialization"
          - include: "#for-step"
          - include: "#expression"
      - include: "#module-or-generate-item-declaration"
      - include: "#interface-instantiation"
      - include: "#program-instantiation"
      - include: "#assertion-item"
      - include: "#bind-directive"
      - include: "#continuous-assign"
      - include: "#net-alias"
      - include: "#initial-construct"
      - include: "#final-construct"
      - include: "#always-construct"
      - include: "#loop-generate-construct"
      - include: "#conditional-generate-construct"
      - include: "#elaboration-system-task"
  module-item:
    patterns:
      - include: "#port-declaration"
      - include: "#non-port-module-item"
  module-or-generate-item:
    patterns:
      - include: "#attribute-instance"
      - include: "#parameter-override"
      - include: "#gate-instantiation"
      - include: "#udp-instantiation"
      - include: "#module-instantiation"
      - include: "#module-common-item"
  module-or-generate-item-declaration:
    patterns:
      - include: "#package-or-generate-item-declaration"
      - include: "#genvar-declaration"
      - include: "#clocking-declaration"
      - match: \b(default)\s+(clocking)\s+(${identifier})\s*\;
        captures:
          "1": { name: keyword.control.$1.sv }
          "2": { name: storage.type.$2.sv }
          "3":
            patterns:
              - include: "#clocking-identifier"
      - name: meta.default-disable.sv
        begin: \b(default)\s+(disable)\s+(iff)\s*
        end: (\;)\s*
        beginCaptures:
          "1": { name: keyword.control.$1.sv }
          "2": { name: keyword.control.$2.sv }
          "3": { name: keyword.control.$3.sv }
        endCaptures:
          "1": { name: punctuation.terminator.semicolon.sv }
  non-port-module-item:
    patterns:
      - include: "#module-or-generate-item"
      - include: "#specify-block"
      - include: "#specparam-declaration"
      - include: "#program-declaration"
      - include: "#module-declaration"
      - include: "#interface-declaration"
      - include: "#timeunits-declaration"
  # A.1.9 Class items
  class-item:
    patterns:
      - include: "#attribute-instance"
      - include: "#class-property"
      - include: "#class-method"
      - include: "#class-constraint"
      - include: "#class-declaration"
      - include: "#covergroup-declaration"
      - include: "#local-parameter-declaration"
      - include: "#parameter-declaration"
      - include: "#semicolon"
  class-property:
    patterns:
      - include: "#property-qualifier"
      - include: "#data-declaration"
      - begin: \b(const)\b\s*
        end: (\;)\s*
        beginCaptures:
          "1": { name: storage.modifier.const.sv }
        endCaptures:
          "1": { name: punctuation.terminator.semicolon.sv }
        patterns:
          - include: "#class-item-qualifier"
          - include: "#const-identifier"
          - begin: (\=)\s*(?!\=)
            end: ${assignmentEnd}
            beginCaptures:
              "1": { name: keyword.operator.assignment.sv }
            patterns:
              - include: "#constant-expression"
          - include: "#data-type"
      - name: meta.assignments.sv
        begin: (\=)\s*(?!\=)
        end: ${assignmentEnd}
        beginCaptures:
          "1": { name: keyword.operator.assignment.sv }
        patterns:
          - include: "#expression"
          - include: "#dynamic-array-new"
          - include: "#class-new"
          - include: "#delay-or-event-control"
  class-method:
    patterns:
      - include: "#method-qualifier"
      - include: "#task-declaration"
      - include: "#function-declaration"
      - name: meta.abstract-class-function-protoype.sv
        begin: \b(pure)\s+(virtual)\s*
        end: (\;)\s*
        beginCaptures:
          "1": { name: storage.modifier.pure.sv }
          "2": { name: storage.modifier.virtual.sv }
        endCaptures:
          "1": { name: punctuation.terminator.semicolon.sv }
        patterns:
          - include: "#class-item-qualifier"
          - include: "#method-prototype"
      - begin: \b(extern)\b\s*
        end: (\;)\s*
        beginCaptures:
          "1": { name: storage.modifier.extern.sv }
        endCaptures:
          "1": { name: punctuation.terminator.semicolon.sv }
        patterns:
          - include: "#method-qualifier"
          - include: "#method-prototype"
          - include: "#class-constructor-prototype"
      - include: "#method-qualifier"
      - include: "#class-constructor-declaration"
  class-constructor-prototype:
    name: meta.class-constructor-protoype.sv
    begin: \b(function)\b\s+\b(new)\b\s*
    end: (\;)\s*
    beginCaptures:
      "1": { name: storage.type.function.sv }
      "2": { name: entity.name.function.sv }
    endCaptures:
      "1": { name: punctuation.terminator.semicolon.sv }
    patterns:
      - begin: (\()\s*
        end: (\))\s*
        beginCaptures:
          "1": { name: punctuation.section.group.begin.sv }
        endCaptures:
          "1": { name: punctuation.section.group.end.sv }
        patterns:
          - include: "#tf-port-list"
  class-constraint:
    patterns:
      - include: "#constraint-prototype"
      - include: "#constraint-declaration"
  class-item-qualifier:
    patterns:
      - match: \b(static|protected|local)\b
        captures:
          "1": { name: storage.modifier.$1.sv }
  property-qualifier:
    patterns:
      - include: "#random-qualifier"
      - include: "#class-item-qualifier"
  random-qualifier:
    patterns:
      - match: \b(rand|randc)\b\s*
        captures:
          "1": { name: storage.modifier.$1.sv }
  method-qualifier:
    patterns:
      - match: \b(virtual)\b\s*
        captures:
          "1": { name: storage.modifier.$1.sv }
      - include: "#class-item-qualifier"
  method-prototype:
    patterns:
      - include: "#task-prototype"
      - include: "#function-prototype"
  # Move the 'super.new' pattern to function declaration
  class-constructor-declaration:
    patterns:
      - include: "#function-declaration"
  # A.1.11 Package items
  package-item:
    patterns:
      - include: "#package-or-generate-item-declaration"
      - include: "#anonymous-program"
      - include: "#package-export-declaration"
      - include: "#timeunits-declaration"
  package-or-generate-item-declaration:
    patterns:
      # This section handles assignments for both nets and data.
      # The assignment logic has been moved here for better organization.
      - name: meta.assignments.sv
        begin: (\=)\s*(?!\=)
        end: ${assignmentEnd}
        beginCaptures:
          "1": { name: keyword.operator.assignment.sv }
        patterns:
          - include: "#expression"
          - include: "#dynamic-array-new"
          - include: "#class-new"
          - include: "#delay-or-event-control"
      - include: "#net-declaration"
      - include: "#data-declaration"
      - include: "#task-declaration"
      - include: "#function-declaration"
      - include: "#checker-declaration"
      - include: "#dpi-import-export"
      - include: "#extern-constraint-declaration"
      - include: "#class-declaration"
      - include: "#class-constructor-declaration"
      - include: "#local-parameter-declaration"
      - include: "#parameter-declaration"
      - include: "#covergroup-declaration"
      - include: "#assertion-item-declaration"
      - include: "#semicolon"
  anonymous-program:
    name: meta.anonymous-program.sv
    begin: \b(program)\s*
    end: \b(endprogram)\b\s*
    beginCaptures:
      "1": { name: storage.type.$1.sv }
    endCaptures:
      "1": { name: storage.type.$1.sv }
    patterns:
      - include: "#semicolon"
      - include: "#anonymous-program-item"
  anonymous-program-item:
    patterns:
      - include: "#task-declaration"
      - include: "#function-declaration"
      - include: "#class-declaration"
      - include: "#covergroup-declaration"
      - include: "#class-constructor-declaration"
      - include: "#semicolon"
  # A.2 Declarations
  # A.2.1 Declaration types
  # A.2.1.1 Module parameter declarations
  local-parameter-declaration:
    patterns:
      - name: meta.local-parameter-declaration.sv
        begin: \b(localparam)\s+(type)\b\s*
        end: (?=[,);])
        beginCaptures:
          "1": { name: storage.modifier.localparam.sv }
          "2": { name: storage.modifier.type.sv }
        endCaptures:
          "1": { name: punctuation.terminator.semicolon.sv }
        patterns:
          - include: "#list-of-type-assignments"
      - name: meta.local-parameter-declaration.sv
        begin: \b(localparam)\b\s*
        end: (?=[,);])
        beginCaptures:
          "1": { name: storage.modifier.localparam.sv }
        endCaptures:
          "1": { name: punctuation.terminator.semicolon.sv }
        patterns:
          - include: "#list-of-param-assignments"
          - include: "#data-type-or-implicit"
  parameter-declaration:
    patterns:
      - name: meta.parameter-declaration.sv
        begin: \b(parameter)\s+(type)\b\s*
        end: (?=[,);])
        beginCaptures:
          "1": { name: storage.modifier.parameter.sv }
          "2": { name: storage.modifier.type.sv }
        endCaptures:
          "1": { name: punctuation.terminator.semicolon.sv }
        patterns:
          - include: "#list-of-type-assignments"
      - name: meta.parameter-declaration.sv
        begin: \b(parameter)\b\s*
        end: (?=[,);])
        beginCaptures:
          "1": { name: storage.modifier.parameter.sv }
        endCaptures:
          "1": { name: punctuation.terminator.semicolon.sv }
        patterns:
          - include: "#list-of-param-assignments"
          - include: "#data-type-or-implicit"
  specparam-declaration:
    name: meta.specparam-declaration.sv
    begin: \b(specparam)\s*
    end: (\;)\s*
    beginCaptures:
      "1": { name: storage.modifier.specparam.sv }
    endCaptures:
      "1": { name: punctuation.terminator.semicolon.sv }
    patterns:
      - include: "#packed-dimension"
      - include: "#list-of-specparam-assignments"
  # A.2.1.2 Port declarations
  inout-declaration:
    patterns:
      - match: \b(inout)\b\s*
        captures:
          "1": { name: storage.modifier.$1.sv }
      - include: "#list-of-port-identifiers"
      - include: "#net-port-type"
  input-declaration:
    patterns:
      - match: \b(input)\b\s*
        captures:
          "1": { name: storage.modifier.$1.sv }
      - include: "#net-port-type"
      - include: "#list-of-port-identifiers"
      - include: "#list-of-variable-identifiers"
      - include: "#variable-port-type"
  output-declaration:
    patterns:
      - match: \b(output)\b\s*
        captures:
          "1": { name: storage.modifier.$1.sv }
      - include: "#net-port-type"
      - include: "#list-of-port-identifiers"
      - include: "#list-of-variable-identifiers"
      - include: "#variable-port-type"
  interface-port-declaration:
    patterns:
      - include: "#interface-identifier"
      - include: "#list-of-interface-identifiers"
      - include: "#modport-identifier"
      - include: "#period"
  ref-declaration:
    patterns:
      - match: \b(ref)\b\s*
        captures:
          "1": { name: storage.modifier.$1.sv }
      - include: "#list-of-variable-identifiers"
      - include: "#variable-port-type"
  # A.2.1.3 Type declarations
  data-declaration:
    patterns:
      - match: \b(const)\b\s*
        captures:
          "1": { name: storage.modifier.const.sv }
      - match: \b(var)\b\s*
        captures:
          "1": { name: storage.modifier.var.sv }
      - include: "#lifetime"
      - include: "#list-of-variable-decl-assignments"
      - include: "#semicolon"
      - include: "#type-declaration"
      - include: "#package-import-declaration"
      - include: "#net-type-declaration"
      - include: "#data-type-or-implicit"
  package-import-declaration:
    begin: \b(import)\b\s*
    end: (\;)\s*
    beginCaptures:
      "1": { name: keyword.control.import.sv }
    endCaptures:
      "1": { name: punctuation.terminator.semicolon.sv }
    patterns:
      - include: "#package-import-item"
      - include: "#comma"
  package-import-item:
    patterns:
      - match: (${identifier})\s*(\:\:)\s*(${identifier})\s*
        captures:
          "1": { name: entity.name.namespace.sv }
          "2": { name: punctuation.separator.scope-resolution.sv }
          # This section handles declarations that could be parameters, functions/tasks, data types, or classes.
          # Unfortunately, without semantic analysis, it's not possible to distinguish between them accurately.
          # In this extension, we use naming conventions to make educated guesses:
          # - If the identifier starts with a capital letter, it's likely a parameter.
          # - If the identifier starts with "t_" or "e_" or ends with "_t" or "_e", it's likely a data type.
          # - Otherwise, it's likely a function/task.
          "3":
            patterns:
              - match: \b([A-Z][a-zA-Z0-9_$]*)\b\s*
                captures:
                  "1": { name: variable.other.constant.sv }
              - match: \b(t_[a-zA-Z0-9_]*|e_[a-zA-Z0-9_]*|.*_t|.*_e)\b\s*
                captures:
                  "1": { name: entity.name.type.sv }
              - match: \b(${functionIdentifier})\b\s*
                captures:
                  "1": { name: entity.name.function.sv }
      - match: (${identifier})\s*(\:\:)\s*(\*)\s*
        captures:
          "1": { name: entity.name.namespace.sv }
          "2": { name: punctuation.separator.scope-resolution.sv }
          "3": { name: keyword.operator.wildcard.sv }
  package-export-declaration:
    begin: \b(export)\b\s*
    end: (\;)\s*
    beginCaptures:
      "1": { name: keyword.control.export.sv }
    endCaptures:
      "1": { name: punctuation.terminator.semicolon.sv }
    patterns:
      - match: \b(\*)\s*(\:\:)\s*(\*)\s*
        captures:
          "1": { name: keyword.operator.wildcard.sv }
          "2": { name: punctuation.separator.scope-resolution.sv }
          "3": { name: keyword.operator.wildcard.sv }
      - include: "#package-import-item"
      - include: "#comma"
  genvar-declaration:
    name: meta.genvar-declaration.sv
    begin: \b(genvar)\b\s*
    end: (\;)\s*
    beginCaptures:
      "1": { name: storage.modifier.genvar.sv }
    endCaptures:
      "1": { name: punctuation.terminator.semicolon.sv }
    patterns:
      - include: "#list-of-genvar-identifiers"
  net-declaration:
    patterns:
      - match: \b(interconnect)\b\s*
        captures:
          "1": { name: entity.name.type.$1.sv }
      - include: "#net-type"
      - include: "#drive-strength"
      - include: "#charge-strength"
      - match: \b(vectored|scalared)\b\s*
        captures:
          "1": { name: storage.modifier.$1.sv }
      - include: "#list-of-net-decl-assignments"
      - include: "#delay3"
      - include: "#data-type-or-implicit"
  type-declaration:
    name: meta.type-declaration.sv
    begin: \b(typedef)\b\s*
    end: (;)\s*
    beginCaptures:
      "1": { name: keyword.control.typedef.sv }
    endCaptures:
      "1": { name: punctuation.terminator.semicolon.sv }
    patterns:
      - include: "#type-identifier"
      - include: "#variable-dimension"
      - include: "#semicolon"
      - include: "#interface-instance-identifier"
      - include: "#constant-bit-select"
      - include: "#period"
      - match: \b(enum|struct|union|class)\b\s*(?=${identifier})
        captures:
          "1": { name: storage.type.$1.sv }
      - match: \b(interface)\b\s+\b(class)\b\s*(?=${identifier})
        captures:
          "1": { name: storage.type.$1.sv }
          "2": { name: storage.type.$2.sv }
      - include: "#data-type"
  net-type-declaration:
    name: meta.net-type-declaration.sv
    begin: \b(nettype)\b\s*
    beginCaptures:
      "1": { name: keyword.control.nettype.sv }
    end: \;
    endCaptures:
      "0": { name: punctuation.terminator.semicolon.sv }
    patterns:
      - name: meta.net-type-declaration-with.sv
        begin: \b(with)\b\s*
        beginCaptures:
          "1": { name: keyword.control.with.sv }
        end: (?=\;)
        patterns:
          - include: "#tf-identifier"
          - include: "#package-scope"
          - include: "#class-scope"
      - include: "#net-type-identifier"
      - include: "#data-type"
  lifetime:
    patterns:
      - match: \b(static|automatic)\b\s*
        captures:
          "1": { name: storage.modifier.$1.sv }
  # A.2.2 Declaration data types
  cast-type:
    patterns:
      - include: "#simple-type"
      - include: "#constant-primary"
      - include: "#signing"
      - include: \b(string)\b\s*
        captures:
          "1": { name: entity.name.type.$1.sv }
      - match: \b(const)\b\s*
        captures:
          "1": { name: storage.modifier.$1.sv }
  data-type:
    patterns:
      - include: "#signing"
      - include: "#dimension"
      - include: "#integer-vector-type"
      - include: "#integer-atom-type"
      - include: "#non-integer-type"
      - begin: \b(struct|union(?:\s+tagged)?)\b\s*(?:(?:(packed)\b(?:\s+(signed|unsigned))?)\b\s*)?
        end: (?<=\})\s*((?:\[.*?\])*)\s*
        name: meta.struct.sv
        beginCaptures:
          "1":
            patterns:
              - include: "#struct-union"
          "2": { name: storage.modifier.packed.sv }
          "3":
            patterns:
              - include: "#signing"
        endCaptures:
          "1":
            patterns:
              - include: "#dimension"
        patterns:
          - begin: \{
            end: \}
            name: meta.struct.body.sv
            beginCaptures:
              "0": { name: punctuation.section.braces.begin.sv }
            endCaptures:
              "0": { name: punctuation.section.braces.end.sv }
            patterns:
              - include: "#struct-union-member"
              - include: "#comment"
              - include: "#compiler-directive"
          - include: "#comment"
          - include: "#compiler-directive"
      - begin: (?=\benum\b)
        end: (\})\s*
        name: meta.enum.sv
        endCaptures:
          "1": { name: punctuation.section.braces.end.sv }
        patterns:
          - name: meta.enum-header.sv
            begin: \b(enum)\b\s*
            end: (?=\{)
            beginCaptures:
              "1": { name: storage.type.enum.sv }
            patterns:
              - include: "#comment"
              - include: "#compiler-directive"
              - include: "#enum-base-type"
          # enum to beginning of '{'
          # '{' to beginning of '}'
          - name: meta.enum-body.sv
            begin: (\{)\s*
            end: (?=\})
            beginCaptures:
              "1": { name: punctuation.section.braces.begin.sv }
            patterns:
              - include: "#comment"
              - include: "#compiler-directive"
              - include: "#enum-name-declaration"
              - include: "#comma"
      - match: \b(string)\b\s*
        captures:
          "1": { name: entity.name.type.$1.sv }
      - match: \b(chandle)\b\s*
        captures:
          "1": { name: entity.name.type.$1.sv }
      - match: \b(virtual)\b\s*
        captures:
          "1": { name: storage.modifier.$1.sv }
      - match: \b(interface)\b\s*
        captures:
          "1": { name: storage.type.$1.sv }
      - include: "#parameter-value-assignment"
      - include: "#period"
      - include: "#type-identifier"
      - include: "#class-scope"
      - include: "#package-scope"
      - include: "#class-type"
      - match: \b(event)\b\s*
        captures:
          "1": { name: entity.name.type.$1.sv }
      - include: "#ps-covergroup-identifier"
      - include: "#type-reference"
  data-type-or-implicit:
    patterns:
      - include: "#data-type"
      - include: "#implicit-data-type"
  implicit-data-type:
    patterns:
      - include: "#signing"
      - include: "#dimension"
  enum-base-type:
    patterns:
      - include: "#integer-atom-type"
      - include: "#integer-vector-type"
      - include: "#signing"
      - include: "#dimension"
      - include: "#type-identifier"
  enum-name-declaration:
    begin: (${identifier})
    end: (?=\,|\})
    beginCaptures:
      "1": { name: variable.other.enummember.sv }
    patterns:
      - name: meta.enum-range.sv
        begin: (\[)\s*
        end: (\])\s*
        beginCaptures:
          "1": { name: punctuation.section.brackets.begin.sv }
        endCaptures:
          "1": { name: punctuation.section.brackets.end.sv }
        patterns:
          - include: "#integral-number"
          - include: "#colon"
      - name: meta.enum-assignment.sv
        begin: (\=)\s*(?!\=)
        end: (?=\,|\})
        beginCaptures:
          "1": { name: keyword.operator.assignment.sv }
        patterns:
          - include: "#constant-expression"
  class-scope:
    patterns:
      - include: "#package-scope"
      - match: (${identifier})\s*(\#\s*\(.*?\)\s*)?(::)\s*
        name: meta.class-scope.sv
        captures:
          "1": { name: entity.name.type.sv }
          "2":
            patterns:
              - include: "#parameter-value-assignment"
          "3": { name: punctuation.separator.scope-resolution.sv }
  class-type:
    patterns:
      - include: "#parameter-value-assignment"
      - include: "#ps-class-identifier"
  integer-type:
    patterns:
      - include: "#integer-atom-type"
      - include: "#integer-vector-type"
  integer-atom-type:
    match: \b(byte|shortint|int|longint|integer|time)\b\s*
    captures:
      "1": { name: entity.name.type.$1.sv }
  integer-vector-type:
    match: \b(bit|logic|reg)\b\s*
    captures:
      "1": { name: entity.name.type.$1.sv }
  non-integer-type:
    match: \b(shortreal|real|realtime)\b\s*
    captures:
      "1": { name: entity.name.type.$1.sv }
  net-type:
    match: \b(supply0|supply1|tri|triand|trior|trireg|tri0|tri1|uwire|wire|wand|wor)\b\s*
    captures:
      "1": { name: entity.name.type.$1.sv }
  net-port-type:
    patterns:
      - match: \b(interconnect)\b\s*
        captures:
          "1": { name: entity.name.type.$1.sv }
      - include: "#net-type"
      - include: "#net-type-identifier"
      - include: "#implicit-data-type"
      - include: "#data-type-or-implicit"
  variable-port-type:
    patterns:
      - include: "#var-data-type"
  var-data-type:
    patterns:
      - match: \b(var)\b\s*
        captures:
          "1": { name: storage.modifier.var.sv }
      - include: "#data-type"
      - include: "#data-type-or-implicit"
  signing:
    match: \b(signed|unsigned)\b\s*
    captures:
      "1": { name: storage.modifier.$1.sv }
  simple-type:
    patterns:
      - include: "#integer-type"
      - include: "#non-integer-type"
      - include: "#ps-type-identifier"
      - include: "#ps-parameter-identifier"
  struct-union-member:
    patterns:
      - begin: (\=)\s*(?!\=)
        end: ${assignmentEnd}
        beginCaptures:
          "1": { name: keyword.operator.assignment.sv }
        patterns:
          - include: "#expression"
      - include: "#attribute-instance"
      - include: "#random-qualifier"
      - include: "#list-of-variable-decl-assignments"
      - include: "#semicolon"
      - include: "#data-type-or-void"
  data-type-or-void:
    patterns:
      - match: \b(void)\b\s*
        captures:
          "1": { name: entity.name.type.$1.sv }
      - include: "#data-type"
  struct-union:
    patterns:
      - match: \b(struct)\b\s*
        captures:
          "1": { name: storage.type.$1.sv }
      - match: \b(union)\b\s+(tagged)\s*
        captures:
          "1": { name: storage.type.$1.sv }
          "2": { name: storage.modifier.$2.sv }
      - match: \b(union)\b\s*
        captures:
          "1": { name: storage.type.$1.sv }
  type-reference:
    name: meta.type-reference.sv
    begin: \b(type)\s*(\()\s*
    end: (\))\s*
    beginCaptures:
      "1": { name: entity.name.function.$1.sv }
      "2": { name: punctuation.section.group.begin.sv }
    endCaptures:
      "1": { name: punctuation.section.group.end.sv }
    patterns:
      - include: "#expression"
      - include: "#data-type"
  # A.2.2.2 Strengths
  drive-strength:
    name: meta.drive-strength.sv
    match: (\()\s*(supply0|strong0|pull0|weak0|supply1|strong1|pull1|weak1|highz0|highz1)\s*(\,)\s*(supply0|strong0|pull0|weak0|supply1|strong1|pull1|weak1|highz0|highz1)\s*(\))
    captures:
      "1": { name: punctuation.section.group.begin.sv }
      "2": { name: storage.modifier.$2.sv }
      "3": { name: punctuation.separator.comma.sv }
      "4": { name: storage.modifier.$4.sv }
      "5": { name: punctuation.section.group.end.sv }
  strength0:
    match: \b(supply0|strong0|pull0|weak0)\b
    name: storage.modifier.$1.sv
  strength1:
    match: \b(supply1|strong1|pull1|weak1)\b
    name: storage.modifier.$1.sv
  charge-strength:
    match: (\()\s*(small|medium|large)\s*(\))
    captures:
      "1": { name: punctuation.section.group.begin.sv }
      "2": { name: storage.modifier.$2.sv }
      "3": { name: punctuation.section.group.end.sv }
  # A.2.2.3 Delays
  delay3:
    patterns:
      - name: meta.delay3.sv
        begin: (\#)\s*(\()\s*
        end: (\))\s*
        beginCaptures:
          "1": { name: punctuation.definition.delay.sv }
          "2": { name: punctuation.section.group.begin.sv }
        endCaptures:
          "1": { name: punctuation.section.group.end.sv }
        patterns:
          - include: "#comma"
          - include: "#mintypmax-expression"
      - match: (\#)\s*
        captures:
          "1": { name: punctuation.definition.delay.sv }
      - include: "#delay-value"
  delay2:
    patterns:
      - name: meta.delay2.sv
        begin: (\#)\s*(\()\s*
        end: (\))\s*
        beginCaptures:
          "1": { name: punctuation.definition.delay.sv }
          "2": { name: punctuation.section.group.begin.sv }
        endCaptures:
          "1": { name: punctuation.section.group.end.sv }
        patterns:
          - include: "#comma"
          - include: "#mintypmax-expression"
      - match: (\#)\s*
        captures:
          "1": { name: punctuation.definition.delay.sv }
      - include: "#delay-value"
  delay-value:
    patterns:
      - match: \b(1step)\b\s*
        captures:
          "1": { name: constant.numeric.$1.sv }
      - include: "#unsigned-number"
      - include: "#real-number"
      - include: "#ps-identifier"
      - include: "#time-literal"
  # A.2.3 Declaration lists
  list-of-defparam-assignments:
    patterns:
      - include: "#comma"
      - include: "#defparam-assignment"
  list-of-genvar-identifiers:
    patterns:
      - include: "#comma"
      - include: "#genvar-identifier"
  list-of-interface-identifiers:
    patterns:
      - include: "#comma"
      - include: "#dimension"
      - include: "#interface-identifier"
  list-of-net-decl-assignments:
    patterns:
      - include: "#comma"
      - include: "#net-decl-assignment"
  list-of-param-assignments:
    patterns:
      - include: "#comma"
      - include: "#param-assignment"
  list-of-port-identifiers:
    patterns:
      - include: "#comma"
      - include: "#dimension"
      - include: "#port-identifier"
  list-of-udp-port-identifiers:
    patterns:
      - include: "#comma"
      - include: "#port-identifier"
  list-of-specparam-assignments:
    patterns:
      - include: "#comma"
      - include: "#specparam-assignment"
  list-of-tf-variable-identifiers:
    patterns:
      - include: "#comma"
      - include: "#variable-identifier"
      - include: "#dimension"
  list-of-type-assignments:
    patterns:
      - include: "#comma"
      - include: "#type-assignment"
  list-of-variable-decl-assignments:
    patterns:
      - include: "#comma"
      - include: "#variable-decl-assignment"
  list-of-variable-identifiers:
    patterns:
      - include: "#comma"
      - include: "#variable-identifier"
      - include: "#variable-dimension"
  list-of-variable-port-identifiers:
    patterns:
      - include: "#comma"
      - include: "#variable-identifier"
      - include: "#variable-dimension"
      - name: meta.variable-port-identifier.sv
        begin: (\=)\s*(?!\=)
        end: ${assignmentEnd}
        beginCaptures:
          "1": { name: keyword.operator.assignment.sv }
        patterns:
          - include: "#constant-expression"
  # A.2.4 Declaration assignments
  defparam-assignment:
    patterns:
      - name: meta.defparam-assignment.sv
        begin: (\=)\s*(?!\=)
        end: ${assignmentEnd}
        beginCaptures:
          "1": { name: keyword.operator.assignment.sv }
        patterns:
          - include: "#constant-mintypmax-expression"
      - include: "#hierarchical-parameter-identifier"
  net-decl-assignment:
    patterns:
      - include: "#net-identifier"
      - include: "#dimension"
  param-assignment:
    patterns:
      - name: meta.param-assignment.sv
        begin: (\=)\s*(?!\=)
        end: ${assignmentEnd}
        beginCaptures:
          "1": { name: keyword.operator.assignment.sv }
        patterns:
          - include: "#constant-param-expression"
      - include: "#parameter-identifier"
      - include: "#dimension"
  specparam-assignment:
    patterns:
      - name: meta.specparam-assignment.sv
        begin: (\=)\s*(?!\=)
        end: ${assignmentEnd}
        beginCaptures:
          "1": { name: keyword.operator.assignment.sv }
        patterns:
          - include: "#constant-mintypmax-expression"
      - include: "#specparam-identifier"
      - include: "#pulse-control-specparam"
  type-assignment:
    patterns:
      - name: meta.type-assignment.sv
        begin: (\=)\s*(?!\=)
        end: ${assignmentEnd}
        beginCaptures:
          "1": { name: keyword.operator.assignment.sv }
        patterns:
          - include: "#data-type"
      - match: (${identifier})\s*
        captures:
          "1": { name: entity.name.type.sv }
  # pulse_control_specparam: too complicated, not implemented
  error-limit-value:
    patterns:
      - include: "#limit-value"
  reject-limit-value:
    patterns:
      - include: "#limit-value"
  limit-value:
    patterns:
      - include: "#constant-mintypmax-expression"
  variable-decl-assignment:
    patterns:
      - include: "#dimension"
      - include: "#variable-identifier"
      - include: "#dynamic-array-variable-identifier"
      - include: "#class-variable-identifier"
  class-new:
    patterns:
      - include: "#class-scope"
      - match: \b(new)\b\s*
        captures:
          "1": { name: entity.name.function.sv }
      - name: meta.class-new.sv
        begin: (\()\s*
        end: (\))\s*
        beginCaptures:
          "1": { name: punctuation.section.group.begin.sv }
        endCaptures:
          "1": { name: punctuation.section.group.end.sv }
        patterns:
          - include: "#list-of-arguments"
      - include: "#expression"
  dynamic-array-new:
    patterns:
      - match: \b(new)\b\s*
        captures:
          "1": { name: entity.name.function.sv }
      - include: "#dimension"
  # A.2.5 Declaration ranges
  dimension:
    name: meta.dimension.sv
    begin: (\[)\s*
    beginCaptures:
      "1": { name: punctuation.section.brackets.begin.sv }
    end: (\])\s*
    endCaptures:
      "1": { name: punctuation.section.brackets.end.sv }
    patterns:
      - match: (\*)\s*
        captures:
          "1": { name: keyword.operator.wildcard.sv }
      - match: (\$)\s*(?!\w)
        captures:
          "1": { name: constant.numeric.dollar.sv }
      - include: "#constant-range-expression"
      - include: "#constant-range"
      - include: "#constant-expression"
      - include: "#data-type"
  # A.2.6 Function declarations
  function-data-type-or-implicit:
    patterns:
      - include: "#data-type-or-void"
      - include: "#implicit-data-type"
  function-declaration:
    name: meta.function-declaration.sv
    begin: (?=\b(function)\s*)
    end: \b(endfunction)\b\s*(?:(\:)\s*(${identifier})\s*)?
    endCaptures:
      "1": { name: storage.type.function.sv }
      "2": { name: punctuation.separator.colon.sv }
      "3": { name: entity.name.function.sv }
    patterns:
      - name: meta.function-declaration-header.sv
        begin: \b(function)\s*
        end: (\;)\s*
        beginCaptures:
          "1": { name: storage.type.$1.sv }
        endCaptures:
          "1": { name: punctuation.terminator.semicolon.sv }
        patterns:
          - include: "#lifetime"
          # In class, the function name can be 'new'
          - match: \b(new)\b\s*
            captures:
              "1": { name: entity.name.function.sv }
          - include: "#function-identifier"
          - include: "#interface-identifier"
          - include: "#class-scope"
          - begin: (\()\s*
            end: (\))\s*
            beginCaptures:
              "1": { name: punctuation.section.group.begin.sv }
            endCaptures:
              "1": { name: punctuation.section.group.end.sv }
            patterns:
              - include: "#tf-port-list"
          - include: "#function-data-type-or-implicit"
      - name: meta.function-declaration-body.sv
        begin: (?<=\;\s*)
        end: (?=\b(endfunction)\s*)
        patterns:
          # super.new is copied from class constructor declaration
          - begin: \b(super)\b\s*(\.)\s*(new)\b\s*
            end: (\;)\s*
            beginCaptures:
              "1": { name: variable.language.super.sv }
              "2": { name: punctuation.accessor.dot.sv }
              "3": { name: entity.name.function.sv }
            endCaptures:
              "1": { name: punctuation.terminator.semicolon.sv }
            patterns:
              - begin: (\()\s*
                end: (\))\s*
                beginCaptures:
                  "1": { name: punctuation.section.group.begin.sv }
                endCaptures:
                  "1": { name: punctuation.section.group.end.sv }
                patterns:
                  - include: "#list-of-arguments"
          - include: "#comment"
          - include: "#compiler-directive"
          - include: "#tf-item-declaration"
          - include: "#block-item-declaration"
          - include: "#function-statement-or-null"
  function-prototype:
    begin: \b(function)\s*
    end: (?=\;|\)|\{)
    beginCaptures:
      "1": { name: storage.type.$1.sv }
    patterns:
      - include: "#function-data-type-or-implicit"
      - include: "#function-identifier"
      - begin: (\()\s*
        end: (\))\s*
        beginCaptures:
          "1": { name: punctuation.section.group.begin.sv }
        endCaptures:
          "1": { name: punctuation.section.group.end.sv }
        patterns:
          - include: "#tf-port-list"
  dpi-import-export:
    begin: \b(import|export)\s*
    end: (\;)\s*
    beginCaptures:
      "1": { name: keyword.control.$1.sv }
    endCaptures:
      "1": { name: punctuation.terminator.semicolon.sv }
    patterns:
      - include: "#dpi-spec-string"
      - include: "#dpi-function-import-property"
      - include: "#dpi-task-import-property"
      - include: "#c-identifier"
      - include: "#dpi-function-proto"
      - include: "#dpi-task-proto"
      - include: "#function-identifier"
      - include: "#task-identifier"
  dpi-spec-string:
    patterns:
      - include: "#string"
  dpi-function-import-property:
    patterns:
      - match: \b(context|pure)\b\s*
        captures:
          "1": { name: storage.modifier.$1.sv }
  dpi-task-import-property:
    patterns:
      - match: \b(context)\b\s*
        captures:
          "1": { name: storage.modifier.$1.sv }
  dpi-function-proto:
    patterns:
      - include: "#function-prototype"
  dpi-task-proto:
    patterns:
      - include: "#task-prototype"
  # A.2.7 Task declarations
  task-declaration:
    begin: (?=\b(task)\s*)
    end: \b(endtask)\b\s*(?:(\:)\s*(${identifier})\s*)?
    endCaptures:
      "1": { name: storage.type.task.sv }
      "2": { name: punctuation.separator.colon.sv }
      "3": { name: entity.name.type.task.sv }
    patterns:
      - begin: \b(task)\b\s*
        end: (?=\;)
        beginCaptures:
          "1": { name: storage.type.$1.sv }
        patterns:
          - include: "#lifetime"
          - include: "#task-identifier"
          - include: "#interface-identifier"
          - include: "#class-scope"
          - begin: (\()\s*
            end: (\))\s*
            beginCaptures:
              "1": { name: punctuation.section.group.begin.sv }
            endCaptures:
              "1": { name: punctuation.section.group.end.sv }
            patterns:
              - include: "#tf-port-list"
      - begin: (\;)\s*
        end: (?=\b(endtask)\s*)
        beginCaptures:
          "1": { name: punctuation.terminator.semicolon.sv }
        patterns:
          - include: "#tf-item-declaration"
          - include: "#block-item-declaration"
          - include: "#statement-or-null"
  tf-item-declaration:
    patterns:
      - include: "#block-item-declaration"
      - include: "#tf-port-declaration"
  tf-port-list:
    patterns:
      - include: "#comma"
      - include: "#tf-port-item"
  tf-port-item:
    patterns:
      - include: "#attribute-instance"
      - match: \b(var)\b\s*
        captures:
          "1": { name: storage.modifier.var.sv }
      - include: "#tf-port-direction"
      - include: "#port-identifier"
      - include: "#variable-dimension"
      - begin: (\=)\s*(?!\=)
        end: (?=\,|\))
        beginCaptures:
          "1": { name: keyword.operator.assignment.sv }
        patterns:
          - include: "#expression"
      - include: "#data-type-or-implicit"
  tf-port-direction:
    patterns:
      - match: \b(const)\b\s*
        captures:
          "1": { name: storage.modifier.$1.sv }
      - match: \b(ref)\b\s*
        captures:
          "1": { name: storage.modifier.$1.sv }
      - include: "#port-direction"
  tf-port-declaration:
    patterns:
      - include: "#attribute-instance"
      - include: "#tf-port-direction"
      - match: \b(var)\b\s*
        captures:
          "1": { name: storage.modifier.var.sv }
      - include: "#list-of-tf-variable-identifiers"
      - include: "#data-type-or-implicit"
      - include: "#semicolon"
  task-prototype:
    begin: \b(task)\s*
    end: (?=\;|\)|\{)
    beginCaptures:
      "1": { name: storage.type.$1.sv }
    patterns:
      - include: "#task-identifier"
      - begin: (\()\s*
        end: (\))\s*
        beginCaptures:
          "1": { name: punctuation.section.group.begin.sv }
        endCaptures:
          "1": { name: punctuation.section.group.end.sv }
        patterns:
          - include: "#tf-port-list"
  # A.2.8 Block item declarations
  block-item-declaration:
    patterns:
      - include: "#attribute-instance"
      - include: "#data-declaration"
      - include: "#local-parameter-declaration"
      - include: "#parameter-declaration"
      - include: "#let-declaration"
  # A.2.10 Assertion declarations
  assertion-item-declaration:
    patterns:
      - include: "#property-declaration"
      - include: "#sequence-declaration"
      - include: "#let-declaration"
  # A.2.12 Let declarations
  let-declaration:
    name: meta.let-declaration.sv
    begin: \b(let)\s*
    end: (\;)\s*
    beginCaptures:
      "1": { name: storage.type.$1.sv }
    endCaptures:
      "1": { name: punctuation.terminator.semicolon.sv }
    patterns:
      - name: meta.let-declaration-header.sv
        begin: (\()\s*
        end: (\))\s*
        beginCaptures:
          "1": { name: punctuation.section.group.begin.sv }
        endCaptures:
          "1": { name: punctuation.section.group.end.sv }
        patterns:
          - include: "#let-port-list"
      - begin: (\=)\s*(?!\=)
        end: (?=\;)
        beginCaptures:
          "1": { name: keyword.operator.assignment.sv }
        patterns:
          - include: "#expression"
      - include: "#let-identifier"
  let-identifier:
    match: ${functionIdentifierStart}(${functionIdentifier})\s*(?=\()
    captures:
      "1": { name: entity.name.function.sv }
  let-port-list:
    patterns:
      - include: "#comma"
      - include: "#let-port-item"
  let-port-item:
    patterns:
      - include: "#attribute-instance"
      - begin: (\=)\s*(?!\=)
        end: (?=\,|\))
        beginCaptures:
          "1": { name: keyword.operator.assignment.sv }
        patterns:
          - include: "#expression"
      - include: "#variable-dimension"
      - include: "#formal-port-identifier"
      - include: "#let-formal-type"
  let-formal-type:
    patterns:
      - match: \b(untyped)\b\s*
        captures:
          "1": { name: storage.modifier.$1.sv }
      - include: "#data-type-or-implicit"
  let-expression:
    patterns:
      - include: "#package-scope"
      - include: "#let-identifier"
      - name: meta.let-expression.sv
        begin: (\()\s*
        end: (\))\s*
        beginCaptures:
          "1": { name: punctuation.section.group.begin.sv }
        endCaptures:
          "1": { name: punctuation.section.group.end.sv }
        patterns:
          - include: "#let-list-of-arguments"
  let-list-of-arguments:
    patterns:
      - begin: (?<!\w)(\.)\s*(${identifier})\s*(\()\s*
        end: (\))\s*
        beginCaptures:
          "1": { name: punctuation.definition.named-parameter-assignment.sv }
          "2": { name: variable.parameter.sv }
          "3": { name: punctuation.section.group.begin.sv }
        endCaptures:
          "1": { name: punctuation.section.group.end.sv }
        patterns:
          - include: "#let-actual-arg"
      - include: "#comma"
      - include: "#let-actual-arg"
  let-actual-arg:
    patterns:
      - include: "#expression"
  # A.4 Instantiations
  # A.4.1 Instantiation
  # A.4.1.1 Module instantiation
  module-instantiation:
    patterns:
      - include: "#module-identifier"
      - include: "#parameter-value-assignment"
      - include: "#hierarchical-instance"
      - include: "#comma"
      - include: "#semicolon"
  parameter-value-assignment:
    begin: (\#)\s*(\()
    end: (\))\s*
    beginCaptures:
      "1": { name: punctuation.definition.parameter-assignment-or-delay.sv }
      "2": { name: punctuation.section.group.begin.sv }
    endCaptures:
      "1": { name: punctuation.section.group.end.sv }
    patterns:
      - include: "#list-of-parameter-assignments"
  list-of-parameter-assignments:
    patterns:
      - include: "#named-parameter-assignment"
      - include: "#ordered-parameter-assignment"
      - include: "#comma"
  ordered-parameter-assignment:
    patterns:
      - include: "#param-expression"
  named-parameter-assignment:
    name: meta.named-parameter-assignment.sv
    begin: (?<!\w)(\.)\s*(${identifier})\s*
    end: (?=\)|,)
    beginCaptures:
      "1": { name: punctuation.definition.named-parameter-assignment.sv }
      "2": { name: variable.parameter.sv }
    patterns:
      - name: meta.named-parameter-assignment.sv
        begin: (\()\s*
        end: (\))\s*
        beginCaptures:
          "1": { name: punctuation.section.group.begin.sv }
        endCaptures:
          "1": { name: punctuation.section.group.end.sv }
        patterns:
          - include: "#param-expression"
  hierarchical-instance:
    begin: (?<!\.\s*)(${identifier})\s*(\()
    end: (\))\s*
    beginCaptures:
      "1": { name: variable.other.sv }
      "2": { name: punctuation.section.group.begin.sv }
    endCaptures:
      "1": { name: punctuation.section.group.end.sv }
    patterns:
      - include: "#list-of-port-connections"
  name-of-instance:
    patterns:
      - include: "#instance-identifier"
      - include: "#dimension"
  list-of-port-connections:
    patterns:
      - include: "#named-port-connection"
      - include: "#ordered-port-connection"
      - include: "#comma"
  ordered-port-connection:
    patterns:
      - include: "#attribute-instance"
      - include: "#expression"
  named-port-connection:
    begin: (\.)\s*(${identifier})\s*
    end: (?=\)|,)
    beginCaptures:
      "1": { name: punctuation.definition.named-port-connection.sv }
      "2": { name: variable.parameter.sv }
    patterns:
      - name: meta.named-port-connection.sv
        begin: (\()\s*
        end: (\))\s*
        beginCaptures:
          "1": { name: punctuation.section.group.begin.sv }
        endCaptures:
          "1": { name: punctuation.section.group.end.sv }
        patterns:
          - include: "#expression"
  # A.4.2 Generated instantiation
  generate-region:
    name: meta.generate-region.sv
    begin: \b(generate)\b\s*
    end: \b(endgenerate)\b\s*
    beginCaptures:
      "1": { name: keyword.control.$1.sv }
    endCaptures:
      "1": { name: keyword.control.$1.sv }
    patterns:
      - include: "#generate-item"
  loop-generate-construct:
    patterns:
      - name: meta.loop-generate-construct.sv
        begin: \b(for)\b\s*(\()\s*
        end: (\))\s*
        beginCaptures:
          "1": { name: keyword.control.for.sv }
          "2": { name: punctuation.section.group.begin.sv }
        endCaptures:
          "1": { name: punctuation.section.group.end.sv }
        patterns:
          - include: "#genvar-initialization"
          - include: "#genvar-expression"
          - include: "#genvar-iteration"
          - include: "#semicolon"
  genvar-initialization:
    patterns:
      - match: \b(genvar)\b\s*
        captures:
          "1": { name: entity.name.type.$1.sv }
      - include: "#genvar-identifier"
      - name: meta.genvar-initialization.sv
        begin: (\=)\s*(?!\=)
        end: (?=\;)
        beginCaptures:
          "1": { name: keyword.operator.assignment.sv }
        patterns:
          - include: "#constant-expression"
  genvar-iteration:
    patterns:
      - include: "#genvar-identifier"
      - include: "#assignment-operator"
      - include: "#genvar-expression"
      - include: "#inc-or-dec-operator"
  conditional-generate-construct:
    patterns:
      - include: "#if-generate-construct"
      - include: "#case-generate-construct"
  if-generate-construct:
    patterns:
      - begin: \b(if)\b\s*(\()\s*
        end: (\))\s*
        beginCaptures:
          "1": { name: keyword.control.$1.sv }
          "2": { name: punctuation.section.group.begin.sv }
        endCaptures:
          "1": { name: punctuation.section.group.end.sv }
        patterns:
          - include: "#constant-expression"
      - match: \b(else)\b\s*
        captures:
          "1": { name: keyword.control.$1.sv }
  case-generate-construct:
    begin: (?=\b(case)\b)
    end: \b(endcase)\b\s*
    endCaptures:
      "1": { name: keyword.control.$1.sv }
    patterns:
      # Header
      - name: meta.case-generate-construct-header.sv
        begin: \b(case)\b\s*(\()\s*
        end: (?=\))
        beginCaptures:
          "1": { name: keyword.control.$1.sv }
          "2": { name: punctuation.section.group.begin.sv }
        patterns:
          - include: "#constant-expression"
      # Body
      - name: meta.case-generate-construct-body.sv
        begin: (\))\s*
        end: (?=\b(endcase)\b)
        beginCaptures:
          "1": { name: punctuation.section.group.end.sv }
        patterns:
          - include: "#case-generate-item"
  case-generate-item:
    patterns:
      - include: "#constant-expression"
      - include: "#colon"
      - include: "#generate-block"
      - match: \b(default)\b\s*
        captures:
          "1": { name: keyword.control.$1.sv }
  generate-block:
    patterns:
      # The seq-block and generate-block have the same beginning ('begin'). Therefore, include 'generate-item' in seq-block.
      - include: "#generate-item"
      - match: \b(${identifier})\s*(\:)\s*
        captures:
          "1": { name: variable.other.block.sv }
          "2": { name: punctuation.separator.colon.sv }
      - match: \b(begin)\b\s*
        captures:
          "1": { name: keyword.control.begin.sv }
      - match: \b(end)\b\s*
        captures:
          "1": { name: keyword.control.end.sv }
      - match: (\:)\s*(${identifier})\s*
        captures:
          "1": { name: punctuation.separator.colon.sv }
          "2": { name: variable.other.block.sv }
  generate-item:
    patterns:
      - include: "#module-or-generate-item"
      - include: "#interface-or-generate-item"
      - include: "#checker-or-generate-item"
  # A.6 Behavioral statements
  # A.6.1 Continuous assignment and net alias statements
  continuous-assign:
    patterns:
      - match: \b(assign)\b\s*
        captures:
          "1": { name: keyword.control.assign.sv }
      - include: "#drive-strength"
      - include: "#delay3"
      - include: "#delay-control"
      - include: "#list-of-net-assignments"
      - include: "#list-of-variable-assignments"
  # A.6.2 Procedural blocks and assignments
  initial-construct:
    patterns:
      - match: \b(initial)\b\s*
        captures:
          "1": { name: keyword.control.initial.sv }
      - include: "#statement-or-null"
  always-construct:
    patterns:
      - match: \b(always|always_comb|always_latch|always_ff)\b\s*
        captures:
          "1": { name: keyword.control.$1.sv }
      - include: "#statement"
  final-construct:
    patterns:
      - match: \b(final)\b\s*
        captures:
          "1": { name: keyword.control.final.sv }
      - include: "#function_statement"
  blocking-assignment:
    patterns:
      - include: "#equals"
      - include: "#assignment-operator"
  assignment-operator:
    patterns:
      - match: (=|\+=|-=|\*=|\/=|%=|&=|\|=|\^=|<<=|>>=|<<<=|>>>=)\s*(?!\=)
        captures:
          "1": { name: keyword.operator.assignment.sv }
  operator-assignment:
    patterns:
      - include: "#assignment-operator"
      - include: "#variable-lvalue"
      - include: "#expression"
  nonblocking-assignment:
    patterns:
      - match: (\<=)\s*
        captures:
          "1": { name: keyword.operator.assignment.sv }
  procedural-continuous-assignment:
    patterns:
      - match: \b(assign)\b\s*
        captures:
          "1": { name: keyword.control.assign.sv }
      - match: \b(deassign)\b\s*
        captures:
          "1": { name: keyword.control.deassign.sv }
      - match: \b(force)\b\s*
        captures:
          "1": { name: keyword.control.force.sv }
      - match: \b(release)\b\s*
        captures:
          "1": { name: keyword.control.release.sv }
      - include: "#variable-assignment"
      - include: "#net-assignment"
      - include: "#variable-lvalue"
      - include: "#net-lvalue"
  variable-assignment:
    patterns:
      - include: "#variable-lvalue"
      - include: "#equals"
      - include: "#expression"
  # A.6.3 Parallel and sequential blocks
  action-block:
    patterns:
      - match: \b(else)\b\s*
        captures:
          "1": { name: keyword.control.$1.sv }
  seq-block:
    name: meta.seq-block.sv
    begin: \b(begin)\s*(?:(\:)\s*(${identifier})\s*)?
    end: \b(end)\b\s*(?:(\:)\s*(${identifier})\s*)?
    beginCaptures:
      "1": { name: keyword.control.begin.sv }
      "2": { name: punctuation.separator.colon.sv }
      "3": { name: variable.other.block.sv }
    endCaptures:
      "1": { name: keyword.control.end.sv }
      "2": { name: punctuation.separator.colon.sv }
      "3": { name: variable.other.block.sv }
    patterns:
      - include: "#generate-item"
      - include: "#block-item-declaration"
      - include: "#statement-or-null"
  par-block:
    begin: \b(fork)\s*(?:(\:)\s*(${identifier})\s*)?
    end: \b(join|join_any|join_none)\b\s*(?:(\:)\s*(${identifier})\s*)?
    beginCaptures:
      "1": { name: keyword.control.fork.sv }
      "2": { name: punctuation.separator.colon.sv }
      "3": { name: variable.other.block.sv }
    endCaptures:
      "1": { name: keyword.control.$1.sv }
      "2": { name: punctuation.separator.colon.sv }
      "3": { name: variable.other.block.sv }
    patterns:
      - include: "#block-item-declaration"
      - include: "#statement-or-null"
  # A.6.4 Statements
  statement-or-null:
    patterns:
      - include: "#statement"
      - include: "#attribute-instance"
      - match: \;
        name: punctuation.terminator.semicolon.sv
  statement:
    patterns:
      - match: (?<!\.)(${identifier})\s*(\:)\s*
        captures:
          "1":
            patterns:
              - include: "#block-identifier"
          "2": { name: punctuation.separator.colon.sv }
      - include: "#attribute-instance"
      - include: "#statement-item"
  statement-item:
    patterns:
      - include: "#semicolon"
      - name: meta.assignments.sv
        begin: (\=)\s*(?!\=)
        end: ${assignmentEnd}
        beginCaptures:
          "1": { name: keyword.operator.assignment.sv }
        patterns:
          - include: "#expression"
          - include: "#dynamic-array-new"
          - include: "#class-new"
          - include: "#delay-or-event-control"
      - include: "#blocking-assignment"
      - include: "#nonblocking-assignment"
      - include: "#procedural-continuous-assignment"
      - include: "#case-statement"
      - include: "#conditional-statement"
      - include: "#inc-or-dec-expression"
      - include: "#subroutine-call-statement"
      - include: "#disable-statement"
      - include: "#event-trigger"
      # Conflict: The 'generate for' and 'for' statements have the same beginning. Therefore, they are combined here:
      - name: meta.for.sv
        begin: \b(for)\b\s*(\()\s*
        end: (\))\s*
        beginCaptures:
          "1": { name: keyword.control.for.sv }
          "2": { name: punctuation.section.group.begin.sv }
        endCaptures:
          "1": { name: punctuation.section.group.end.sv }
        patterns:
          - include: "#genvar-initialization"
          - include: "#genvar-iteration"
          - include: "#genvar-expression"
          - include: "#semicolon"
          - include: "#for-initialization"
          - include: "#for-step"
          - include: "#expression"
      - include: "#loop-statement"
      - include: "#jump-statement"
      - include: "#par-block"
      - include: "#procedural-timing-control-statement"
      - include: "#seq-block"
      - include: "#wait-statement"
      - include: "#procedural-assertion-statement"
      - include: "#clocking-drive"
      - include: "#randsequence-statement"
      - include: "#randcase-statement"
      - include: "#expect-property-statement"
      - include: "#expression"
  function-statement:
    patterns:
      - include: "#statement"
  function-statement-or-null:
    patterns:
      - include: "#function-statement"
      - include: "#attribute-instance"
      - include: "#semicolon"
  variable-identifier-list:
    patterns:
      - include: "#variable-identifier"
      - include: "#comma"
  # A.6.5 Timing control statements
  procedural-timing-control-statement:
    patterns:
      - include: "#delay-or-event-control"
  delay-or-event-control:
    patterns:
      - include: "#delay-control"
      - include: "#event-control"
      - begin: \b(repeat)\s*(\()\s*
        end: (\))\s*
        beginCaptures:
          "1": { name: keyword.control.$1.sv }
          "2": { name: punctuation.section.group.begin.sv }
        endCaptures:
          "1": { name: punctuation.section.group.end.sv }
        patterns:
          - include: "#expression"
  delay-control:
    patterns:
      - name: meta.delay-control.sv
        begin: (\#)\s*(\()\s*
        end: (\))\s*
        beginCaptures:
          "1": { name: punctuation.definition.delay.sv }
          "2": { name: punctuation.section.group.begin.sv }
        endCaptures:
          "1": { name: punctuation.section.group.end.sv }
        patterns:
          - include: "#mintypmax-expression"
      - match: (\#)\s*
        captures:
          "1": { name: punctuation.definition.delay.sv }
      - include: "#delay-value"
  event-control:
    patterns:
      - name: meta.event-control.sv
        match: (\@)\s*(\*)\s*
        captures:
          "1": { name: punctuation.definition.event.sv }
          "2": { name: keyword.operator.wildcard.sv }
      - name: meta.event-control.sv
        match: (\@)\s*(\()\s*(\*)\s*(\))\s*
        captures:
          "1": { name: punctuation.definition.event.sv }
          "2": { name: punctuation.section.group.begin.sv }
          "3": { name: keyword.operator.wildcard.sv }
          "4": { name: punctuation.section.group.end.sv }
      - name: meta.event-control.sv
        begin: (\@)\s*(\()\s*
        end: (\))\s*
        beginCaptures:
          "1": { name: punctuation.definition.event.sv }
          "2": { name: punctuation.section.group.begin.sv }
        endCaptures:
          "1": { name: punctuation.section.group.end.sv }
        patterns:
          - include: "#event-expression"
      - match: (\@)\s*(${identifier})\s*
        captures:
          "1": { name: punctuation.definition.event.sv }
          "2": { name: variable.other.sv }
      - match: (\@)\s*
        captures:
          "1": { name: punctuation.definition.event.sv }
      - include: "#hierarchical-event-identifier"
      - include: "#ps-or-hierarchical-sequence-identifier"
  event-expression:
    patterns:
      - include: "#edge-identifier"
      - include: "#expression"
      - match: \b(iff)\b\s*
        captures:
          "1": { name: keyword.control.iff.sv }
      - include: "#sequence-instance"
      - match: \b(or)\b\s*
        captures:
          "1": { name: keyword.other.logical.sv }
      - include: "#comma"
      - begin: \(\s*
        end: \)\s*
        beginCaptures:
          "0": { name: punctuation.section.group.begin.sv }
        endCaptures:
          "0": { name: punctuation.section.group.end.sv }
        patterns:
          - include: "#event-expression"
  procedural-timing-control:
    patterns:
      - include: "#delay-control"
      - include: "#event-control"
      - include: "#cycle-delay"
  jump-statement:
    patterns:
      - match: \b(return)\b\s*
        captures:
          "1": { name: keyword.control.$1.sv }
      - include: "#expression"
      - match: \b(break|continue)\b\s*
        captures:
          "1": { name: keyword.control.$1.sv }
      - include: "#semicolon"
  wait-statement:
    patterns:
      - begin: \b(wait)\s*(\()\s*
        end: (\))\s*
        beginCaptures:
          "1": { name: keyword.control.$1.sv }
          "2": { name: punctuation.section.group.begin.sv }
        endCaptures:
          "1": { name: punctuation.section.group.end.sv }
        patterns:
          - include: "#expression"
      - match: \b(wait)\b\s*\b(fork)\b\s*
        captures:
          "1": { name: keyword.control.$1.sv }
          "2": { name: keyword.control.$2.sv }
      - begin: \b(wait_order)\s*(\()\s*
        end: (\))\s*
        beginCaptures:
          "1": { name: keyword.control.$1.sv }
          "2": { name: punctuation.section.group.begin.sv }
        endCaptures:
          "1": { name: punctuation.section.group.end.sv }
        patterns:
          - include: "#hierarchical-identifier"
          - include: "#comma"
      - include: "#action-block"
  event-trigger:
    patterns:
      - begin: (\-\>)\s*
        end: (\;)\s*
        beginCaptures:
          "1": { name: punctuation.definition.event-trigger.sv }
        endCaptures:
          "1": { name: punctuation.terminator.semicolon.sv }
        patterns:
          - include: "#hierarchical-event-identifier"
      - begin: (\-\>\>)\s*
        end: (\;)\s*
        beginCaptures:
          "1": { name: punctuation.definition.event-trigger.sv }
        endCaptures:
          "1": { name: punctuation.terminator.semicolon.sv }
        patterns:
          - include: "#delay-or-event-control"
          - include: "#hierarchical-event-identifier"
  disable-statement:
    patterns:
      - begin: \b(disable)\s*
        end: (\;)\s*
        beginCaptures:
          "1": { name: keyword.control.$1.sv }
        endCaptures:
          "1": { name: punctuation.terminator.semicolon.sv }
        patterns:
          - match: \b(fork)\b\s*
            captures:
              "1": { name: keyword.control.$1.sv }
          - include: "#hierarchical-task-identifier"
          - include: "#hierarchical-block-identifier"
  # A.6.6 Conditional statements
  conditional-statement:
    patterns:
      - include: "#unique-priority"
      - name: meta.conditional-statement.sv
        begin: \b(if)\b\s*(\()\s*
        beginCaptures:
          "1": { name: keyword.control.$1.sv }
          "2": { name: punctuation.section.group.begin.sv }
        end: (\))\s*
        endCaptures:
          "1": { name: punctuation.section.group.end.sv }
        patterns:
          - include: "#cond-predicate"
          - include: "#expression"
      - match: \b(else)\b\s*
        captures:
          "1": { name: keyword.control.$1.sv }
  unique-priority:
    match: (?<!\.)\b(unique|unique0|priority)\b\s*
    captures:
      "1": { name: keyword.control.$1.sv }
  cond-predicate:
    patterns:
      - match: (\&\&\&)\s*
        captures:
          "1": { name: keyword.operator.andandand.sv }
      - include: "#expression-or-cond-pattern"
  expression-or-cond-pattern:
    patterns:
      - include: "#cond-pattern"
  cond-pattern:
    name: meta.cond-pattern.sv
    begin: \b(matches)\b\s*
    end: (?=\&\&\&|\)|\?)
    beginCaptures:
      "1": { name: keyword.control.matches.sv }
    patterns:
      - include: "#pattern"
  # A.6.7 Case statements
  case-statement:
    patterns:
      - include: "#unique-priority"
      - name: meta.case-statement.sv
        begin: (?=\b(case|casex|casez)\b)
        end: \b(endcase)\b\s*
        endCaptures:
          "1": { name: keyword.control.$1.sv }
        patterns:
          # Header
          - begin: (case|casex|casez)\s*(\()\s*
            end: (?=\))
            beginCaptures:
              "1": { name: keyword.control.$1.sv }
              "2": { name: punctuation.section.group.begin.sv }
            patterns:
              - include: "#case-expression"
          # Body
          - begin: (\))\s*
            beginCaptures:
              "1": { name: punctuation.section.group.end.sv }
            end: (?=\b(endcase)\b)
            patterns:
              - match: \b(matches)\b\s*
                captures:
                  "1": { name: keyword.control.matches.sv }
              - match: \b(inside)\b\s*
                captures:
                  "1": { name: keyword.control.$1.sv }
              - include: "#case-pattern-item"
              - include: "#case-item"
              - include: "#case-inside-item"
  case-keyword:
    match: \b(case|casex|casez)\b\s*
    captures:
      "1": { name: keyword.control.$1.sv }
  case-expression:
    patterns:
      - include: "#expression"
  case-item:
    patterns:
      - include: "#colon"
      - include: "#comma"
      - match: \b(default)\b\s*
        captures:
          "1": { name: keyword.control.$1.sv }
      - include: "#case-item-expression"
      - include: "#statement-or-null"
  case-pattern-item:
    patterns:
      - match: (\&\&\&)\s*
        captures:
          "1": { name: keyword.operator.andandand.sv }
      - include: "#colon"
      - match: \b(default)\b\s*
        captures:
          "1": { name: keyword.control.$1.sv }
      - include: "#pattern"
      - include: "#expression"
      - include: "#statement-or-null"
  case-inside-item:
    patterns:
      - include: "#colon"
      - match: \b(default)\b\s*
        captures:
          "1": { name: keyword.control.$1.sv }
      - include: "#open-range-list"
      - include: "#statement-or-null"
  case-item-expression:
    patterns:
      - include: "#expression"
  randcase-statement:
    begin: \b(randcase)\b\s*
    end: \b(endcase)\b\s*
    beginCaptures:
      "1": { name: keyword.control.$1.sv }
    endCaptures:
      "1": { name: keyword.control.$1.sv }
    patterns:
      - include: "#randcase-item"
  randcase-item:
    patterns:
      - include: "#colon"
      - include: "#expression"
      - include: "#statement-or-null"
  open-range-list:
    patterns:
      - include: "#comma"
      - include: "#open-value-range"
  open-value-range:
    patterns:
      - include: "#value-range"
  # A.6.7.1 Patterns
  pattern:
    patterns:
      - match: (\.)\s*(${identifier})\s*
        captures:
          "1": { name: punctuation.definition.pattern.sv }
          "2": { name: variable.other.sv }
      - match: (\.\*)
        captures:
          "1": { name: punctuation.definition.wildcard.sv }
      - include: "#constant-expression"
      - match: \b(tagged)\s+(${identifier})\s*
        captures:
          "1": { name: keyword.other.tagged.sv }
          "2": { name: variable.other.enummember.sv }
      - include: "#assignment-pattern"
  assignment-pattern:
    name: meta.pattern.sv
    begin: (\'\{)\s*
    end: (\})\s*
    beginCaptures:
      "1": { name: punctuation.section.braces.begin.sv }
    endCaptures:
      "1": { name: punctuation.section.braces.end.sv }
    patterns:
      - include: "#pattern"
      # Replication case
      - name: meta.assignment-pattern-replication.sv
        begin: (?<=[^{,'\s])\s*\{
        end: \}
        beginCaptures:
          "0": { name: punctuation.section.braces.begin.sv }
        endCaptures:
          "0": { name: punctuation.section.braces.end.sv }
        patterns:
          - include: "#comma"
          - include: "#expression"
          - include: "#comment"
          - include: "#compiler-directive"
      - name: meta.assignment-pattern-key-value.sv
        begin: (\:)\s*
        end: (?=\}|,)
        beginCaptures:
          "1": { name: punctuation.separator.colon.sv }
        patterns:
          - include: "#expression"
          - include: "#comment"
          - include: "#compiler-directive"
      # Special case for member identifier
      - match: (${identifier})\s*(?=\:)
        captures:
          "1": { name: variable.other.member.sv }
      - include: "#comma"
      - include: "#expression"
      - include: "#structure-pattern-key"
      - include: "#array-pattern-key"
      - include: "#comment"
      - include: "#compiler-directive"
  structure-pattern-key:
    patterns:
      - include: "#member-identifier"
      - include: "#assignment-pattern-key"
  array-pattern-key:
    patterns:
      - include: "#constant-expression"
      - include: "#assignment-pattern-key"
  assignment-pattern-key:
    patterns:
      - match: \b(default)\b
        name: keyword.other.default.sv
      - include: "#simple-type"
  assignment-pattern-expression:
    patterns:
      - include: "#assignment-pattern-expression-type"
      - include: "#assignment-pattern"
  assignment-pattern-expression-type:
    patterns:
      - include: "#ps-type-identifier"
      - include: "#ps-parameter-identifier"
      - include: "#integer-atom-type"
      - include: "#type-reference"
  constant-assignment-pattern-expression:
    patterns:
      - include: "#assignment-pattern-expression"
  assignment-pattern-net-lvalue:
    patterns:
      - name: meta.assignment-pattern-net-lvalue.sv
        begin: \'\{
        end: \}
        beginCaptures:
          "0": { name: punctuation.section.braces.begin.sv }
        endCaptures:
          "0": { name: punctuation.section.braces.end.sv }
        patterns:
          - include: "#net-lvalue"
          - include: "#comma"
  assignment-pattern-variable-lvalue:
    patterns:
      - name: meta.assignment-pattern-variable-lvalue.sv
        begin: \'\{
        end: \}
        beginCaptures:
          "0": { name: punctuation.section.braces.begin.sv }
        endCaptures:
          "0": { name: punctuation.section.braces.end.sv }
        patterns:
          - include: "#variable-lvalue"
          - include: "#comma"
  # A.6.8 Looping statements
  loop-statement:
    patterns:
      - match: \b(forever)\b\s*
        captures:
          "1": { name: keyword.control.$1.sv }
      - name: meta.loop-statement.sv
        begin: \b(repeat)\s*(\()\s*
        end: (\))\s*
        beginCaptures:
          "1": { name: keyword.control.$1.sv }
          "2": { name: punctuation.section.group.begin.sv }
        endCaptures:
          "1": { name: punctuation.section.group.end.sv }
        patterns:
          - include: "#expression"
      - name: meta.loop-statement.sv
        begin: \b(while)\s*(\()\s*
        end: (\))\s*
        beginCaptures:
          "1": { name: keyword.control.$1.sv }
          "2": { name: punctuation.section.group.begin.sv }
        endCaptures:
          "1": { name: punctuation.section.group.end.sv }
        patterns:
          - include: "#expression"
      - name: meta.loop-statement.sv
        begin: \b(for)\s*(\()\s*
        end: (\))\s*
        beginCaptures:
          "1": { name: keyword.control.$1.sv }
          "2": { name: punctuation.section.group.begin.sv }
        endCaptures:
          "1": { name: punctuation.section.group.end.sv }
        patterns:
          - include: "#for-initialization"
          - include: "#expression"
          - include: "#for-step"
          - include: "#semicolon"
      - match: \b(do)\b\s*
        captures:
          "1": { name: keyword.control.$1.sv }
      - name: meta.loop-statement.sv
        begin: \b(foreach)\s*(\()\s*
        end: (\))\s*
        beginCaptures:
          "1": { name: keyword.control.$1.sv }
          "2": { name: punctuation.section.group.begin.sv }
        endCaptures:
          "1": { name: punctuation.section.group.end.sv }
        patterns:
          - include: "#ps-or-hierarchical-array-identifier"
          - include: "#dimension"
  for-initialization:
    patterns:
      - include: "#list-of-variable-assignments"
      - include: "#for-variable-declaration"
  for-variable-declaration:
    patterns:
      - match: \b(var)\b\s*
        captures:
          "1": { name: storage.modifier.var.sv }
      - include: "#equals"
      - include: "#expression"
      - include: "#variable-identifier"
      - include: "#data-type"
      - include: "#comma"
  for-step:
    patterns:
      - include: "#for-step-assignment"
      - include: "#comma"
  for-step-assignment:
    patterns:
      - include: "#operator-assignment"
      - include: "#inc-or-dec-expression"
      - include: "#function-subroutine-call"
  loop-variables:
    patterns:
      - include: "#index-variable-identifier"
      - include: "#comma"
  # A.6.9 Subroutine call statements
  subroutine-call-statement:
    patterns:
      - include: "#subroutine-call"
  # A.6.11 Clocking block
  clocking-declaration:
    begin: (?:\b(default|global)\b\s+)?\b(clocking)\b\s*(?:(\b${identifier}\b)\s*)?
    end: \b(endclocking)\b\s*(?:(\:)\s*(${identifier})\s*)?
    beginCaptures:
      "1": { name: storage.modifier.$1.sv }
      "2": { name: storage.type.clocking.sv }
      "3": { name: entity.name.type.sv }
    endCaptures:
      "1": { name: storage.type.clocking.sv }
      "2": { name: punctuation.separator.colon.sv }
      "3": { name: entity.name.type.sv }
    patterns:
      - include: "#clocking-event"
      - include: "#clocking-item"
  clocking-event:
    patterns:
      - name: meta.clocking-event.sv
        match: (\@)\s*(${identifier})\s*
        captures:
          "1": { name: punctuation.definition.event.sv }
          "2": { name: variable.other.sv }
      - name: meta.clocking-event.sv
        begin: (\@)\s*(\()\s*
        end: (\))\s*
        beginCaptures:
          "1": { name: punctuation.definition.event.sv }
          "2": { name: punctuation.section.group.begin.sv }
        endCaptures:
          "1": { name: punctuation.section.group.end.sv }
        patterns:
          - include: "#event-expression"
  clocking-item:
    patterns:
      - begin: \b(default)\b\s*
        end: (\;)\s*
        beginCaptures:
          "1": { name: storage.modifier.default.sv }
        endCaptures:
          "1": { name: punctuation.terminator.semicolon.sv }
        patterns:
          - include: "#default-skew"
      - include: "#clocking-direction"
      - include: "#list-of-clocking-decl-assign"
      - include: "#attribute-instance"
      - include: "#assertion-item-declaration"
      - include: "#semicolon"
  default-skew:
    patterns:
      - match: \b(input|output)\b\s*
        captures:
          "1": { name: storage.modifier.$1.sv }
      - include: "#clocking-skew"
  clocking-direction:
    patterns:
      - match: \b(inout)\b\s*
        captures:
          "1": { name: storage.modifier.$1.sv }
      - match: \b(input|output)\b\s*
        captures:
          "1": { name: storage.modifier.$1.sv }
      - include: "#clocking-skew"
  list-of-clocking-decl-assign:
    patterns:
      - include: "#clocking-decl-assign"
      - include: "#comma"
  clocking-decl-assign:
    patterns:
      - include: "#signal-identifier"
      - begin: (\=)\s*
        end: (?=\,|\;)
        beginCaptures:
          "1": { name: keyword.operator.assignment.sv }
        patterns:
          - include: "#expression"
  clocking-skew:
    patterns:
      - include: "#edge-identifier"
      - include: "#delay-control"
  clocking-drive:
    patterns:
      - include: "#clockvar-expression"
      - begin: (\<\=)\s*
        end: (?=\;)
        beginCaptures:
          "1": { name: keyword.operator.assignment.sv }
        patterns:
          - include: "#cycle-delay"
          - include: "#expression"
  cycle-delay:
    patterns:
      - match: (\#\#)\s*
        captures:
          "1": { name: keyword.operator.cycle-delay.sv }
      - include: "#integral-number"
      - include: "#identifier"
      - begin: (\#\#)\s*(\()\s*
        end: (\))\s*
        beginCaptures:
          "1": { name: keyword.operator.cycle-delay.sv }
          "2": { name: punctuation.section.group.begin.sv }
        endCaptures:
          "1": { name: punctuation.section.group.end.sv }
        patterns:
          - include: "#expression"
  clockvar:
    patterns:
      - include: "#hierarchical-identifier"
  clockvar-expression:
    patterns:
      - include: "#clockvar"
      - include: "#select"
  # A.7.4 Specify path delays
  edge-identifier:
    match: \b(posedge|negedge|edge)\b\s*
    captures:
      "1": { name: keyword.other.$1.sv }
  # A.8 Expressions
  # A.8.1 Concatenations
  concatenation:
    name: meta.concatenation.sv
    begin: (\{)\s*
    end: (\})\s*
    beginCaptures:
      "1": { name: punctuation.section.braces.begin.sv }
    endCaptures:
      "1": { name: punctuation.section.braces.end.sv }
    patterns:
      - include: "#stream-operator"
      - include: "#expression"
      - include: "#constant-expression"
      - include: "#slice-size"
      - include: "#stream-concatenation"
      - include: "#comma"
  constant-concatenation:
    patterns:
      - include: "#concatenation"
  constant-multiple-concatenation:
    patterns:
      - include: "#constant-concatenation"
  module-path-concatenation:
    begin: (\{)\s*
    end: (\})\s*
    beginCaptures:
      "1": { name: punctuation.section.braces.begin.sv }
    endCaptures:
      "1": { name: punctuation.section.braces.end.sv }
    patterns:
      - include: "#module-path-expression"
      - include: "#comma"
  module-path-multiple-concatenation:
    patterns:
      - include: "#constant-expression"
      - include: "#module-path-concatenation"
  multiple-concatenation:
    patterns:
      - include: "#concatenation"
  streaming-concatenation:
    patterns:
      - include: "#concatenation"
  stream-operator:
    match: (>>|<<)\s*
    captures:
      "1": { name: keyword.operator.stream.sv }
  slice-size:
    patterns:
      - include: "#simple-type"
      - include: "#constant-expression"
  stream-concatenation:
    patterns:
      - include: "#stream-expression"
      - include: "#comma"
  stream-expression:
    patterns:
      - include: "#array-range-expression"
      - include: "#expression"
      - match: \b(with)\s*
        captures:
          "1": { name: keyword.control.with.sv }
  array-range-expression:
    patterns:
      - include: "#expression"
      - match: (\:)\s*
        captures:
          "1": { name: punctuation.separator.colon.sv }
      - match: (\+\:)\s*
        captures:
          "1": { name: punctuation.separator.pluscolon.sv }
      - match: (\-\:)\s*
        captures:
          "1": { name: punctuation.separator.minuscolon.sv }
  empty-unpacked-array-concatenation:
    patterns:
      - include: "#concatenation"
  # A.8.2 Subroutine calls
  constant-function-call:
    patterns:
      - include: "#function-subroutine-call"
  tf-call:
    name: meta.tf-call.sv
    begin: (?<!(?:${simpleIdentifier}|\))\s+)(${functionIdentifier}|\bnew\b)\s*(\()\s*
    end: (\))\s*
    beginCaptures:
      "1": { name: entity.name.function.sv }
      "2": { name: punctuation.section.group.begin.sv }
    endCaptures:
      "1": { name: punctuation.section.group.end.sv }
    patterns:
      - include: "#let-list-of-arguments"
      - include: "#list-of-arguments"
      - include: "#comment"
      - include: "#compiler-directive"
  system-tf-call:
    patterns:
      - name: meta.system-tf-call.sv
        begin: (\$[a-zA-Z0-9_\$]+)\b(\()\s*
        beginCaptures:
          "1": { name: entity.name.function.sv }
          "2": { name: punctuation.section.group.begin.sv }
        end: (\))
        endCaptures:
          "1": { name: punctuation.section.group.end.sv }
        patterns:
          - include: "#list-of-arguments"
      - match: (\$[a-zA-Z0-9_\$]+)\b
        captures:
          "1": { name: entity.name.function.sv }
  subroutine-call:
    patterns:
      - include: "#system-tf-call"
      - include: "#tf-call"
      - include: "#method-call"
      - match: \b(std)\b\s*(\:\:)\s*
        captures:
          "1": { name: entity.name.function.sv }
          "2": { name: punctuation.separator.scope-resolution.sv }
      - include: "#randomize-call"
  function-subroutine-call:
    patterns:
      - include: "#subroutine-call"
  list-of-arguments:
    patterns:
      - begin: (?<!\w)(\.)\s*(${identifier})\s*(\()\s*
        end: (\))\s*
        beginCaptures:
          "1": { name: punctuation.definition.named-parameter-assignment.sv }
          "2": { name: variable.other.member.sv }
          "3": { name: punctuation.section.group.begin.sv }
        endCaptures:
          "1": { name: punctuation.section.group.end.sv }
        patterns:
          - include: "#expression"
      - include: "#comma"
      - include: "#expression"
  method-call:
    patterns:
      - include: "#method-call-root"
      - include: "#period"
      - include: "#method-call-body"
  method-call-body:
    patterns:
      - include: "#built-in-method-call"
  built-in-method-call:
    patterns:
      - include: "#array-manipulation-call"
      - include: "#randomize-call"
  array-manipulation-call:
    patterns:
      - begin: (${functionIdentifier}|\b(?:unique|and|or|xor))\b\s*(\()\s*
        end: (\))\s*
        beginCaptures:
          "1": { name: entity.name.function.sv }
          "2": { name: punctuation.section.group.begin.sv }
        endCaptures:
          "1": { name: punctuation.section.group.end.sv }
        patterns:
          - include: "#list-of-arguments"
      # - match: (${functionIdentifier}|\b(?:unique|and|or|xor))\b\s*(?=\bwith\b)
      #   captures:
      #     "1": { name: entity.name.function.sv }
      - begin: \b(with)\s*(\()\s*
        end: (\))\s*
        beginCaptures:
          "1": { name: keyword.control.with.sv }
          "2": { name: punctuation.section.group.begin.sv }
        endCaptures:
          "1": { name: punctuation.section.group.end.sv }
        patterns:
          - include: "#expression"
  randomize-call:
    patterns:
      - begin: \b(randomize)\s*(\()\s*
        end: (\))\s*
        beginCaptures:
          "1": { name: entity.name.function.sv }
          "2": { name: punctuation.section.group.begin.sv }
        endCaptures:
          "1": { name: punctuation.section.group.end.sv }
        patterns:
          - include: "#variable-identifier-list"
          - match: \b(null)\b\s*
            captures:
              "1": { name: constant.language.null.sv }
      - begin: \b(with)\s*(\()\s*
        end: (\))\s*
        beginCaptures:
          "1": { name: keyword.control.with.sv }
          "2": { name: punctuation.section.group.begin.sv }
        endCaptures:
          "1": { name: punctuation.section.group.end.sv }
        patterns:
          - include: "#identifier-list"
      - include: "#constraint-block"
  method-call-root:
    patterns:
      - include: "#implicit-class-handle"
  array-method-name:
    match: \b(unique|and|or|xor|${functionIdentifier})\b\s*
    captures:
      "1": { name: entity.name.function.sv }
  # A.8.3 Expressions
  inc-or-dec-expression:
    patterns:
      - include: "#attribute-instance"
      - include: "#inc-or-dec-operator"
      - include: "#variable-lvalue"
  conditional-expression:
    patterns:
      - include: "#cond-predicate"
      - match: (\?)\s*
        captures:
          "1": { name: keyword.operator.ternary.sv }
      - include: "#attribute-instance"
      - match: (\:)\s*
        captures:
          "1": { name: punctuation.separator.colon.sv }
      - include: "#attribute-instance"
  constant-expression:
    patterns:
      - match: (\?)\s*
        captures:
          "1": { name: keyword.operator.ternary.sv }
      - match: (\:)\s*
        captures:
          "1": { name: punctuation.separator.colon.sv }
      - include: "#attribute-instance"
      - include: "#constant-primary"
      - include: "#binary-operator"
      - include: "#unary-operator"
      - include: "#attribute-instance"
  constant-mintypmax-expression:
    patterns:
      - match: (\:)\s*
        captures:
          "1": { name: punctuation.separator.colon.sv }
      - include: "#constant-expression"
  constant-param-expression:
    patterns:
      - match: (\$)\s*(?!\w)
        captures:
          "1": { name: variable.language.dollar.sv }
      - include: "#constant-mintypmax-expression"
      - include: "#data-type"
  param-expression:
    patterns:
      - match: (\$)\s*(?!\w)
        captures:
          "1": { name: variable.language.dollar.sv }
      - include: "#mintypmax-expression"
      - include: "#data-type"
  constant-range-expression:
    patterns:
      - include: "#constant-part-select-range"
      - include: "#constant-expression"
  constant-part-select-range:
    patterns:
      - include: "#constant-indexed-range"
      - include: "#constant-range"
  constant-range:
    patterns:
      - match: (\:)\s*
        captures:
          "1": { name: punctuation.separator.colon.sv }
      - include: "#constant-expression"
  constant-indexed-range:
    patterns:
      - match: (\+\:)\s*
        captures:
          "1": { name: punctuation.separator.pluscolon.sv }
      - match: (\-\:)\s*
        captures:
          "1": { name: punctuation.separator.minuscolon.sv }
      - include: "#constant-expression"
  expression:
    patterns:
      # This section of code handles the expression in different types of declarations,
      # such as data declaration and net declaration. By moving this code here, it
      # improves the organization of the syntax file.
      - name: meta.parenthesis.sv
        begin: (\()\s*(?!\s*\*)
        end: (\))\s*
        beginCaptures:
          "1": { name: punctuation.section.group.begin.sv }
        endCaptures:
          "1": { name: punctuation.section.group.end.sv }
        patterns:
          - include: "#operator-assignment"
          - include: "#expression"
      - include: "#inc-or-dec-expression"
      - include: "#binary-operator"
      - include: "#unary-operator"
      - include: "#attribute-instance"
      - include: "#primary"
      - include: "#conditional-expression"
      - include: "#inside-expression"
      - include: "#tagged-union-expression"
  tagged-union-expression:
    match: \b(tagged)\s+(${identifier})\s*
    captures:
      "1": { name: keyword.other.tagged.sv }
      "2": { name: variable.other.enummember.sv }
  inside-expression:
    patterns:
      - match: \b(inside)\b\s*
        captures:
          "1": { name: keyword.control.inside.sv }
      - include: "#open-range-list"
  value-range:
    patterns:
      # - include: "#expression"
      - include: "#dimension"
  mintypmax-expression:
    patterns:
      - include: "#expression"
      - include: "#colon"
  module-path-conditional-expression:
    patterns:
      - match: (\?)\s*
        captures:
          "1": { name: keyword.operator.ternary.sv }
      - include: "#attribute-instance"
      - match: (\:)\s*
        captures:
          "1": { name: punctuation.separator.colon.sv }
      - include: "#module-path-expression"
  module-path-expression:
    patterns:
      - include: "#module-path-primary"
      - include: "#unary-module-path-operator"
      - include: "#binary-module-path-operator"
      - include: "#module-path-conditional-expression"
      - include: "#attribute-instance"
  module-path-mintypmax-expression:
    patterns:
      - include: "#module-path-expression"
      - include: "#colon"
  part-select-range:
    patterns:
      - include: "#constant-indexed-range"
      - include: "#constant-range"
  indexed-range:
    patterns:
      - match: (\+\:)\s*
        captures:
          "1": { name: punctuation.separator.pluscolon.sv }
      - match: (\-\:)\s*
        captures:
          "1": { name: punctuation.separator.minuscolon.sv }
      - include: "#constant-expression"
  genvar-expression:
    patterns:
      - include: "#constant-expression"
  # A.8.4 Primaries
  constant-primary:
    patterns:
      # Two special identifier for type casting:
      # 1. If the identifier starts with an uppercase letter, we guess it is a parameter name
      # 2. Otherwise, we guess it is a type name
      - match: (\b[A-Z][a-zA-Z0-9_\$]*)\s*(?=\')
        captures:
          "1": { name: variable.other.constant.sv }
      - match: (${simpleIdentifier})\s*(?=\')
        captures:
          "1": { name: entity.name.type.sv }
      - include: "#primary-literal"
      - include: "#ps-parameter-identifier"
      - include: "#constant-select"
      - include: "#specparam-identifier"
      - include: "#dimension"
      - include: "#genvar-identifier"
      - include: "#formal-port-identifier"
      - include: "#package-scope"
      - include: "#class-scope"
      - include: "#enum-identifier"
      - include: "#constant-concatenation"
      - include: "#constant-multiple-concatenation"
      - include: "#constant-function-call"
      - include: "#constant-let-expression"
      - begin: \(\s*
        end: \)\s*
        beginCaptures:
          "0": { name: punctuation.section.group.begin.sv }
        endCaptures:
          "0": { name: punctuation.section.group.end.sv }
        patterns:
          - include: "#constant-mintypmax-expression"
      - include: "#constant-cast"
      - include: "#constant-assignment-pattern-expression"
      - include: "#type-reference"
      - match: \b(null)\b\s*
        captures:
          "1": { name: constant.language.null.sv }
  module-path-primary:
    patterns:
      - include: "#number"
      - include: "#identifier"
      - include: "#module-path-concatenation"
      - include: "#module-path-multiple-concatenation"
      - include: "#function-subroutine-call"
      - begin: \(\s*
        end: \)\s*
        beginCaptures:
          "0": { name: punctuation.section.group.begin.sv }
        endCaptures:
          "0": { name: punctuation.section.group.end.sv }
        patterns:
          - include: "#module-path-mintypmax-expression"
  primary:
    patterns:
      # Two special identifier for type casting:
      # 1. If the identifier starts with an uppercase letter, we guess it is a parameter name
      # 2. Otherwise, we guess it is a type name
      - match: (\b[A-Z][a-zA-Z0-9_\$]*)\s*(?=\')
        captures:
          "1": { name: variable.other.constant.sv }
      - match: (${simpleIdentifier})\s*(?=\')
        captures:
          "1": { name: entity.name.type.sv }
      - include: "#primary-literal"
      - include: "#class-qualifier"
      - include: "#package-scope"
      - include: "#hierarchical-identifier"
      - include: "#select"
      - include: "#empty-unpacked-array-concatenation"
      - include: "#concatenation"
      - begin: (\[)\s*
        end: (\])\s*
        beginCaptures:
          "1": { name: punctuation.section.brackets.begin.sv }
        endCaptures:
          "1": { name: punctuation.section.brackets.end.sv }
        patterns:
          - include: "#range-expression"
      - include: "#function-subroutine-call"
      - include: "#let-expression"
      - begin: \(\s*
        end: \)\s*
        beginCaptures:
          "0": { name: punctuation.section.group.begin.sv }
        endCaptures:
          "0": { name: punctuation.section.group.end.sv }
        patterns:
          - include: "#mintypmax-expression"
      - include: "#cast"
      - include: "#assignment-pattern-expression"
      - include: "#streaming-concatenation"
      - include: "#sequence-method-call"
      - match: \b(this)\b\s*
        captures:
          "1": { name: variable.language.this.sv }
      - match: (\$)\s*(?!\w)
        captures:
          "1": { name: variable.language.dollar.sv }
      - match: \b(null)\b\s*
        captures:
          "1": { name: constant.language.null.sv }
  class-qualifier:
    patterns:
      - match: \b(local)\b\s*
        captures:
          "1": { name: entity.name.namespace.sv }
      - match: (\:\:)\s*
        captures:
          "1": { name: punctuation.separator.double-colon.sv }
      - include: "#period"
      - include: "#implicit-class-handle"
      - include: "#class-scope"
  range-expression:
    patterns:
      - include: "#part-select-range"
      - include: "#expression"
  primary-literal:
    patterns:
      - include: "#string-literal"
      - include: "#time-literal"
      - include: "#unbased-unsized-literal"
      - include: "#number"
  time-literal:
    patterns:
      - match: \b([0-9][0-9_]*)\s*(s|ms|us|ns|ps|fs)\b
        captures:
          "1": { name: constant.numeric.integer.sv }
          "2": { name: constant.numeric.time-unit.sv }
      - match: \b([0-9_]+\.[0-9_]+)\s*(s|ms|us|ns|ps|fs)\b
        captures:
          "1": { name: constant.numeric.real.sv }
          "2": { name: constant.numeric.time-unit.sv }
      - include: "#number"
  time-unit:
    name: constant.numeric.time-unit.sv
    match: (?<=[0-9][0-9_]*\s*)(s|ms|us|ns|ps|fs)\b
  implicit-class-handle:
    match: \b(this|super)\b\s*
    captures:
      "1": { name: variable.language.$1.sv }
  bit-select:
    patterns:
      - include: "#dimension"
  select:
    patterns:
      - include: "#bit-select"
      - include: "#dimension"
      - include: "#period"
      - include: "#member-identifier"
  nonrange-select:
    patterns:
      - include: "#bit-select"
      - include: "#period"
      - include: "#member-identifier"
  constant-bit-select:
    patterns:
      - include: "#dimension"
  constant-select:
    patterns:
      - include: "#constant-bit-select"
      - include: "#dimension"
      - include: "#period"
      - include: "#member-identifier"
  constant-cast:
    patterns:
      - include: "#casting-type"
      - begin: (\')\s*(\()\s*
        end: (\))\s*
        beginCaptures:
          "1": { name: punctuation.definition.casting.sv }
          "2": { name: punctuation.section.group.begin.sv }
        endCaptures:
          "1": { name: punctuation.section.group.end.sv }
        patterns:
          - include: "#constant-expression"
  constant-let-expression:
    patterns:
      - include: "#let-expression"
  cast:
    patterns:
      - include: "#casting-type"
      - begin: (\')\s*(\()\s*
        end: (\))\s*
        beginCaptures:
          "1": { name: punctuation.definition.casting.sv }
          "2": { name: punctuation.section.group.begin.sv }
        endCaptures:
          "1": { name: punctuation.section.group.end.sv }
        patterns:
          - include: "#expression"
  # A.8.6 Operators
  unary-operator:
    match: (~\^|\^~|~&|~\||\+|\-|!|~|&|\||\^)\s*(?!\+)
    captures:
      "1": { name: keyword.operator.unary.sv }
  binary-operator:
    match: (?<!^|(?:\(|\:|=)\s*)(===|!==|==\?|==|!=\?|!=|&&|\|\||\*\*|<=|>=|\^~|~\^|\^~|>>>|<<<|>>|<<|->|<->|\+|\-|\*|\/|%|<|>|&|\||\^)\s*(?!\+)
    captures:
      "1": { name: keyword.operator.binary.sv }
  inc-or-dec-operator:
    match: (\+\+|--)\s*
    captures:
      "1": { name: keyword.operator.incdec.sv }
  unary-module-path-operator:
    match: (~&|~\||~\^|\^~|!|~|&|\||\^)\s*
    captures:
      "1": { name: keyword.operator.unary.sv }
  binary-module-path-operator:
    match: (==|!=|&&|\|\||\^~|~\^|&|\||\^)\s*
    captures:
      "1": { name: keyword.operator.binary.sv }
  # A.8.7 Numbers
  number:
    name: meta.number.sv
    patterns:
      - include: "#integral-number"
      - include: "#real-number"
      - include: "#comment"
      - include: "#compiler-directive"
  integral-number:
    name: meta.integral-number.sv
    patterns:
      - include: "#octal-number"
      - include: "#binary-number"
      - include: "#hex-number"
      - include: "#decimal-number"
      - include: "#comment"
      - include: "#compiler-directive"
  decimal-number:
    patterns:
      - match: (\b[1-9][0-9_]*)?\s*(\')[sS]?[dD]\s*([0-9_xXzZ\?]+)
        name: constant.numeric.decimal.sv
      - match: (?<!\.)\b([0-9_]+)\b(?!\.)
        name: constant.numeric.integer.sv
  binary-number:
    match: (\b[1-9][0-9_]*)?\s*(\')[sS]?[bB]\s*([0-1_xXzZ\?]+)
    name: constant.numeric.binary.sv
  octal-number:
    match: (\b[1-9][0-9_]*)?\s*(\')[sS]?[oO]\s*([0-7_xXzZ\?]+)
    name: constant.numeric.octal.sv
  hex-number:
    match: (\b[1-9][0-9_]*)?\s*(\')[sS]?[hH]\s*([0-9a-fA-F_xXzZ\?]+)
    name: constant.numeric.hex.sv
  real-number:
    name: meta.real-number.sv
    patterns:
      - include: "#fixed-point-number"
      - match: (?<!\.)\b[0-9_]+(\.[0-9_]+)?[eE][+-]?[0-9_]+
        name: constant.numeric.real.sv
  fixed-point-number:
    match: \b[0-9_]+\.[0-9_]+\b
    name: constant.numeric.real.sv
  unbased-unsized-literal:
    match: (\'[01xXzZ])\b
    name: constant.numeric.unbased-unsized.sv
  # A.9 General
  # A.9.1 Attributes
  attribute-instance:
    name: meta.attribute-instance.sv
    begin: \(\*
    end: \*\)
    beginCaptures:
      "0": { name: punctuation.definition.attribute.begin.sv }
    endCaptures:
      "0": { name: punctuation.definition.attribute.end.sv }
    patterns:
      - include: "#att-spec"
      - include: "#comma"
      - include: "#comment"
      - include: "#compiler-directive"
  att-spec:
    name: meta.att-spec.sv
    begin: \b([a-zA-Z_][a-zA-Z0-9_]*)\s*(\=)?
    end: (?=(\*\))|\,)\s*
    beginCaptures:
      "1": { name: entity.other.attribute-name.sv }
      "2": { name: keyword.operator.assignment.sv }
    patterns:
      - include: "#constant-expression"
      - include: "#comment"
      - include: "#compiler-directive"
  # A.8.8 Strings
  string-literal:
    name: string.quoted.double.sv
    begin: \"
    end: \"
    beginCaptures:
      "0": { name: punctuation.definition.string.begin.sv }
    endCaptures:
      "0": { name: punctuation.definition.string.end.sv }
    patterns:
      - match: (?:\\u[0-9a-fA-F]{4}|\\U[0-9a-fA-F]{8})
        name: constant.character.escape.sv
      - match: (?:\\[abfnrtv\\\"\'\?])
        name: constant.character.escape.sv
      - match: (?:\\[0-7]{1,3})
        name: constant.character.escape.sv
      - match: (?:\\x[0-9a-fA-F]{1,2})
        name: constant.character.escape.sv
      - match: \%(\d+\$)?[#0\- +']*[,;:_]?((-?\d+)|\*(-?\d+\$)?)?(\.((-?\d+)|\*(-?\d+\$)?)?)?(hh|h|ll|l|j|t|z|q|L|vh|vl|v|hv|hl)?[hHxXdDoObBcClLvVmMpPsStTuUzZieEfFgGaAn%]
        name: constant.other.placeholder.sv
      - match: \\\n
        name: punctuation.separator.continuation.sv
  # A.9.2 Comments
  comment:
    patterns:
      - include: "#line-comment"
      - include: "#block-comment"
  line-comment:
    name: comment.line.sv
    match: (//)(.*)
    captures:
      "1": { name: punctuation.definition.comment.sv }
  block-comment:
    name: comment.block.sv
    begin: /\*
    end: \*/
    beginCaptures:
      "0": { name: punctuation.definition.comment.sv }
    endCaptures:
      "0": { name: punctuation.definition.comment.sv }
  # A.9.3 Identifiers
  array-identifier:
    patterns:
      - include: "#identifier"
  block-identifier:
    patterns:
      - include: "#identifier"
  bin-identifier:
    patterns:
      - include: "#identifier"
  c-identifier:
    match: \b([a-zA-Z_][a-zA-Z0-9_]*)\b\s*
    captures:
      "1": { name: variable.other.sv }
  cell-identifier:
    patterns:
      - include: "#identifier"
  checker-identifier:
    patterns:
      - include: "#identifier"
  class-identifier:
    match: (${identifier})\s*${classIdentifierEnd}
    captures:
      "1": { name: entity.name.type.sv }
  class-variable-identifier:
    patterns:
      - include: "#variable-identifier"
  clocking-identifier:
    patterns:
      - include: "#identifier"
  config-identifier:
    patterns:
      - include: "#identifier"
  const-identifier:
    patterns:
      - include: "#identifier"
  constraint-identifier:
    patterns:
      - include: "#identifier"
  covergroup-identifier:
    patterns:
      - include: "#identifier"
  covergroup-variable-identifier:
    patterns:
      - include: "#variable-identifier"
  cover-point-identifier:
    patterns:
      - include: "#identifier"
  cross-identifier:
    patterns:
      - include: "#identifier"
  dynamic-array-variable-identifier:
    patterns:
      - include: "#variable-identifier"
  enum-identifier:
    patterns:
      - include: "#identifier"
  escaped-identifier:
    match: \\[^\s]+\s*
    name: variable.other.sv
  formal-identifier:
    patterns:
      - include: "#identifier"
  formal-port-identifier:
    patterns:
      - include: "#identifier"
  function-identifier:
    match: (${functionIdentifier})\s*${functionIdentifierEnd}
    captures:
      "1": { name: entity.name.function.sv }
  generate-block-identifier:
    patterns:
      - include: "#identifier"
  genvar-identifier:
    patterns:
      - include: "#identifier"
  hierarchical-array-identifier:
    patterns:
      - include: "#hierarchical-identifier"
  hierarchical-block-identifier:
    patterns:
      - include: "#hierarchical-identifier"
  hierarchical-event-identifier:
    patterns:
      - include: "#hierarchical-identifier"
  hierarchical-identifier:
    patterns:
      - match: (\$root)\s*(\.)\s*
        captures:
          "1": { name: variable.other.root.sv }
          "2": { name: punctuation.accessor.dot.sv }
      - match: (\.)\s*
        captures:
          "1": { name: punctuation.accessor.dot.sv }
      - include: "#identifier"
  hierarchical-net-identifier:
    patterns:
      - include: "#hierarchical-identifier"
  hierarchical-parameter-identifier:
    patterns:
      - include: "#hierarchical-identifier"
  hierarchical-property-identifier:
    patterns:
      - include: "#hierarchical-identifier"
  hierarchical-sequence-identifier:
    patterns:
      - include: "#hierarchical-identifier"
  hierarchical-task-identifier:
    patterns:
      - include: "#hierarchical-identifier"
  hierarchical-tf-identifier:
    patterns:
      - include: "#hierarchical-identifier"
  hierarchical-variable-identifier:
    patterns:
      - include: "#hierarchical-identifier"
  identifier:
    patterns:
      # For built-in methods, we use an educated guess to highlight them as functions
      # 1. Associative array methods: num, size, delete, exists, first, last, next, prev
      # 2. Queue: size, insert, delete, pop_front, pop_back, push_front, push_back
      # 3. Array locator: find, find_index, find_first, find_first_index, find_last, find_last_index, min, max, unique, unique_index
      # 4. Array ordering: reverse, sort, rsort, shuffle
      # 5. Array reduction: sum, product, and, or, xor
      # 6. Iterator index querying: index
      - match: (?<=\.)\b(num|size|delete|exists|first|last|next|prev|insert|pop_front|pop_back|push_front|push_back|find|find_index|find_first|find_first_index|find_last|find_last_index|min|max|unique|unique_index|reverse|sort|rsort|shuffle|sum|product|and|or|xor|index)\b(?!\b(if|case|casez|casex)\b)
        captures:
          "1": { name: entity.name.function.sv }
      - match: \b([A-Z][a-zA-Z0-9_$]*)\b(?!\s*${identifier}|\(|\'|::)
        captures:
          "1": { name: variable.other.constant.sv }
      - match: (${identifier})\s*${identifierEnd}
        captures:
          "1": { name: variable.other.sv }
  index-variable-identifier:
    patterns:
      - include: "#identifier"
  interface-instance-identifier:
    patterns:
      - include: "#identifier"
  interface-identifier:
    patterns:
      - include: "#identifier"
  inout-port-identifier:
    patterns:
      - include: "#identifier"
  input-port-identifier:
    patterns:
      - include: "#identifier"
  instance-identifier:
    patterns:
      - include: "#identifier"
  library-identifier:
    patterns:
      - include: "#identifier"
  member-identifier:
    patterns:
      - include: "#identifier"
  method-identifier:
    patterns:
      - include: "#identifier"
  modport-identifier:
    patterns:
      - include: "#identifier"
  module-identifier:
    match: (${identifier})(?=\s+${identifier})
    captures:
      "1": { name: entity.name.type.sv }
  net-identifier:
    patterns:
      - include: "#identifier"
  net-type-identifier:
    match: (${identifier})\s*${typeIdentifierEnd}
    captures:
      "1": { name: entity.name.type.sv }
  output-port-identifier:
    patterns:
      - include: "#identifier"
  package-identifier:
    patterns:
      - include: "#identifier"
  package-scope:
    patterns:
      - match: (\$unit)\s*
        captures:
          "1": { name: entity.name.namespace.sv }
      - match: (${identifier})\s*(::)\s*
        captures:
          "1": { name: entity.name.namespace.sv }
          "2": { name: punctuation.separator.scope-resolution.sv }
  parameter-identifier:
    match: (${identifier})\s*${identifierEnd}
    captures:
      "1": { name: variable.other.constant.sv }
  port-identifier:
    patterns:
      - include: "#identifier"
  production-identifier:
    patterns:
      - include: "#identifier"
  program-identifier:
    patterns:
      - include: "#identifier"
  property-identifier:
    patterns:
      - include: "#identifier"
  ps-class-identifier:
    patterns:
      - include: "#package-scope"
      - include: "#class-identifier"
  ps-covergroup-identifier:
    patterns:
      - include: "#package-scope"
      - include: "#covergroup-identifier"
  ps-checker-identifier:
    patterns:
      - include: "#package-scope"
      - include: "#checker-identifier"
  ps-identifier:
    patterns:
      - include: "#package-scope"
      - include: "#identifier"
  ps-or-hierarchical-array-identifier:
    patterns:
      - include: "#implicit-class-handle"
      - match: (\.)\s*
        captures:
          "1": { name: punctuation.accessor.dot.sv }
      - include: "#class-scope"
      - include: "#package-scope"
      - include: "#hierarchical-array-identifier"
  ps-or-hierarchical-net-identifier:
    patterns:
      - include: "#package-scope"
      - include: "#net-identifier"
      - include: "#hierarchical-net-identifier"
  ps-or-hierarchical-property-identifier:
    patterns:
      - include: "#package-scope"
      - include: "#property-identifier"
      - include: "#hierarchical-property-identifier"
  ps-or-hierarchical-sequence-identifier:
    patterns:
      - include: "#package-scope"
      - include: "#sequence-identifier"
      - include: "#hierarchical-sequence-identifier"
  ps-or-hierarchical-tf-identifier:
    patterns:
      - include: "#package-scope"
      - include: "#tf-identifier"
      - include: "#hierarchical-tf-identifier"
  ps-parameter-identifier:
    patterns:
      - include: "#package-scope"
      - include: "#class-scope"
      - include: "#generate-block-identifier"
      - include: "#dimension"
      - match: (\.)\s*
        captures:
          "1": { name: punctuation.accessor.dot.sv }
      - include: "#parameter-identifier"
  ps-type-identifier:
    patterns:
      - match: (\b(local)\b)\s*(::)\s*
        captures:
          "1": { name: keyword.other.local.sv }
          "2": { name: punctuation.separator.scope-resolution.sv }
      - include: "#package-scope"
      - include: "#class-scope"
      - include: "#type-identifier"
  sequence-identifier:
    patterns:
      - include: "#identifier"
  signal-identifier:
    patterns:
      - include: "#identifier"
  simple-identifier:
    name: variable.other.sv
    match: ${simpleIdentifier}
  specparam-identifier:
    patterns:
      - include: "#parameter-identifier"
  system-tf-identifier:
    match: (\$[a-zA-Z0-9_\$]+)\b
    captures:
      "1": { name: entity.name.function.sv }
  task-identifier:
    match: (${functionIdentifier})\s*${functionIdentifierEnd}
    captures:
      "1": { name: entity.name.function.sv }
  tf-identifier:
    match: (${functionIdentifier})\s*${functionIdentifierEnd}
    captures:
      "1": { name: entity.name.function.sv }
  terminal-identifier:
    patterns:
      - include: "#identifier"
  topmodule-identifier:
    patterns:
      - include: "#identifier"
  type-identifier:
    match: (${identifier})\s*${typeIdentifierEnd}
    captures:
      "1": { name: entity.name.type.sv }
  udp-identifier:
    patterns:
      - include: "#identifier"
  variable-identifier:
    patterns:
      - include: "#identifier"
  # Compiler directives
  compiler-directive:
    patterns:
      - include: "#macro-resetall"
      - include: "#macro-include"
      - include: "#macro-define"
      - include: "#macro-undefineall"
      - include: "#macro-undef"
      - include: "#macro-ifdef"
      - include: "#macro-elsif"
      - include: "#macro-else"
      - include: "#macro-ifndef"
      - include: "#macro-endif"
      - include: "#macro-timescale"
      - include: "#macro-default-nettype"
      - include: "#macro-unconnected-drive"
      - include: "#macro-nounconnected-drive"
      - include: "#macro-celldefine"
      - include: "#macro-endcelldefine"
      - include: "#macro-pragma"
      - include: "#macro-line"
      - include: "#macro-begin-keywords"
      - include: "#macro-end-keywords"
      - include: "#macro-__line__"
      - include: "#macro-__file__"
      - include: "#text-macro-usage"
  macro-resetall:
    match: (`resetall)\b
    name: keyword.control.resetall.sv
  macro-include:
    name: meta.preprocessor.include.sv
    begin: (`include)\s*
    end: $
    beginCaptures:
      "1": { name: keyword.control.include.sv }
    patterns:
      - match: ("[^"]*")
        name: string.quoted.double.include.sv
      - match: (<[^>]*>)
        name: string.quoted.angle.include.sv
      - include: "#text-macro-usage"
  macro-define:
    name: meta.macro-definition.sv
    patterns:
      # Oneline
      - match: (`define)\s*([a-zA-Z_][a-zA-Z0-9_\$]*)\s*(.*)$
        captures:
          "1": { name: keyword.control.define.sv }
          "2": { name: meta.preprocessor.macro-name.sv }
          "3":
            patterns:
              - name: meta.preprocessor.macro-text.sv
                begin: \(
                end: \)
                beginCaptures:
                  "0": { name: punctuation.section.group.begin.sv }
                endCaptures:
                  "0": { name: punctuation.section.group.end.sv }
                patterns:
                  - include: "#formal-argument"
                  - include: "#comma"
              - include: "#macro-text"
      # Multiline
      - name: meta.macro-definition.sv
        begin: (`define)\s*([a-zA-Z_][a-zA-Z0-9_\$]*)
        end: (?<!\\)$
        beginCaptures:
          "1": { name: keyword.control.define.sv }
          "2": { name: meta.preprocessor.macro-name.sv }
        patterns:
          - name: meta.preprocessor.macro-text.sv
            begin: \(
            end: \)
            beginCaptures:
              "0": { name: punctuation.section.group.begin.sv }
            endCaptures:
              "0": { name: punctuation.section.group.end.sv }
            patterns:
              - include: "#formal-argument"
              - include: "#comma"
          - include: "#macro-continuation"
          - include: "#macro-text"
  macro-continuation:
    match: \\
    name: punctuation.separator.continuation.sv
  macro-text:
    patterns:
      # Escaped quotation mark
      - name: string.quoted.macro.sv
        begin: \`\"
        end: \`\"
        beginCaptures:
          "0": { name: constant.character.escape.sv }
        endCaptures:
          "0": { name: constant.character.escape.sv }
        patterns:
          - match: \`\`
            name: constant.character.escape.sv
          - match: \`\\\`\"
            name: constant.character.escape.sv
          - match: (?:\\u[0-9a-fA-F]{4}|\\U[0-9a-fA-F]{8})
            name: constant.character.escape.sv
          - match: (?:\\[abfnrtv\\\"\'\?])
            name: constant.character.escape.sv
          - match: (?:\\[0-7]{1,3})
            name: constant.character.escape.sv
          - match: (?:\\x[0-9a-fA-F]{1,2})
            name: constant.character.escape.sv
          - match: \%(\d+\$)?[#0\- +']*[,;:_]?((-?\d+)|\*(-?\d+\$)?)?(\.((-?\d+)|\*(-?\d+\$)?)?)?(hh|h|ll|l|j|t|z|q|L|vh|vl|v|hv|hl)?[hHxXdDoObBcClLvVmMpPsStTuUzZieEfFgGaAn%]
            name: constant.other.placeholder.sv
          - match: \\\n
            name: punctuation.separator.continuation.sv
      - match: ((?<!\\|\$)\b[a-zA-Z_][`a-zA-Z0-9_\$]*\b|\\\S+(?=\s|$))(?<!\b(?:accept_on|alias|always|always_comb|always_ff|always_latch|and|assert|assign|assume|automatic|before|begin|bind|bins|binsof|bit|break|buf|bufif0|bufif1|byte|case|casex|casez|cell|chandle|checker|class|clocking|cmos|config|const|constraint|context|continue|cover|covergroup|coverpoint|cross|deassign|default|defparam|design|disable|dist|do|edge|else|end|endcase|endchecker|endclass|endclocking|endconfig|endfunction|endgenerate|endgroup|endinterface|endmodule|endpackage|endprimitive|endprogram|endproperty|endspecify|endsequence|endtable|endtask|enum|event|eventually|expect|export|extends|extern|final|first_match|for|force|foreach|forever|fork|forkjoin|function|generate|genvar|global|highz0|highz1|if|iff|ifnone|ignore_bins|illegal_bins|implements|implies|import|incdir|include|initial|inout|input|inside|instance|int|integer|interconnect|interface|intersect|join|join_any|join_none|large|let|liblist|library|local|localparam|logic|longint|macromodule|matches|medium|modport|module|nand|negedge|nettype|new|nexttime|nmos|nor|noshowcancelled|not|notif0|notif1|null|or|output|package|packed|parameter|pmos|posedge|primitive|priority|program|property|protected|pull0|pull1|pulldown|pullup|pulsestyle_ondetect|pulsestyle_onevent|pure|rand|randc|randcase|randsequence|rcmos|real|realtime|ref|reg|reject_on|release|repeat|restrict|return|rnmos|rpmos|rtran|rtranif0|rtranif1|s_always|s_eventually|s_nexttime|s_until|s_until_with|scalared|sequence|shortint|shortreal|showcancelled|signed|small|soft|solve|specify|specparam|static|string|strong|strong0|strong1|struct|super|supply0|supply1|sync_accept_on|sync_reject_on|table|tagged|task|this|throughout|time|timeprecision|timeunit|tran|tranif0|tranif1|tri|tri0|tri1|triand|trior|trireg|type|typedef|union|unique|unique0|unsigned|until|until_with|untyped|use|uwire|var|vectored|virtual|void|wait|wait_order|wand|weak|weak0|weak1|while|wildcard|wire|with|within|wor|xnor|xor)\b)
        captures:
          "1":
            name: variable.other.sv
            patterns:
              - match: \`\`
                name: constant.character.escape.sv
      - include: "#module-item"
      - include: "#expression"
  formal-argument:
    patterns:
      - match: \b([a-zA-Z_][a-zA-Z0-9_\$]*)\b
        name: variable.other.sv
      - include: "#equals"
      - include: "#expression"
  text-macro-usage:
    patterns:
      # Macro function
      - begin: (${macro})\s*(\()\s*
        end: (\))\s*
        name: meta.preprocessor.text-macro-usage.sv meta.preprocessor.macro-function.sv
        beginCaptures:
          "1": { name: meta.preprocessor.macro-name.sv }
          "2": { name: punctuation.section.group.begin.sv }
        endCaptures:
          "1": { name: punctuation.section.group.end.sv }
        patterns:
          - include: "#expression"
          - include: "#comma"
      # Macro variable
      - match: (${macro})\s*(?!\s*[a-zA-Z_(])
        name: meta.preprocessor.text-macro-usage.sv meta.preprocessor.macro-name.sv
  macro-undef:
    match: (`undef)\s*([a-zA-Z_][a-zA-Z0-9_\$]*)
    captures:
      "1": { name: keyword.control.undef.sv }
      "2": { name: meta.preprocessor.macro-name.sv }
  macro-undefineall:
    match: (`undefineall)\b
    name: keyword.control.undefineall.sv
  macro-ifdef:
    match: (`ifdef)\s*([a-zA-Z_][a-zA-Z0-9_\$]*)
    captures:
      "1": { name: keyword.control.ifdef.sv }
      "2": { name: meta.preprocessor.macro-name.sv }
  macro-elsif:
    match: (`elsif)\s*([a-zA-Z_][a-zA-Z0-9_\$]*)
    captures:
      "1": { name: keyword.control.elsif.sv }
      "2": { name: meta.preprocessor.macro-name.sv }
  macro-else:
    match: (`else)\b
    name: keyword.control.else.sv
  macro-ifndef:
    match: (`ifndef)\s*([a-zA-Z_][a-zA-Z0-9_\$]*)
    captures:
      "1": { name: keyword.control.ifndef.sv }
      "2": { name: meta.preprocessor.macro-name.sv }
  macro-endif:
    match: (`endif)\b
    name: keyword.control.endif.sv
  macro-timescale:
    # `timescale time_unit / time_precision
    begin: (`timescale)\s*
    end: $
    beginCaptures:
      "1": { name: keyword.control.timescale.sv }
    patterns:
      - match: \/
        name: punctuation.separator.slash.sv
      - include: "#time-literal"
  macro-default-nettype:
    # `default_nettype net_type
    match: (`default_nettype)\s+(wire|tri|tri0|tri1|wand|triand|wor|trior|trireg|uwire|none)\b
    captures:
      "1": { name: keyword.control.default-nettype.sv }
      "2": { name: storage.type.$2.sv }
  macro-nounconnected-drive:
    # `nounconnected_drive drive_strength
    match: (`nounconnected_drive)\s*
    captures:
      "1": { name: keyword.control.nounconnected-drive.sv }
  macro-unconnected-drive:
    # `unconnected_drive drive_strength
    match: (`unconnected_drive)\s+(pull0|pull1)\b
    captures:
      "1": { name: keyword.control.unconnected-drive.sv }
      "2": { name: storage.modifier.$2.sv }
  macro-celldefine:
    # `celldefine
    match: (`celldefine)\b
    name: keyword.control.celldefine.sv
  macro-endcelldefine:
    # `endcelldefine
    match: (`endcelldefine)\b
    name: keyword.control.endcelldefine.sv
  macro-pragma:
    # `pragma
    begin: (`pragma)\s+([a-zA-Z_][a-zA-Z0-9_$]*)\b\s*
    beginCaptures:
      "1": { name: keyword.control.pragma.sv }
      "2": { name: entity.other.attribute-name.sv }
    end: $
    patterns:
      - include: "#comma"
      - include: "#pragma-expression"
  pragma-expression:
    patterns:
      # pragma_keyword = pragma_value
      - begin: (${simpleIdentifier})\s*(\=)\s*
        beginCaptures:
          "1": { name: entity.other.attribute-name.sv }
          "2": { name: keyword.operator.assignment.sv }
        end: (?=\,|\)|$)
        patterns:
          - include: "#pragma-value"
      # pragma_value
      - include: "#pragma-value"
  pragma-value:
    patterns:
      - begin: \(
        end: \)
        beginCaptures:
          "0": { name: punctuation.section.group.begin.sv }
        endCaptures:
          "0": { name: punctuation.section.group.end.sv }
        patterns:
          - include: "#comma"
          - include: "#pragma-expression"
      - include: "#number"
      - include: "#unary-operator"
      - include: "#string-literal"
      - include: "#simple-identifier"
  macro-line:
    match: (`line)\s+([0-9]+)\s+(\"[^"]+\")\s+([0-9]+)
    captures:
      "1": { name: keyword.control.line.sv }
      "2": { name: constant.numeric.integer.sv }
      "3": { name: string.quoted.double.sv }
      "4": { name: constant.numeric.integer.sv }
  macro-begin-keywords:
    match: (`begin_keywords)\s+(\"[^"]+\")
    captures:
      "1": { name: keyword.control.begin-keywords.sv }
      "2": { name: string.quoted.double.sv }
  macro-end-keywords:
    match: (`end_keywords)\b
    name: keyword.control.end-keywords.sv
  macro-__line__:
    match: (`__LINE__)\b
    name: meta.preprocessor.macro-name.sv
  macro-__file__:
    match: (`__FILE__)\b
    name: meta.preprocessor.macro-name.sv
  # Misc
  semicolon:
    match: (\;)[ \t]*
    captures:
      "1": { name: punctuation.terminator.semicolon.sv }
  comma:
    match: (\,)\s*
    captures:
      "1": { name: punctuation.separator.comma.sv }
  equals:
    match: (\=)\s*(?!\=)
    captures:
      "1": { name: keyword.operator.assignment.sv }
  colon:
    match: (\:)\s*
    captures:
      "1": { name: punctuation.separator.colon.sv }

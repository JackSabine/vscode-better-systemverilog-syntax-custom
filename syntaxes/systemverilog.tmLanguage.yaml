name: SystemVerilog
scopeName: source-text.sv
variables:
  simpleIdentifier: \b[a-zA-Z_][a-zA-Z0-9_\$]*\b
  identifier: (?:(?<!\\|\$|\`)\b[a-zA-Z_][a-zA-Z0-9_\$]*\b|\\\S+(?=\s|$))(?<!\b(?:accept_on|alias|always|always_comb|always_ff|always_latch|and|assert|assign|assume|automatic|before|begin|bind|bins|binsof|bit|break|buf|bufif0|bufif1|byte|case|casex|casez|cell|chandle|checker|class|clocking|cmos|config|const|constraint|context|continue|cover|covergroup|coverpoint|cross|deassign|default|defparam|design|disable|dist|do|edge|else|end|endcase|endchecker|endclass|endclocking|endconfig|endfunction|endgenerate|endgroup|endinterface|endmodule|endpackage|endprimitive|endprogram|endproperty|endspecify|endsequence|endtable|endtask|enum|event|eventually|expect|export|extends|extern|final|first_match|for|force|foreach|forever|fork|forkjoin|function|generate|genvar|global|highz0|highz1|if|iff|ifnone|ignore_bins|illegal_bins|implements|implies|import|incdir|include|initial|inout|input|inside|instance|int|integer|interconnect|interface|intersect|join|join_any|join_none|large|let|liblist|library|local|localparam|logic|longint|macromodule|matches|medium|modport|module|nand|negedge|nettype|new|nexttime|nmos|nor|noshowcancelled|not|notif0|notif1|null|or|output|package|packed|parameter|pmos|posedge|primitive|priority|program|property|protected|pull0|pull1|pulldown|pullup|pulsestyle_ondetect|pulsestyle_onevent|pure|rand|randc|randcase|randsequence|rcmos|real|realtime|ref|reg|reject_on|release|repeat|restrict|return|rnmos|rpmos|rtran|rtranif0|rtranif1|s_always|s_eventually|s_nexttime|s_until|s_until_with|scalared|sequence|shortint|shortreal|showcancelled|signed|small|soft|solve|specify|specparam|static|string|strong|strong0|strong1|struct|super|supply0|supply1|sync_accept_on|sync_reject_on|table|tagged|task|this|throughout|time|timeprecision|timeunit|tran|tranif0|tranif1|tri|tri0|tri1|triand|trior|trireg|type|typedef|union|unique|unique0|unsigned|until|until_with|untyped|use|uwire|var|vectored|virtual|void|wait|wait_order|wand|weak|weak0|weak1|while|wildcard|wire|with|within|wor|xnor|xor)\b|`(?:__FILE__|__LINE__|begin_keywords|celldefine|default_nettype|define|else|elsif|end_keywords|endcelldefine|endif|ifdef|ifndef|include|line|nounconnected_drive|pragma|resetall|timescale|unconnected_drive|undef|undefineall)\b)
  macro: (?:`[a-zA-Z_][a-zA-Z0-9_\$]*\b(?:\(.*?\))?)(?<!`(?:__FILE__|__LINE__|begin_keywords|celldefine|default_nettype|define|else|elsif|end_keywords|endcelldefine|endif|ifdef|ifndef|include|line|nounconnected_drive|pragma|resetall|timescale|unconnected_drive|undef|undefineall)\b)
  # Remove array method name: unique, and, or, xor
  functionIdentifier: (?:(?<!\\|\$)(?:\b[a-zA-Z_]|\$)[a-zA-Z0-9_\$]*\b|\\\S+(?=\s|$))(?<!\b(?:accept_on|alias|always|always_comb|always_ff|always_latch|assert|assign|assume|automatic|before|begin|bind|bins|binsof|bit|break|buf|bufif0|bufif1|byte|case|casex|casez|cell|chandle|checker|class|clocking|cmos|config|const|constraint|context|continue|cover|covergroup|coverpoint|cross|deassign|default|defparam|design|disable|dist|do|edge|else|end|endcase|endchecker|endclass|endclocking|endconfig|endfunction|endgenerate|endgroup|endinterface|endmodule|endpackage|endprimitive|endprogram|endproperty|endspecify|endsequence|endtable|endtask|enum|event|eventually|expect|export|extends|extern|final|first_match|for|force|foreach|forever|fork|forkjoin|function|generate|genvar|global|highz0|highz1|if|iff|ifnone|ignore_bins|illegal_bins|implements|implies|import|incdir|include|initial|inout|input|inside|instance|int|integer|interconnect|interface|intersect|join|join_any|join_none|large|let|liblist|library|local|localparam|logic|longint|macromodule|matches|medium|modport|module|nand|negedge|nettype|new|nexttime|nmos|nor|noshowcancelled|not|notif0|notif1|null|output|package|packed|parameter|pmos|posedge|primitive|priority|program|property|protected|pull0|pull1|pulldown|pullup|pulsestyle_ondetect|pulsestyle_onevent|pure|rand|randc|randcase|randsequence|rcmos|real|realtime|ref|reg|reject_on|release|repeat|restrict|return|rnmos|rpmos|rtran|rtranif0|rtranif1|s_always|s_eventually|s_nexttime|s_until|s_until_with|scalared|sequence|shortint|shortreal|showcancelled|signed|small|soft|solve|specify|specparam|static|string|strong|strong0|strong1|struct|super|supply0|supply1|sync_accept_on|sync_reject_on|table|tagged|task|this|throughout|time|timeprecision|timeunit|tran|tranif0|tranif1|tri|tri0|tri1|triand|trior|trireg|type|typedef|union|unique0|unsigned|until|until_with|untyped|use|uwire|var|vectored|virtual|void|wait|wait_order|wand|weak|weak0|weak1|while|wildcard|wire|with|within|wor|xnor)\b)
  classScope: (?:${identifier}\s*(?:\#\(.*?\)\s*)?::\s*)+
  # Identifier can be followed by ":" (ternary statement, label, etc.)
  identifierEnd: (?!\s*(${identifier}|#(?!\#)|\(|\'|::))
  typeIdentifierStart: (?<!\#\s*)
  # Type identifier can be followed by "#" (class, module, etc.)
  # Type identifier can be followed by "[" (unpacked dimension)
  typeIdentifierEnd: (?!\s*(\(|\.|\=|::|:|${identifier}\s*\())
  functionIdentifierStart: (?<!(?:\))\s+)
  functionIdentifierEnd: (?!\s*(\b\w+\b|\.|\[|#|::))
  classIdentifierStart: (?<!\#\s*)
  classIdentifierEnd: (?!\s*(\(|\.|\=|:|${identifier}\s*\())
  psIdentifier: (?:(?:${identifier})\s*(?:::)\s*)?(?:${identifier})
  # When there is a new design element, the current design element should be ended
  designElementsFailSafe: (?=\b(?:module|program|interface|checker|package|primitive|config)\b)
  blocksFailSafe: (?=\b(?:endmodule|endprogram|endinterface|endchecker|endpackage|endprimitive|endconfig)\b)
  # When there is an end of block, the statement should be ended
  itemsFailSafe: (?=\b(?:endmodule|endprimitive|endinterface|endpackage|endconfig|endtask|endfunction|endchecker|endclass|endgroup|endproperty|endsequence|endgenerate|endtable|endclocking|endspecify)\b)|${blocksFailSafe}
  statementStart: \b(?:assign|deassign|force|release|case|casez|casex|if|else|disable(?!\s*\biff\b)|forever|repeat|while|for|do|foreach|return|break|continue|fork|begin|wait|wait_order|assert|assume|cover|randsequence|randcase|expect)\b
  statementsFailSafe: ${itemsFailSafe}|(?=${statementStart})
  bracketsFailSafe: (?=\b(?:end|endcase)\b)|${itemsFailSafe}|(?=${statementStart})
  assignmentEnd: (?=\,|\)|\;)|${bracketsFailSafe}|(?=${statementStart})

patterns:
  - include: "#comment"
  - include: "#compiler-directive"
  - include: "#description"
  - include: "#module-item"
  - include: "#interface-item"
  - include: "#program-item"
  - include: "#checker-item"
  - include: "#package-item"
  - include: "#class-item"
  - include: "#interface-class-item"
  - include: "#interface-item"
repository:
  # A.1.2 SystemVerilog source text
  description:
    patterns:
      - include: "#attribute-instance"
      - include: "#module-declaration"
      - include: "#udp-declaration"
      - include: "#interface-declaration"
      - include: "#program-declaration"
      - include: "#package-declaration"
      - include: "#package-item"
      - include: "#bind-directive"
      - include: "#config-declaration"
  module-declaration:
    name: meta.module-declaration.sv
    begin: (?=\b(module|macromodule)\b)
    end: \b(endmodule)\b\s*(?:(\:)\s*(${identifier})\s*)?
    endCaptures:
      "1": { name: storage.type.module.sv }
      "2": { name: punctuation.separator.colon.sv }
      "3": { name: entity.name.type.sv }
    patterns:
      - name: meta.module-header.sv
        begin: \b(module|macromodule)\b\s+(?:\b(static|automatic)\b\s+)?((${identifier})\s*)?
        end: (?=\;)|(?=\b(endmodule)\b)
        beginCaptures:
          "1": { name: storage.type.$1.sv }
          "2": { name: storage.modifier.$2.sv }
          "3": { name: entity.name.type.sv }
        patterns:
          - include: "#package-import-declaration"
          - include: "#parameter-port-list"
          - include: "#list-of-port-declarations"
      - name: meta.module-body.sv
        begin: (\;)\s*
        end: (?=\b(endmodule)\b)
        beginCaptures:
          "1": { name: punctuation.terminator.semicolon.sv }
        patterns:
          - include: "#timeunits-declaration"
          - include: "#module-item"
          - include: "#non-port-module-item"
  interface-declaration:
    begin: (?=\b(interface)\b(?!\s*\bclass\b))
    end: \b(endinterface)\b\s*(?:(\:)\s*(${identifier})\s*)?
    endCaptures:
      "1": { name: storage.type.interface.sv }
      "2": { name: punctuation.separator.colon.sv }
      "3": { name: entity.name.type.sv }
    patterns:
      - name: meta.interface-header.sv
        begin: \b(interface)\b\s+(?:\b(static|automatic)\b\s+)?(?:(${identifier})\s*)?(?!\bclass\b)
        end: (?=\;)
        beginCaptures:
          "1": { name: storage.type.interface.sv }
          "2": { name: storage.modifier.$2.sv }
          "3": { name: entity.name.type.sv }
        patterns:
          - include: "#package-import-declaration"
          - include: "#parameter-port-list"
          - include: "#list-of-port-declarations"
      - name: meta.interface-body.sv
        begin: (\;)\s*
        end: (?=\b(endinterface)\b)
        beginCaptures:
          "1": { name: punctuation.terminator.semicolon.sv }
        patterns:
          - include: "#timeunits-declaration"
          - include: "#interface-item"
          - include: "#non-port-interface-item"
  program-declaration:
    begin: (?=\b(program)\b)
    end: \b(endprogram)\b\s*(?:(\:)\s*(${identifier})\s*)?
    endCaptures:
      "1": { name: storage.type.program.sv }
      "2": { name: punctuation.separator.colon.sv }
      "3": { name: entity.name.type.sv }
    patterns:
      - name: meta.program-header.sv
        begin: \b(program)\b\s+(?:\b(static|automatic)\b\s+)?(?:(${identifier})\s*)?
        end: (?=\;)
        beginCaptures:
          "1": { name: storage.type.program.sv }
          "2": { name: storage.modifier.$2.sv }
          "3": { name: entity.name.type.sv }
        patterns:
          - include: "#package-import-declaration"
          - include: "#parameter-port-list"
          - include: "#list-of-port-declarations"
      - name: meta.program-body.sv
        begin: (\;)\s*
        end: (?=\b(endprogram)\b)
        beginCaptures:
          "1": { name: punctuation.terminator.semicolon.sv }
        patterns:
          - include: "#timeunits-declaration"
          - include: "#program-item"
          - include: "#non-port-program-item"
  checker-declaration:
    name: meta.checker-declaration.sv
    begin: (?=\b(checker)\b)
    end: \b(endchecker)\b\s*(?:(\:)\s*(${identifier})\s*)?|${blocksFailSafe}
    endCaptures:
      "1": { name: storage.type.checker.sv }
      "2": { name: punctuation.separator.colon.sv }
      "3": { name: entity.name.type.sv }
    patterns:
      - name: meta.checker-header.sv
        begin: \b(checker)\b\s*(?:(${identifier})\s*)?
        end: (?=\;)|${blocksFailSafe}
        beginCaptures:
          "1": { name: storage.type.checker.sv }
          "2": { name: entity.name.type.sv }
        patterns:
          - begin: (\()\s*
            end: (\))\s*|${bracketsFailSafe}
            beginCaptures:
              "1": { name: punctuation.section.group.begin.sv }
            endCaptures:
              "1": { name: punctuation.section.group.end.sv }
            patterns:
              - include: "#checker-port-list"
      - name: meta.checker-body.sv
        begin: (\;)\s*
        end: (?=\b(endchecker)\b)|${blocksFailSafe}
        beginCaptures:
          "1": { name: punctuation.terminator.semicolon.sv }
        patterns:
          - include: "#attribute-instance"
          - include: "#checker-or-generate-item"
  class-declaration:
    begin: (?=\b(class)\b|\bvirtual\b\s+\bclass\b)
    end: \b(endclass)\b\s*(?:(\:)\s*(${identifier})\s*)?|${blocksFailSafe}
    endCaptures:
      "1": { name: storage.type.class.sv }
      "2": { name: punctuation.separator.colon.sv }
      "3": { name: entity.name.type.sv }
    patterns:
      # Header
      - name: meta.class-header.sv
        begin: (?:\b(virtual)\b\s+)?\b(class)\b\s*
        end: (?=\;)|${blocksFailSafe}
        beginCaptures:
          "1": { name: storage.modifier.virtual.sv }
          "2": { name: storage.type.$2.sv }
        patterns:
          - include: "#lifetime"
          - include: "#class-identifier"
          - include: "#parameter-port-list"
          # Extends
          - begin: \b(extends)\b\s*
            end: (?=\;|\b(implements)\b)
            beginCaptures:
              "1": { name: storage.modifier.$1.sv }
            patterns:
              - include: "#class-type"
              - include: "#list-of-arguments"
          # Implements
          - begin: \b(implements)\b\s*
            end: (?=\;)
            beginCaptures:
              "1": { name: storage.modifier.$1.sv }
            patterns:
              - include: "#interface-class-type"
              - include: "#comma"
      # Body
      - name: meta.class-body.sv
        begin: (\;)\s*
        end: (?=\b(endclass)\b)|${blocksFailSafe}
        beginCaptures:
          "1": { name: punctuation.terminator.semicolon.sv }
        patterns:
          - include: "#class-item"
  interface-class-type:
    patterns:
      - include: "#ps-class-identifier"
      - include: "#parameter-value-assignment"
  interface-class-declaration:
    begin: (?=\binterface\b\s+\bclass\b)
    end: \b(endclass)\b\s*(?:(\:)\s*(${identifier})\s*)?
    endCaptures:
      "1": { name: storage.type.class.sv }
      "2": { name: punctuation.separator.colon.sv }
      "3": { name: entity.name.type.sv }
    patterns:
      - name: meta.interface-class-header.sv
        begin: \b(interface)\b\s+\b(class)\b\s*(?:(${identifier})\s*)?
        end: (?=\;)
        beginCaptures:
          "1": { name: storage.type.interface.sv }
          "2": { name: storage.type.class.sv }
          "3": { name: entity.name.type.sv }
        patterns:
          - include: "#parameter-port-list"
          - begin: \b(extends)\b\s*
            end: (?=\;)
            beginCaptures:
              "1": { name: storage.modifier.$1.sv }
            patterns:
              - include: "#interface-class-type"
              - include: "#comma"
      - name: meta.interface-class-body.sv
        begin: (\;)\s*
        end: (?=\b(endclass)\b)
        beginCaptures:
          "1": { name: punctuation.terminator.semicolon.sv }
        patterns:
          - include: "#interface-class-item"
  interface-class-item:
    patterns:
      - include: "#type-declaration"
      - include: "#attribute-instance"
      - include: "#interface-class-method"
      - include: "#local-parameter-declaration"
      - include: "#parameter-declaration"
      - include: "#semicolon"
  interface-class-method:
    begin: \b(pure)\b\s+\b(virtual)\b\s*
    end: (\;)\s*
    beginCaptures:
      "1": { name: storage.modifier.pure.sv }
      "2": { name: storage.modifier.virtual.sv }
    endCaptures:
      "1": { name: punctuation.terminator.semicolon.sv }
    patterns:
      - include: "#method-prototype"
  package-declaration:
    begin: (?=\b(package)\b)
    end: \b(endpackage)\b\s*(?:(\:)\s*(${identifier})\s*)?
    endCaptures:
      "1": { name: storage.type.package.sv }
      "2": { name: punctuation.separator.colon.sv }
      "3": { name: entity.name.namespace.sv }
    patterns:
      - name: meta.package-header.sv
        begin: \b(package)\b\s+(?:\b(static|automatic)\b\s+)?(?:(${identifier})\s*)?
        end: (?=\;)
        beginCaptures:
          "1": { name: storage.type.package.sv }
          "2": { name: storage.modifier.$2.sv }
          "3": { name: entity.name.namespace.sv }
      - name: meta.package-body.sv
        begin: (\;)\s*
        end: (?=\b(endpackage)\b)
        beginCaptures:
          "1": { name: punctuation.terminator.semicolon.sv }
        patterns:
          - include: "#timeunits-declaration"
          - include: "#package-item"
  timeunits-declaration:
    begin: \b(timeunit|timeprecision)\b\s*
    end: (\;)\s*
    beginCaptures:
      "1": { name: storage.type.$1.sv }
    endCaptures:
      "1": { name: punctuation.terminator.semicolon.sv }
    patterns:
      - match: (\/)]\s*
        captures:
          "1": { name: punctuation.separator.slash.sv }
      - include: "#time-literal"
  # A.1.3 Module parameters and ports
  parameter-port-list:
    name: meta.parameter-port-list.sv
    begin: (\#\s*\()\s*
    end: (\))\s*|${bracketsFailSafe}
    beginCaptures:
      "1": { name: punctuation.section.group.begin.sv }
    endCaptures:
      "1": { name: punctuation.section.group.end.sv }
    patterns:
      - include: "#list-of-param-assignments"
      - include: "#parameter-port-declaration"
      - include: "#comma"
  parameter-port-declaration:
    patterns:
      - begin: \b(type)\b\s*
        end: (?=\;|\,|\))
        name: meta.parameter-port-declaration.sv
        beginCaptures:
          "1": { name: storage.type.type.sv }
        patterns:
          - include: "#list-of-type-assignments"
      - include: "#list-of-param-assignments"
      - include: "#parameter-declaration"
      - include: "#local-parameter-declaration"
      - include: "#data-type"
  list-of-port-declarations:
    name: meta.list-of-port-declarations.sv
    begin: (\()\s*(?!\*)
    end: (\))\s*|${bracketsFailSafe}
    beginCaptures:
      "1": { name: punctuation.section.group.begin.sv }
    endCaptures:
      "1": { name: punctuation.section.group.end.sv }
    patterns:
      - include: "#comma"
      - include: "#attribute-instance"
      - include: "#port"
      - include: "#ansi-port-declaration"
  port-declaration:
    patterns:
      - include: "#attribute-instance"
      - include: "#inout-declaration"
      - include: "#input-declaration"
      - include: "#output-declaration"
      - include: "#ref-declaration"
      - include: "#interface-port-declaration"
  port:
    patterns:
      - name: meta.port.sv
        begin: (\.)(${identifier})\s*(\()\s*
        end: (\))\s*|${bracketsFailSafe}
        beginCaptures:
          "1": { name: punctuation.definition.named-port.sv }
          "2": { name: variable.other.sv }
          "3": { name: punctuation.section.group.begin.sv }
        endCaptures:
          "1": { name: punctuation.section.group.end.sv }
        patterns:
          - include: "#port-expression"
      - include: "#port-expression"
  port-expression:
    patterns:
      - include: "#port-reference"
      - name: meta.port-expression.sv
        begin: (\{)\s*
        end: (\})\s*|${bracketsFailSafe}
        beginCaptures:
          "1": { name: punctuation.section.group.begin.sv }
        endCaptures:
          "1": { name: punctuation.section.group.end.sv }
        patterns:
          - include: "#port-reference"
          - include: "#comma"
  port-reference:
    name: meta.port-reference.sv
    begin: (?<=(?:\{|\,|\()\s*|^)(${identifier})\s*(?=\[|\,|\}|\))
    beginCaptures:
      "1": { name: variable.other.sv }
    end: (?=,|\}|\))
    patterns:
      - include: "#port-identifier"
      - include: "#constant-select"
  port-direction:
    patterns:
      - match: \b(input|output|inout|ref)\b
        captures:
          "1": { name: storage.modifier.$1.sv }
  net-port-header:
    patterns:
      - include: "#port-direction"
      - include: "#net-port-type"
  variable-port-header:
    patterns:
      - include: "#port-direction"
      - include: "#variable-port-type"
  interface-port-header:
    patterns:
      - match: \b(interface)\b
        captures:
          "1": { name: storage.type.interface.sv }
      - include: "#dot"
      - match: (${identifier})
        captures:
          "1": { name: entity.name.type.interface.sv }
  ansi-port-declaration:
    patterns:
      - include: "#port-identifier"
      - include: "#net-port-header"
      - include: "#interface-port-header"
      - include: "#variable-port-header"
      - include: "#dimension"
      - name: meta.ansi-port-declaration.sv
        begin: (\=)\s*(?!\=)
        end: ${assignmentEnd}
        beginCaptures:
          "1": { name: keyword.operator.assignment.sv }
        patterns:
          - include: "#constant-expression"
      - include: "#comma"
  # A.1.4 Module items
  module-common-item:
    patterns:
      # Conflict: The 'generate for' and 'for' statements have the same beginning. Therefore, they are combined here:
      - name: meta.for.sv
        begin: \b(for)\b\s*(\()\s*
        end: (\))\s*|${bracketsFailSafe}
        beginCaptures:
          "1": { name: keyword.control.for.sv }
          "2": { name: punctuation.section.group.begin.sv }
        endCaptures:
          "1": { name: punctuation.section.group.end.sv }
        patterns:
          - include: "#genvar-initialization"
          - include: "#genvar-iteration"
          - include: "#genvar-expression"
          - include: "#semicolon"
          - include: "#for-initialization"
          - include: "#for-step"
          - include: "#expression"
      - include: "#module-or-generate-item-declaration"
      - include: "#interface-instantiation"
      - include: "#program-instantiation"
      - include: "#assertion-item"
      - include: "#bind-directive"
      - include: "#continuous-assign"
      - include: "#net-alias"
      - include: "#initial-construct"
      - include: "#final-construct"
      - include: "#always-construct"
      - include: "#loop-generate-construct"
      - include: "#conditional-generate-construct"
      - include: "#elaboration-system-task"
  module-item:
    patterns:
      - include: "#port-declaration"
      - include: "#non-port-module-item"
  module-or-generate-item:
    patterns:
      - include: "#attribute-instance"
      - include: "#parameter-override"
      - include: "#gate-instantiation"
      - include: "#udp-instantiation"
      - include: "#module-instantiation"
      - include: "#module-common-item"
  module-or-generate-item-declaration:
    patterns:
      - include: "#package-or-generate-item-declaration"
      - include: "#genvar-declaration"
      - include: "#clocking-declaration"
      - match: \b(default)\b\s+\b(clocking)\b\s+(${identifier})\s*\;
        captures:
          "1": { name: keyword.control.$1.sv }
          "2": { name: storage.type.$2.sv }
          "3":
            patterns:
              - include: "#clocking-identifier"
      - name: meta.default-disable.sv
        begin: \b(default)\b\s+\b(disable)\b\s+\b(iff)\b\s*
        end: (\;)\s*
        beginCaptures:
          "1": { name: keyword.control.$1.sv }
          "2": { name: keyword.control.$2.sv }
          "3": { name: keyword.control.$3.sv }
        endCaptures:
          "1": { name: punctuation.terminator.semicolon.sv }
        patterns:
          - include: "#expression-or-dist"
  non-port-module-item:
    patterns:
      - include: "#generate-region"
      - include: "#module-or-generate-item"
      - include: "#specify-block"
      - include: "#specparam-declaration"
      - include: "#program-declaration"
      - include: "#module-declaration"
      - include: "#interface-declaration"
      - include: "#timeunits-declaration"
  # A.1.6 Interface items
  interface-or-generate-item:
    patterns:
      - include: "#attribute-instance"
      - include: "#module-common-item"
      - include: "#extern-tf-declaration"
  extern-tf-declaration:
    begin: \b(extern)\b\s*(?:\b(forkjoin)\b\s+)?
    end: (\;)\s*
    beginCaptures:
      "1": { name: storage.modifier.extern.sv }
      "2": { name: storage.modifier.forkjoin.sv }
    endCaptures:
      "1": { name: punctuation.terminator.semicolon.sv }
    patterns:
      - include: "#method-prototype"
      - include: "#task-prototype"
  interface-item:
    patterns:
      - include: "#port-declaration"
      - include: "#non-port-interface-item"
  non-port-interface-item:
    patterns:
      - include: "#generate-region"
      - include: "#interface-or-generate-item"
      - include: "#program-declaration"
      - include: "#modport-declaration"
      - include: "#interface-declaration"
      - include: "#timeunits-declaration"
  # A.1.7 Program items
  program-item:
    patterns:
      - include: "#port-declaration"
      - include: "#non-port-program-item"
  non-port-program-item:
    patterns:
      - include: "#attribute-instance"
      - include: "#continuous-assign"
      - include: "#module-or-generate-item-declaration"
      - include: "#initial-construct"
      - include: "#final-construct"
      - include: "#concurrent-assertion-item"
      - include: "#timeunits-declaration"
      - include: "#program-generate-item"
  program-generate-item:
    patterns:
      - include: "#loop-generate-construct"
      - include: "#conditional-generate-construct"
      - include: "#generate-region"
      - include: "#elaboration-system-task"
  # A.1.8 Checker items
  checker-port-list:
    patterns:
      - include: "#checker-port-item"
      - include: "#comma"
  checker-port-item:
    patterns:
      - include: "#attribute-instance"
      - include: "#checker-port-direction"
      - include: "#formal-port-identifier"
      - include: "#variable-dimension"
      - begin: (\=)\s*(?!\=)
        end: ${assignmentEnd}
        beginCaptures:
          "1": { name: keyword.operator.assignment.sv }
        patterns:
          - include: "#property-actual-arg"
      - include: "#property-formal-type"
  checker-port-direction:
    patterns:
      - match: \b(input|output)\b
        captures:
          "1": { name: storage.modifier.$1.sv }
  checker-or-generate-item:
    patterns:
      - include: "#checker-or-generate-item-declaration"
      - include: "#initial-construct"
      - include: "#final-construct"
      - include: "#concurrent-assertion-item"
      - include: "#continuous-assign"
      - include: "#checker-generate-item"
  checker-or-generate-item-declaration:
    patterns:
      - match: \b(rand)\b\s*
        captures:
          "1": { name: storage.modifier.rand.sv }
      - include: "#data-declaration"
      - include: "#function-declaration"
      - include: "#checker-declaration"
      - include: "#assertion-item-declaration"
      - include: "#covergroup-declaration"
      - include: "#genvar-declaration"
      - include: "#clocking-declaration"
      - match: \b(default)\b\s*(?:\b(clocking)\b\s*)?:(?:(${identifier})\s*)?(?:(\;)\s*)?
        captures:
          "1": { name: keyword.control.default.sv }
          "2": { name: storage.type.clocking.sv }
          "3": { name: entity.name.type.sv }
          "4": { name: punctuation.terminator.semicolon.sv }
      - name: meta.default-disable.sv
        begin: \b(default)\b\s*\b(disable)\b\s*(?:\b(iff)\b\s*)?
        end: (\;)\s*
        beginCaptures:
          "1": { name: keyword.control.default.sv }
          "2": { name: keyword.control.disable.sv }
          "3": { name: keyword.control.iff.sv }
        endCaptures:
          "1": { name: punctuation.terminator.semicolon.sv }
        patterns:
          - include: "#expression-or-dist"
      - include: "#semicolon"
  checker-generate-item:
    patterns:
      - include: "#loop-generate-construct"
      - include: "#conditional-generate-construct"
      - include: "#generate-region"
      - include: "#elaboration-system-task"
  # A.1.9 Class items
  class-item:
    patterns:
      - include: "#attribute-instance"
      - include: "#class-property"
      - include: "#class-method"
      - include: "#class-constraint"
      - include: "#interface-class-declaration"
      - include: "#class-declaration"
      - include: "#covergroup-declaration"
      - include: "#local-parameter-declaration"
      - include: "#parameter-declaration"
      - include: "#semicolon"
  class-property:
    patterns:
      - include: "#property-qualifier"
      - include: "#data-declaration"
      - begin: \b(const)\b\s*
        end: (\;)\s*
        beginCaptures:
          "1": { name: storage.modifier.const.sv }
        endCaptures:
          "1": { name: punctuation.terminator.semicolon.sv }
        patterns:
          - include: "#class-item-qualifier"
          - include: "#const-identifier"
          - begin: (\=)\s*(?!\=)
            end: ${assignmentEnd}
            beginCaptures:
              "1": { name: keyword.operator.assignment.sv }
            patterns:
              - include: "#constant-expression"
          - include: "#data-type"
      - name: meta.assignments.sv
        begin: (\=)\s*(?!\=)
        end: ${assignmentEnd}
        beginCaptures:
          "1": { name: keyword.operator.assignment.sv }
        patterns:
          - include: "#expression"
          - include: "#dynamic-array-new"
          - include: "#class-new"
          - include: "#delay-or-event-control"
  class-method:
    patterns:
      - include: "#method-qualifier"
      - include: "#task-declaration"
      - include: "#function-declaration"
      - name: meta.abstract-class-function-protoype.sv
        begin: \b(pure)\b\s+\b(virtual)\b\s*
        end: (\;)\s*
        beginCaptures:
          "1": { name: storage.modifier.pure.sv }
          "2": { name: storage.modifier.virtual.sv }
        endCaptures:
          "1": { name: punctuation.terminator.semicolon.sv }
        patterns:
          - include: "#class-item-qualifier"
          - include: "#method-prototype"
      - begin: \b(extern)\b\s*(?!\s*\b(constraint)\b)
        end: (\;)\s*
        beginCaptures:
          "1": { name: storage.modifier.extern.sv }
        endCaptures:
          "1": { name: punctuation.terminator.semicolon.sv }
        patterns:
          - include: "#method-qualifier"
          - include: "#method-prototype"
          - include: "#class-constructor-prototype"
      - include: "#method-qualifier"
      - include: "#class-constructor-declaration"
  class-constructor-prototype:
    name: meta.class-constructor-protoype.sv
    begin: \b(function)\b\s+\b(new)\b\s*
    end: (\;)\s*|${blocksFailSafe}
    beginCaptures:
      "1": { name: storage.type.function.sv }
      "2": { name: entity.name.function.sv }
    endCaptures:
      "1": { name: punctuation.terminator.semicolon.sv }
    patterns:
      - begin: (\()\s*
        end: (\))\s*|${bracketsFailSafe}
        beginCaptures:
          "1": { name: punctuation.section.group.begin.sv }
        endCaptures:
          "1": { name: punctuation.section.group.end.sv }
        patterns:
          - include: "#tf-port-list"
  class-constraint:
    patterns:
      - include: "#constraint-prototype"
      - include: "#constraint-declaration"
  class-item-qualifier:
    patterns:
      - match: \b(static|protected|local)\b
        captures:
          "1": { name: storage.modifier.$1.sv }
  property-qualifier:
    patterns:
      - include: "#random-qualifier"
      - include: "#class-item-qualifier"
  random-qualifier:
    patterns:
      - match: \b(rand|randc)\b\s*
        captures:
          "1": { name: storage.modifier.$1.sv }
  method-qualifier:
    patterns:
      - match: \b(virtual)\b\s*
        captures:
          "1": { name: storage.modifier.$1.sv }
      - include: "#class-item-qualifier"
  method-prototype:
    patterns:
      - include: "#task-prototype"
      - include: "#function-prototype"
  # Move the 'super.new' pattern to function declaration
  class-constructor-declaration:
    patterns:
      - include: "#function-declaration"
  # A.1.10 Constraints
  constraint-declaration:
    name: meta.constraint-declaration.sv
    begin: (?=(?:\b(static)\b\s+)?\b(constraint)\b)
    end: (\})\s*|${bracketsFailSafe}
    beginCaptures:
      "1": { name: storage.modifier.static.sv }
      "2": { name: storage.type.constraint.sv }
    endCaptures:
      "1": { name: punctuation.section.braces.end.sv }
    patterns:
      - name: meta.constraint-declaration-header.sv
        begin: (?:\b(static)\b\s+)?\b(constraint)\b\s*
        end: (?=\{)
        beginCaptures:
          "1": { name: storage.modifier.static.sv }
          "2": { name: storage.type.constraint.sv }
        patterns:
          - include: "#constraint-identifier"
          - include: "#class-scope"
      - name: meta.constraint-declaration-body.sv
        begin: (\{)\s*
        end: (?=\})\s*
        beginCaptures:
          "1": { name: punctuation.section.braces.begin.sv }
        endCaptures:
          "1": { name: punctuation.section.braces.end.sv }
        patterns:
          - include: "#constraint-block-item"
  constraint-block-item:
    patterns:
      - begin: \b(solve)\b\s*
        end: (?=\b(before)\b)
        beginCaptures:
          "1": { name: keyword.control.solve.sv }
        patterns:
          - include: "#solve-before-list"
      - begin: \b(before)\b\s*
        end: (\;)\s*
        beginCaptures:
          "1": { name: keyword.control.before.sv }
        endCaptures:
          "1": { name: punctuation.terminator.semicolon.sv }
        patterns:
          - include: "#solve-before-list"
      - include: "#constraint-expression"
  solve-before-list:
    patterns:
      - include: "#constraint-primary"
      - include: "#comma"
  constraint-primary:
    patterns:
      - include: "#implicit-class-handle"
      - include: "#dot"
      - include: "#class-scope"
      - include: "#hierarchical-identifier"
      - include: "#dimension"
  constraint-expression:
    patterns:
      - match: (\-\>)\s*
        captures:
          "1": { name: keyword.operator.constraint.sv }
      - match: \b(soft)\b\s+
        captures:
          "1": { name: keyword.other.soft.sv }
      - include: "#expression-or-dist"
      - include: "#uniqueness-constraint"
      - include: "#semicolon"
      - include: "#expression"
      - include: "#constraint-set"
      - begin: \b(if)\b\s*(\()\s*
        end: (\))\s*|${bracketsFailSafe}
        beginCaptures:
          "1": { name: keyword.control.if.sv }
          "2": { name: punctuation.section.group.begin.sv }
        endCaptures:
          "1": { name: punctuation.section.group.end.sv }
        patterns:
          - include: "#expression"
      - match: \b(else)\b\s*
        captures:
          "1": { name: keyword.control.else.sv }
      - begin: \b(foreach)\b\s*(\()\s*
        end: (\))\s*|${bracketsFailSafe}
        beginCaptures:
          "1": { name: keyword.control.foreach.sv }
          "2": { name: punctuation.section.group.begin.sv }
        endCaptures:
          "1": { name: punctuation.section.group.end.sv }
        patterns:
          - include: "#ps-or-hierarchical-array-identifier"
          - begin: (\[)\s*
            end: (\])\s*|${bracketsFailSafe}
            beginCaptures:
              "1": { name: punctuation.section.brackets.begin.sv }
            endCaptures:
              "1": { name: punctuation.section.brackets.end.sv }
            patterns:
              - include: "#loop-variables"
      - begin: \b(disable)\b\s+\b(soft)\b\s*
        end: (\;)\s*
        beginCaptures:
          "1": { name: keyword.control.disable.sv }
          "2": { name: keyword.other.soft.sv }
        endCaptures:
          "1": { name: punctuation.terminator.semicolon.sv }
        patterns:
          - include: "#constraint-primary"
  uniqueness-constraint:
    patterns:
      - begin: \b(unique)\b\s*(\{)\s*
        end: (\})\s*|${bracketsFailSafe}
        beginCaptures:
          "1": { name: keyword.other.unique.sv }
          "2": { name: punctuation.section.braces.begin.sv }
        endCaptures:
          "1": { name: punctuation.section.braces.end.sv }
        patterns:
          - include: "#open-range-list"
          - include: "#expression"
  constraint-set:
    patterns:
      - begin: (\{)\s*
        end: (\})\s*|${bracketsFailSafe}
        beginCaptures:
          "1": { name: punctuation.section.braces.begin.sv }
        endCaptures:
          "1": { name: punctuation.section.braces.end.sv }
        patterns:
          - include: "#constraint-expression"
  dist-list:
    patterns:
      - include: "#dist-item"
      - include: "#comma"
  dist-item:
    patterns:
      - include: "#value-range"
      - include: "#dist-weight"
      - include: "#expression"
  dist-weight:
    begin: (\:\=|\:\/)\s*
    end: (?=\,|\})
    beginCaptures:
      "1": { name: keyword.operator.dist.sv }
    patterns:
      - include: "#expression"
  constraint-prototype:
    name: meta.constraint-prototype.sv
    match: (?:\b(extern|pure)\b\s+)?(?:\b(static)\b\s+)?\b(constraint)\b\s+(${identifier})\s*(\;)\s*
    captures:
      "1": { name: storage.modifier.$1.sv }
      "2": { name: storage.modifier.$2.sv }
      "3": { name: storage.type.$3.sv }
      "4": { name: variable.other.sv }
      "5": { name: punctuation.terminator.semicolon.sv }
  constraint-prototype-qualifier:
    patterns:
      - match: \b(extern|pure)\b\s+
        captures:
          "1": { name: storage.modifier.$1.sv }
  identifier-list:
    patterns:
      - include: "#identifier"
      - include: "#comma"
  # A.1.11 Package items
  package-item:
    patterns:
      - include: "#package-or-generate-item-declaration"
      - include: "#anonymous-program"
      - include: "#package-export-declaration"
      - include: "#timeunits-declaration"
  package-or-generate-item-declaration:
    patterns:
      # This section handles assignments for both nets and data.
      # The assignment logic has been moved here for better organization.
      - name: meta.assignments.sv
        begin: (\=)\s*(?!\=)
        end: ${assignmentEnd}
        beginCaptures:
          "1": { name: keyword.operator.assignment.sv }
        patterns:
          - include: "#expression"
          - include: "#dynamic-array-new"
          - include: "#class-new"
          - include: "#delay-or-event-control"
      - include: "#net-declaration"
      - include: "#data-declaration"
      - include: "#task-declaration"
      - include: "#function-declaration"
      - include: "#checker-declaration"
      - include: "#dpi-import-export"
      - include: "#extern-constraint-declaration"
      - include: "#interface-class-declaration"
      - include: "#class-declaration"
      - include: "#class-constructor-declaration"
      - include: "#local-parameter-declaration"
      - include: "#parameter-declaration"
      - include: "#covergroup-declaration"
      - include: "#assertion-item-declaration"
      - include: "#semicolon"
  anonymous-program:
    name: meta.anonymous-program.sv
    begin: \b(program)\b\s*
    end: \b(endprogram)\b\s*
    beginCaptures:
      "1": { name: storage.type.$1.sv }
    endCaptures:
      "1": { name: storage.type.$1.sv }
    patterns:
      - include: "#semicolon"
      - include: "#anonymous-program-item"
  anonymous-program-item:
    patterns:
      - include: "#task-declaration"
      - include: "#function-declaration"
      - include: "#interface-class-declaration"
      - include: "#class-declaration"
      - include: "#covergroup-declaration"
      - include: "#class-constructor-declaration"
      - include: "#semicolon"
  # A.2 Declarations
  # A.2.1 Declaration types
  # A.2.1.1 Module parameter declarations
  local-parameter-declaration:
    patterns:
      - name: meta.local-parameter-declaration.sv
        begin: \b(localparam)\b\s+\b(type)\b\s*
        end: (?=[,);])|${itemsFailSafe}
        beginCaptures:
          "1": { name: storage.modifier.localparam.sv }
          "2": { name: storage.modifier.type.sv }
        endCaptures:
          "1": { name: punctuation.terminator.semicolon.sv }
        patterns:
          - include: "#list-of-type-assignments"
      - name: meta.local-parameter-declaration.sv
        begin: \b(localparam)\b\s*
        end: (?=[,);])|${itemsFailSafe}
        beginCaptures:
          "1": { name: storage.modifier.localparam.sv }
        endCaptures:
          "1": { name: punctuation.terminator.semicolon.sv }
        patterns:
          - include: "#list-of-param-assignments"
          - include: "#data-type-or-implicit"
  parameter-declaration:
    patterns:
      - name: meta.parameter-declaration.sv
        begin: \b(parameter)\b\s+\b(type)\b\s*
        end: (?=[,);])|${itemsFailSafe}
        beginCaptures:
          "1": { name: storage.modifier.parameter.sv }
          "2": { name: storage.modifier.type.sv }
        endCaptures:
          "1": { name: punctuation.terminator.semicolon.sv }
        patterns:
          - include: "#list-of-type-assignments"
      - name: meta.parameter-declaration.sv
        begin: \b(parameter)\b\s*
        end: (?=[,);])|${itemsFailSafe}
        beginCaptures:
          "1": { name: storage.modifier.parameter.sv }
        endCaptures:
          "1": { name: punctuation.terminator.semicolon.sv }
        patterns:
          - include: "#list-of-param-assignments"
          - include: "#data-type-or-implicit"
  specparam-declaration:
    name: meta.specparam-declaration.sv
    begin: \b(specparam)\b\s*
    end: (\;)\s*|${itemsFailSafe}
    beginCaptures:
      "1": { name: storage.modifier.specparam.sv }
    endCaptures:
      "1": { name: punctuation.terminator.semicolon.sv }
    patterns:
      - include: "#packed-dimension"
      - include: "#list-of-specparam-assignments"
  # A.2.1.2 Port declarations
  inout-declaration:
    patterns:
      - match: \b(inout)\b\s*
        captures:
          "1": { name: storage.modifier.$1.sv }
      - include: "#list-of-port-identifiers"
      - include: "#net-port-type"
  input-declaration:
    patterns:
      - match: \b(input)\b\s*
        captures:
          "1": { name: storage.modifier.$1.sv }
      - include: "#net-port-type"
      - include: "#list-of-port-identifiers"
      - include: "#list-of-variable-identifiers"
      - include: "#variable-port-type"
  output-declaration:
    patterns:
      - match: \b(output)\b\s*
        captures:
          "1": { name: storage.modifier.$1.sv }
      - include: "#net-port-type"
      - include: "#list-of-port-identifiers"
      - include: "#list-of-variable-identifiers"
      - include: "#variable-port-type"
  interface-port-declaration:
    patterns:
      - include: "#interface-identifier"
      - include: "#list-of-interface-identifiers"
      - include: "#modport-identifier"
      - include: "#dot"
  ref-declaration:
    patterns:
      - match: \b(ref)\b\s*
        captures:
          "1": { name: storage.modifier.$1.sv }
      - include: "#list-of-variable-identifiers"
      - include: "#variable-port-type"
  # A.2.1.3 Type declarations
  data-declaration:
    patterns:
      - match: \b(const)\b\s*
        captures:
          "1": { name: storage.modifier.const.sv }
      - match: \b(var)\b\s*
        captures:
          "1": { name: storage.modifier.var.sv }
      - include: "#lifetime"
      - include: "#list-of-variable-decl-assignments"
      - include: "#semicolon"
      - include: "#type-declaration"
      - include: "#package-import-declaration"
      - include: "#net-type-declaration"
      - include: "#data-type-or-implicit"
  package-import-declaration:
    name: meta.package-import-declaration.sv
    begin: \b(import)\b\s*
    end: (\;)\s*|${itemsFailSafe}
    beginCaptures:
      "1": { name: keyword.control.import.sv }
    endCaptures:
      "1": { name: punctuation.terminator.semicolon.sv }
    patterns:
      - include: "#package-import-item"
      - include: "#comma"
  package-import-item:
    patterns:
      - match: (${identifier})\s*(?:(\:\:)\s*)?(?:(${identifier})\s*)?
        captures:
          "1": { name: entity.name.namespace.sv }
          "2": { name: punctuation.separator.scope-resolution.sv }
          # This section handles declarations that could be parameters, functions/tasks, data types, or classes.
          # Unfortunately, without semantic analysis, it's not possible to distinguish between them accurately.
          # In this extension, we use naming conventions to make educated guesses:
          # - If the identifier starts with a capital letter, it's likely a parameter.
          # - If the identifier starts with "t_" or "e_" or ends with "_t" or "_e", it's likely a data type.
          # - Otherwise, it's likely a function/task.
          "3":
            patterns:
              - match: \b([A-Z][a-zA-Z0-9_$]*)\b\s*
                captures:
                  "1": { name: variable.other.constant.sv }
              - match: \b(t_[a-zA-Z0-9_]*|e_[a-zA-Z0-9_]*|.*_t|.*_e)\b\s*
                captures:
                  "1": { name: entity.name.type.sv }
              - match: \b(${functionIdentifier})\b\s*
                captures:
                  "1": { name: entity.name.function.sv }
      - match: (${identifier})\s*(\:\:)\s*(\*)\s*
        captures:
          "1": { name: entity.name.namespace.sv }
          "2": { name: punctuation.separator.scope-resolution.sv }
          "3": { name: keyword.operator.wildcard.sv }
  package-export-declaration:
    begin: \b(export)\b\s*
    end: (\;)\s*
    beginCaptures:
      "1": { name: keyword.control.export.sv }
    endCaptures:
      "1": { name: punctuation.terminator.semicolon.sv }
    patterns:
      - match: \b(\*)\s*(\:\:)\s*(\*)\s*
        captures:
          "1": { name: keyword.operator.wildcard.sv }
          "2": { name: punctuation.separator.scope-resolution.sv }
          "3": { name: keyword.operator.wildcard.sv }
      - include: "#package-import-item"
      - include: "#comma"
  genvar-declaration:
    name: meta.genvar-declaration.sv
    begin: \b(genvar)\b\s*
    end: (\;)\s*
    beginCaptures:
      "1": { name: storage.modifier.genvar.sv }
    endCaptures:
      "1": { name: punctuation.terminator.semicolon.sv }
    patterns:
      - include: "#list-of-genvar-identifiers"
  net-declaration:
    patterns:
      - match: \b(interconnect)\b\s*
        captures:
          "1": { name: entity.name.type.$1.sv }
      - include: "#net-type"
      - include: "#drive-strength"
      - include: "#charge-strength"
      - match: \b(vectored|scalared)\b\s*
        captures:
          "1": { name: storage.modifier.$1.sv }
      - include: "#list-of-net-decl-assignments"
      - include: "#delay3"
      - include: "#data-type-or-implicit"
  type-declaration:
    name: meta.type-declaration.sv
    begin: \b(typedef)\b\s*
    end: (;)\s*|${itemsFailSafe}
    beginCaptures:
      "1": { name: keyword.control.typedef.sv }
    endCaptures:
      "1": { name: punctuation.terminator.semicolon.sv }
    patterns:
      - include: "#type-identifier"
      - include: "#variable-dimension"
      - include: "#semicolon"
      - include: "#interface-instance-identifier"
      - include: "#constant-bit-select"
      - include: "#dot"
      - match: \b(enum|struct|union|class)\b\s*(?=${identifier})
        captures:
          "1": { name: storage.type.$1.sv }
      - match: \b(interface)\b\s+\b(class)\b\s*(?=${identifier})
        captures:
          "1": { name: storage.type.$1.sv }
          "2": { name: storage.type.$2.sv }
      - include: "#data-type"
  net-type-declaration:
    name: meta.net-type-declaration.sv
    begin: \b(nettype)\b\s*
    beginCaptures:
      "1": { name: keyword.control.nettype.sv }
    end: \;
    endCaptures:
      "0": { name: punctuation.terminator.semicolon.sv }
    patterns:
      - name: meta.net-type-declaration-with.sv
        begin: \b(with)\b\s*
        beginCaptures:
          "1": { name: keyword.control.with.sv }
        end: (?=\;)
        patterns:
          - include: "#tf-identifier"
          - include: "#package-scope"
          - include: "#class-scope"
      - include: "#net-type-identifier"
      - include: "#data-type"
  lifetime:
    patterns:
      - match: \b(static|automatic)\b\s*
        captures:
          "1": { name: storage.modifier.$1.sv }
  # A.2.2 Declaration data types
  cast-type:
    patterns:
      - include: "#simple-type"
      - include: "#constant-primary"
      - include: "#signing"
      - match: \b(string)\b\s*
        captures:
          "1": { name: entity.name.type.$1.sv }
      - match: \b(const)\b\s*
        captures:
          "1": { name: storage.modifier.$1.sv }
  data-type:
    patterns:
      - include: "#signing"
      - include: "#dimension"
      - include: "#integer-vector-type"
      - include: "#integer-atom-type"
      - include: "#non-integer-type"
      - begin: (?=\b(union)\b\s*\b(tagged)\b)
        end: (\})\s*|${bracketsFailSafe}
        name: meta.union-tagged.sv
        endCaptures:
          "1": { name: punctuation.section.braces.end.sv }
        patterns:
          - name: meta.union-tagged-header.sv
            begin: \b(union)\b\s*\b(tagged)\b\s*
            end: (?=\{)|${bracketsFailSafe}
            beginCaptures:
              "1": { name: storage.type.union.sv }
              "2": { name: storage.modifier.tagged.sv }
            patterns:
              - match: \b(packed)\b\s*
                captures:
                  "1": { name: storage.modifier.packed.sv }
              - include: "#signing"
          - name: meta.union-tagged-body.sv
            begin: (\{)\s*
            end: (?=\})|${bracketsFailSafe}
            beginCaptures:
              "1": { name: punctuation.section.braces.begin.sv }
            patterns:
              - include: "#tagged-union-member"
      - begin: (?=\b(struct|union)\b)
        end: (\})\s*|${bracketsFailSafe}
        name: meta.struct.sv
        endCaptures:
          "1": { name: punctuation.section.braces.end.sv }
        patterns:
          - name: meta.struct-header.sv
            begin: \b(struct|union)\b\s*(?:\b(tagged)\b\s*)?
            end: (?=\{)|${bracketsFailSafe}
            beginCaptures:
              "1": { name: storage.type.$1.sv }
              "2": { name: storage.modifier.tagged.sv }
            patterns:
              - match: \b(packed)\b\s*
                captures:
                  "1": { name: storage.modifier.packed.sv }
              - include: "#signing"
          - name: meta.struct-body.sv
            begin: (\{)\s*
            end: (?=\})|${bracketsFailSafe}
            beginCaptures:
              "1": { name: punctuation.section.braces.begin.sv }
            patterns:
              - include: "#struct-union-member"
      - begin: (?=\benum\b)
        end: (\})\s*|${bracketsFailSafe}
        name: meta.enum.sv
        endCaptures:
          "1": { name: punctuation.section.braces.end.sv }
        patterns:
          - name: meta.enum-header.sv
            begin: \b(enum)\b\s*
            end: (?=\{)|${bracketsFailSafe}
            beginCaptures:
              "1": { name: storage.type.enum.sv }
            patterns:
              - include: "#enum-base-type"
          # enum to beginning of '{'
          # '{' to beginning of '}'
          - name: meta.enum-body.sv
            begin: (\{)\s*
            end: (?=\})|${bracketsFailSafe}
            beginCaptures:
              "1": { name: punctuation.section.braces.begin.sv }
            patterns:
              - include: "#enum-name-declaration"
              - include: "#comma"
      - match: \b(string)\b\s*
        captures:
          "1": { name: entity.name.type.$1.sv }
      - match: \b(chandle)\b\s*
        captures:
          "1": { name: entity.name.type.$1.sv }
      - match: \b(virtual)\b\s*(?:\b(interface)\b\s*)?(${identifier})\s*
        captures:
          "1": { name: storage.modifier.virtual.sv }
          "2": { name: storage.type.interface.sv }
          "3": { name: entity.name.type.sv }
      - include: "#parameter-value-assignment"
      - include: "#dot"
      - include: "#type-identifier"
      - include: "#class-scope"
      - include: "#package-scope"
      - include: "#class-type"
      - match: \b(event)\b\s*
        captures:
          "1": { name: entity.name.type.$1.sv }
      - include: "#ps-covergroup-identifier"
      - include: "#type-reference"
  data-type-or-implicit:
    patterns:
      - include: "#data-type"
      - include: "#implicit-data-type"
  implicit-data-type:
    patterns:
      - include: "#signing"
      - include: "#dimension"
  enum-base-type:
    patterns:
      - include: "#integer-atom-type"
      - include: "#integer-vector-type"
      - include: "#signing"
      - include: "#dimension"
      - include: "#type-identifier"
  enum-name-declaration:
    begin: (${identifier})
    end: (?=\,|\})
    beginCaptures:
      "1": { name: variable.other.enummember.sv }
    patterns:
      - name: meta.enum-range.sv
        begin: (\[)\s*
        end: (\])\s*|${bracketsFailSafe}
        beginCaptures:
          "1": { name: punctuation.section.brackets.begin.sv }
        endCaptures:
          "1": { name: punctuation.section.brackets.end.sv }
        patterns:
          - include: "#integral-number"
          - include: "#colon"
      - name: meta.enum-assignment.sv
        begin: (\=)\s*(?!\=)
        end: (?=\,|\})
        beginCaptures:
          "1": { name: keyword.operator.assignment.sv }
        patterns:
          - include: "#constant-expression"
  class-scope:
    patterns:
      - include: "#package-scope"
      - match: (${identifier})\s*(\#\s*\(.*?\)\s*)?(::)\s*
        name: meta.class-scope.sv
        captures:
          "1": { name: entity.name.type.sv }
          "2":
            patterns:
              - include: "#parameter-value-assignment"
          "3": { name: punctuation.separator.scope-resolution.sv }
  class-type:
    patterns:
      - include: "#parameter-value-assignment"
      - include: "#ps-class-identifier"
  integer-type:
    patterns:
      - include: "#integer-atom-type"
      - include: "#integer-vector-type"
  integer-atom-type:
    match: \b(byte|shortint|int|longint|integer|time)\b\s*
    captures:
      "1": { name: entity.name.type.$1.sv }
  integer-vector-type:
    match: \b(bit|logic|reg)\b\s*
    captures:
      "1": { name: entity.name.type.$1.sv }
  non-integer-type:
    match: \b(shortreal|real|realtime)\b\s*
    captures:
      "1": { name: entity.name.type.$1.sv }
  net-type:
    match: \b(supply0|supply1|tri|triand|trior|trireg|tri0|tri1|uwire|wire|wand|wor)\b\s*
    captures:
      "1": { name: entity.name.type.$1.sv }
  net-port-type:
    patterns:
      - match: \b(interconnect)\b\s*
        captures:
          "1": { name: entity.name.type.$1.sv }
      - include: "#net-type"
      - include: "#net-type-identifier"
      - include: "#implicit-data-type"
      - include: "#data-type-or-implicit"
  variable-port-type:
    patterns:
      - include: "#var-data-type"
  var-data-type:
    patterns:
      - match: \b(var)\b\s*
        captures:
          "1": { name: storage.modifier.var.sv }
      - include: "#data-type"
      - include: "#data-type-or-implicit"
  signing:
    match: \b(signed|unsigned)\b\s*
    captures:
      "1": { name: storage.modifier.$1.sv }
  simple-type:
    patterns:
      - include: "#integer-type"
      - include: "#non-integer-type"
      - include: "#ps-type-identifier"
      - include: "#ps-parameter-identifier"
  struct-union-member:
    patterns:
      - begin: (\=)\s*(?!\=)
        end: ${assignmentEnd}
        beginCaptures:
          "1": { name: keyword.operator.assignment.sv }
        patterns:
          - include: "#expression"
      - include: "#attribute-instance"
      - include: "#random-qualifier"
      - include: "#list-of-variable-decl-assignments"
      - include: "#semicolon"
      - include: "#data-type-or-void"
  tagged-union-member:
    patterns:
      - begin: (\=)\s*(?!\=)
        end: ${assignmentEnd}
        beginCaptures:
          "1": { name: keyword.operator.assignment.sv }
        patterns:
          - include: "#expression"
      - include: "#attribute-instance"
      - include: "#random-qualifier"
      - include: "#list-of-tagged-variable-decl-assignments"
      - include: "#semicolon"
      - include: "#data-type-or-void"
  data-type-or-void:
    patterns:
      - match: \b(void)\b\s*
        captures:
          "1": { name: entity.name.type.$1.sv }
      - include: "#data-type"
  struct-union:
    patterns:
      - match: \b(struct)\b\s*
        captures:
          "1": { name: storage.type.$1.sv }
      - match: \b(union)\b\s+\b(tagged)\b\s*
        captures:
          "1": { name: storage.type.$1.sv }
          "2": { name: storage.modifier.$2.sv }
      - match: \b(union)\b\s*
        captures:
          "1": { name: storage.type.$1.sv }
  type-reference:
    name: meta.type-reference.sv
    begin: \b(type)\b\s*(\()\s*
    end: (\))\s*|${bracketsFailSafe}
    beginCaptures:
      "1": { name: entity.name.function.$1.sv }
      "2": { name: punctuation.section.group.begin.sv }
    endCaptures:
      "1": { name: punctuation.section.group.end.sv }
    patterns:
      - include: "#expression"
      - include: "#data-type"
  # A.2.2.2 Strengths
  drive-strength:
    name: meta.drive-strength.sv
    match: (\()\s*(supply0|strong0|pull0|weak0|supply1|strong1|pull1|weak1|highz0|highz1)\s*(\,)\s*(supply0|strong0|pull0|weak0|supply1|strong1|pull1|weak1|highz0|highz1)\s*(\))
    captures:
      "1": { name: punctuation.section.group.begin.sv }
      "2": { name: storage.modifier.$2.sv }
      "3": { name: punctuation.separator.comma.sv }
      "4": { name: storage.modifier.$4.sv }
      "5": { name: punctuation.section.group.end.sv }
  strength0:
    match: \b(supply0|strong0|pull0|weak0)\b
    name: storage.modifier.$1.sv
  strength1:
    match: \b(supply1|strong1|pull1|weak1)\b
    name: storage.modifier.$1.sv
  charge-strength:
    match: (\()\s*\b(small|medium|large)\b\s*(\))
    captures:
      "1": { name: punctuation.section.group.begin.sv }
      "2": { name: storage.modifier.$2.sv }
      "3": { name: punctuation.section.group.end.sv }
  # A.2.2.3 Delays
  delay3:
    patterns:
      - name: meta.delay3.sv
        begin: (\#)\s*(\()\s*
        end: (\))\s*|${bracketsFailSafe}
        beginCaptures:
          "1": { name: punctuation.definition.delay.sv }
          "2": { name: punctuation.section.group.begin.sv }
        endCaptures:
          "1": { name: punctuation.section.group.end.sv }
        patterns:
          - include: "#comma"
          - include: "#mintypmax-expression"
      - match: (\#)\s*(${identifier})\s*
        captures:
          "1": { name: punctuation.definition.delay.sv }
          "2": { name: variable.other.sv }
      - match: (\#)\s*
        captures:
          "1": { name: punctuation.definition.delay.sv }
      - include: "#delay-value"
  delay2:
    patterns:
      - name: meta.delay2.sv
        begin: (\#)\s*(\()\s*
        end: (\))\s*|${bracketsFailSafe}
        beginCaptures:
          "1": { name: punctuation.definition.delay.sv }
          "2": { name: punctuation.section.group.begin.sv }
        endCaptures:
          "1": { name: punctuation.section.group.end.sv }
        patterns:
          - include: "#comma"
          - include: "#mintypmax-expression"
      - match: (\#)\s*(${identifier})\s*
        captures:
          "1": { name: punctuation.definition.delay.sv }
          "2": { name: variable.other.sv }
      - match: (\#)\s*
        captures:
          "1": { name: punctuation.definition.delay.sv }
      - include: "#delay-value"
  delay-value:
    patterns:
      - match: \b(1step)\b\s*
        captures:
          "1": { name: constant.numeric.$1.sv }
      - include: "#unsigned-number"
      - include: "#real-number"
      - include: "#ps-identifier"
      - include: "#time-literal"
  # A.2.3 Declaration lists
  list-of-defparam-assignments:
    patterns:
      - include: "#comma"
      - include: "#defparam-assignment"
  list-of-genvar-identifiers:
    patterns:
      - include: "#comma"
      - include: "#genvar-identifier"
  list-of-interface-identifiers:
    patterns:
      - include: "#comma"
      - include: "#dimension"
      - include: "#interface-identifier"
  list-of-net-decl-assignments:
    patterns:
      - include: "#comma"
      - include: "#net-decl-assignment"
  list-of-param-assignments:
    patterns:
      - include: "#comma"
      - include: "#param-assignment"
  list-of-port-identifiers:
    patterns:
      - include: "#comma"
      - include: "#dimension"
      - include: "#port-identifier"
  list-of-udp-port-identifiers:
    patterns:
      - include: "#comma"
      - include: "#port-identifier"
  list-of-specparam-assignments:
    patterns:
      - include: "#comma"
      - include: "#specparam-assignment"
  list-of-tf-variable-identifiers:
    patterns:
      - include: "#comma"
      - include: "#variable-identifier"
      - include: "#dimension"
  list-of-type-assignments:
    patterns:
      - include: "#comma"
      - include: "#type-assignment"
  list-of-variable-decl-assignments:
    patterns:
      - include: "#comma"
      - include: "#variable-decl-assignment"
  list-of-tagged-variable-decl-assignments:
    patterns:
      - include: "#comma"
      - include: "#tagged-variable-decl-assignment"
  list-of-variable-identifiers:
    patterns:
      - include: "#comma"
      - include: "#variable-identifier"
      - include: "#variable-dimension"
  list-of-variable-port-identifiers:
    patterns:
      - include: "#comma"
      - include: "#variable-identifier"
      - include: "#variable-dimension"
      - name: meta.variable-port-identifier.sv
        begin: (\=)\s*(?!\=)
        end: ${assignmentEnd}
        beginCaptures:
          "1": { name: keyword.operator.assignment.sv }
        patterns:
          - include: "#constant-expression"
  # A.2.4 Declaration assignments
  defparam-assignment:
    patterns:
      - name: meta.defparam-assignment.sv
        begin: (\=)\s*(?!\=)
        end: ${assignmentEnd}
        beginCaptures:
          "1": { name: keyword.operator.assignment.sv }
        patterns:
          - include: "#constant-mintypmax-expression"
      - include: "#hierarchical-parameter-identifier"
  net-decl-assignment:
    patterns:
      - include: "#net-identifier"
      - include: "#dimension"
  param-assignment:
    patterns:
      - name: meta.param-assignment.sv
        begin: (\=)\s*(?!\=)
        end: ${assignmentEnd}
        beginCaptures:
          "1": { name: keyword.operator.assignment.sv }
        patterns:
          - include: "#constant-param-expression"
      - include: "#parameter-identifier"
      - include: "#dimension"
  specparam-assignment:
    patterns:
      - name: meta.specparam-assignment.sv
        begin: (\=)\s*(?!\=)
        end: ${assignmentEnd}
        beginCaptures:
          "1": { name: keyword.operator.assignment.sv }
        patterns:
          - include: "#constant-mintypmax-expression"
      - include: "#specparam-identifier"
      - include: "#pulse-control-specparam"
  type-assignment:
    patterns:
      - name: meta.type-assignment.sv
        begin: (\=)\s*(?!\=)
        end: ${assignmentEnd}
        beginCaptures:
          "1": { name: keyword.operator.assignment.sv }
        patterns:
          - include: "#data-type"
      - match: (${identifier})\s*
        captures:
          "1": { name: entity.name.type.sv }
  # pulse_control_specparam: too complicated, not implemented
  error-limit-value:
    patterns:
      - include: "#limit-value"
  reject-limit-value:
    patterns:
      - include: "#limit-value"
  limit-value:
    patterns:
      - include: "#constant-mintypmax-expression"
  variable-decl-assignment:
    patterns:
      - include: "#dimension"
      - match: (${identifier})\s*(?=\=|\,|\;|(\[[^\[\]]*?\]\s*(\=|\,|\;)))
        captures:
          "1": { name: variable.other.sv }
  tagged-variable-decl-assignment:
    patterns:
      - include: "#dimension"
      - match: (${identifier})\s*(?=\=|\,|\;|(\[[^\[\]]*?\]\s*(\=|\,|\;)))
        captures:
          "1": { name: variable.other.constant.sv }
  class-new:
    patterns:
      - include: "#class-scope"
      - match: \b(new)\b\s*
        captures:
          "1": { name: entity.name.function.sv }
      - name: meta.class-new.sv
        begin: (\()\s*
        end: (\))\s*|${bracketsFailSafe}
        beginCaptures:
          "1": { name: punctuation.section.group.begin.sv }
        endCaptures:
          "1": { name: punctuation.section.group.end.sv }
        patterns:
          - include: "#list-of-arguments"
      - include: "#expression"
  dynamic-array-new:
    patterns:
      - match: \b(new)\b\s*
        captures:
          "1": { name: entity.name.function.sv }
      - include: "#dimension"
  # A.2.5 Declaration ranges
  dimension:
    name: meta.dimension.sv
    begin: (\[)\s*
    beginCaptures:
      "1": { name: punctuation.section.brackets.begin.sv }
    end: (\])\s*|${bracketsFailSafe}
    endCaptures:
      "1": { name: punctuation.section.brackets.end.sv }
    patterns:
      - match: (\*)\s*
        captures:
          "1": { name: keyword.operator.wildcard.sv }
      - match: (\$)\s*(?!\w)
        captures:
          "1": { name: constant.numeric.dollar.sv }
      - include: "#constant-range-expression"
      - include: "#constant-range"
      - include: "#constant-expression"
      - include: "#data-type"
  # A.2.6 Function declarations
  function-data-type-or-implicit:
    patterns:
      - include: "#data-type-or-void"
      - include: "#implicit-data-type"
  function-declaration:
    name: meta.function-declaration.sv
    begin: (?=\b(function)\b\s*)
    end: \b(endfunction)\b\s*(?:(\:)\s*(${identifier})\s*)?|${blocksFailSafe}
    endCaptures:
      "1": { name: storage.type.function.sv }
      "2": { name: punctuation.separator.colon.sv }
      "3": { name: entity.name.function.sv }
    patterns:
      - name: meta.function-declaration-header.sv
        begin: \b(function)\b\s*|${blocksFailSafe}
        end: (?=\;)|${blocksFailSafe}
        beginCaptures:
          "1": { name: storage.type.$1.sv }
        patterns:
          - include: "#lifetime"
          # In class, the function name can be 'new'
          - match: \b(new)\b\s*
            captures:
              "1": { name: entity.name.function.sv }
          - include: "#function-identifier"
          - include: "#interface-identifier"
          - include: "#class-scope"
          - begin: (\()\s*
            end: (\))\s*|${bracketsFailSafe}
            beginCaptures:
              "1": { name: punctuation.section.group.begin.sv }
            endCaptures:
              "1": { name: punctuation.section.group.end.sv }
            patterns:
              - include: "#tf-port-list"
          - include: "#function-data-type-or-implicit"
      - name: meta.function-declaration-body.sv
        begin: (?<=\;\s*)
        end: (?=\b(endfunction)\b\s*)|${blocksFailSafe}
        patterns:
          # super.new is copied from class constructor declaration
          - begin: \b(super)\b\s*(\.)\s*\b(new)\b\s*
            end: (\;)\s*
            beginCaptures:
              "1": { name: variable.language.super.sv }
              "2": { name: punctuation.accessor.dot.sv }
              "3": { name: entity.name.function.sv }
            endCaptures:
              "1": { name: punctuation.terminator.semicolon.sv }
            patterns:
              - begin: (\()\s*
                end: (\))\s*|${bracketsFailSafe}
                beginCaptures:
                  "1": { name: punctuation.section.group.begin.sv }
                endCaptures:
                  "1": { name: punctuation.section.group.end.sv }
                patterns:
                  - include: "#list-of-arguments"
          - include: "#tf-item-declaration"
          - include: "#block-item-declaration"
          - include: "#function-statement-or-null"
  function-prototype:
    begin: \b(function)\b\s*
    end: (?=\;|\)|\{)
    beginCaptures:
      "1": { name: storage.type.$1.sv }
    patterns:
      - include: "#function-data-type-or-implicit"
      - include: "#function-identifier"
      - begin: (\()\s*
        end: (\))\s*|${bracketsFailSafe}
        beginCaptures:
          "1": { name: punctuation.section.group.begin.sv }
        endCaptures:
          "1": { name: punctuation.section.group.end.sv }
        patterns:
          - include: "#tf-port-list"
  dpi-import-export:
    begin: \b(import|export)\b\s*
    end: (\;)\s*
    beginCaptures:
      "1": { name: keyword.control.$1.sv }
    endCaptures:
      "1": { name: punctuation.terminator.semicolon.sv }
    patterns:
      - include: "#dpi-spec-string"
      - include: "#dpi-function-import-property"
      - include: "#dpi-task-import-property"
      - include: "#c-identifier"
      - include: "#dpi-function-proto"
      - include: "#dpi-task-proto"
      - include: "#function-identifier"
      - include: "#task-identifier"
  dpi-spec-string:
    patterns:
      - include: "#string"
  dpi-function-import-property:
    patterns:
      - match: \b(context|pure)\b\s*
        captures:
          "1": { name: storage.modifier.$1.sv }
  dpi-task-import-property:
    patterns:
      - match: \b(context)\b\s*
        captures:
          "1": { name: storage.modifier.$1.sv }
  dpi-function-proto:
    patterns:
      - include: "#function-prototype"
  dpi-task-proto:
    patterns:
      - include: "#task-prototype"
  # A.2.7 Task declarations
  task-declaration:
    name: meta.task-declaration.sv
    begin: (?=\b(task)\b\s*)
    end: \b(endtask)\b\s*(?:(\:)\s*(${identifier})\s*)?|${blocksFailSafe}
    endCaptures:
      "1": { name: storage.type.task.sv }
      "2": { name: punctuation.separator.colon.sv }
      "3": { name: entity.name.function.sv }
    patterns:
      - name: meta.task-declaration-header.sv
        begin: \b(task)\b\s*
        end: (?=\;)|${blocksFailSafe}
        beginCaptures:
          "1": { name: storage.type.$1.sv }
        patterns:
          - include: "#lifetime"
          - include: "#task-identifier"
          - include: "#interface-identifier"
          - include: "#class-scope"
          - begin: (\()\s*
            end: (\))\s*|${bracketsFailSafe}
            beginCaptures:
              "1": { name: punctuation.section.group.begin.sv }
            endCaptures:
              "1": { name: punctuation.section.group.end.sv }
            patterns:
              - include: "#tf-port-list"
      - name: meta.task-declaration-body.sv
        begin: (\;)\s*
        end: (?=\b(endtask)\b\s*)|${blocksFailSafe}
        beginCaptures:
          "1": { name: punctuation.terminator.semicolon.sv }
        patterns:
          - include: "#statement-or-null"
          - include: "#tf-item-declaration"
          - include: "#block-item-declaration"
  tf-item-declaration:
    patterns:
      - include: "#block-item-declaration"
      - include: "#tf-port-declaration"
  tf-port-list:
    patterns:
      - include: "#comma"
      - include: "#tf-port-item"
  tf-port-item:
    patterns:
      - include: "#attribute-instance"
      - match: \b(var)\b\s*
        captures:
          "1": { name: storage.modifier.var.sv }
      - include: "#tf-port-direction"
      - include: "#port-identifier"
      - include: "#variable-dimension"
      - begin: (\=)\s*(?!\=)
        end: (?=\,|\))
        beginCaptures:
          "1": { name: keyword.operator.assignment.sv }
        patterns:
          - include: "#expression"
      - include: "#data-type-or-implicit"
  tf-port-direction:
    patterns:
      - match: \b(const)\b\s*
        captures:
          "1": { name: storage.modifier.$1.sv }
      - match: \b(ref)\b\s*
        captures:
          "1": { name: storage.modifier.$1.sv }
      - include: "#port-direction"
  tf-port-declaration:
    patterns:
      - include: "#attribute-instance"
      - include: "#tf-port-direction"
      - match: \b(var)\b\s*
        captures:
          "1": { name: storage.modifier.var.sv }
      - include: "#list-of-tf-variable-identifiers"
      - include: "#data-type-or-implicit"
      - include: "#semicolon"
  task-prototype:
    begin: \b(task)\b\s*
    end: (?=\;|\)|\{)
    beginCaptures:
      "1": { name: storage.type.$1.sv }
    patterns:
      - include: "#task-identifier"
      - begin: (\()\s*
        end: (\))\s*|${bracketsFailSafe}
        beginCaptures:
          "1": { name: punctuation.section.group.begin.sv }
        endCaptures:
          "1": { name: punctuation.section.group.end.sv }
        patterns:
          - include: "#tf-port-list"
  # A.2.8 Block item declarations
  block-item-declaration:
    patterns:
      - include: "#attribute-instance"
      - include: "#data-declaration"
      - include: "#local-parameter-declaration"
      - include: "#parameter-declaration"
      - include: "#let-declaration"
  # A.2.10 Assertion declarations
  concurrent-assimilation-item:
    patterns:
      - match: (${identifier})\s*(\:\s*)?
        captures:
          "1": { name: variable.other.block.sv }
          "2": { name: punctuation.separator.colon.sv }
      - include: "#concurrent-assertion-statement"
      - include: "#checker-instantiation"
  concurrent-assertion-statement:
    patterns:
      - include: "#assert-property-statement"
      - include: "#assume-property-statement"
      - include: "#cover-property-statement"
      - include: "#cover-sequence-statement"
      - include: "#restrict-property-statement"
  assert-property-statement:
    patterns:
      - begin: \b(assert)\b\s+\b(property)\b\s*(?:(\()\s*)?
        end: (\))\s*|${bracketsFailSafe}
        beginCaptures:
          "1": { name: keyword.control.assert.sv }
          "2": { name: keyword.control.property.sv }
          "3": { name: punctuation.section.group.begin.sv }
        endCaptures:
          "1": { name: punctuation.section.group.end.sv }
        patterns:
          - include: "#property-spec"
      - include: "#action-block"
  assume-property-statement:
    patterns:
      - begin: \b(assume)\b\s+\b(property)\b\s*(?:(\()\s*)?
        end: (\))\s*|${bracketsFailSafe}
        beginCaptures:
          "1": { name: keyword.control.assume.sv }
          "2": { name: keyword.control.property.sv }
          "3": { name: punctuation.section.group.begin.sv }
        endCaptures:
          "1": { name: punctuation.section.group.end.sv }
        patterns:
          - include: "#property-spec"
      - include: "#action-block"
  cover-property-statement:
    patterns:
      - begin: \b(cover)\b\s+\b(property)\b\s*(?:(\()\s*)?
        end: (\))\s*|${bracketsFailSafe}
        beginCaptures:
          "1": { name: keyword.control.cover.sv }
          "2": { name: keyword.control.property.sv }
          "3": { name: punctuation.section.group.begin.sv }
        endCaptures:
          "1": { name: punctuation.section.group.end.sv }
        patterns:
          - include: "#property-spec"
      # - include: "#statement-or-null"
  expect-property-statement:
    patterns:
      - begin: \b(expect)\b\s*(?:(\()\s*)?
        end: (\))\s*|${bracketsFailSafe}
        beginCaptures:
          "1": { name: keyword.control.expect.sv }
          "2": { name: punctuation.section.group.begin.sv }
        endCaptures:
          "1": { name: punctuation.section.group.end.sv }
        patterns:
          - include: "#property-spec"
      - include: "#action-block"
  cover-sequence-statement:
    patterns:
      - begin: \b(cover)\b\s+\b(sequence)\b\s*(?:(\()\s*)?
        end: (\))\s*|${bracketsFailSafe}
        beginCaptures:
          "1": { name: keyword.control.cover.sv }
          "2": { name: keyword.control.sequence.sv }
          "3": { name: punctuation.section.group.begin.sv }
        endCaptures:
          "1": { name: punctuation.section.group.end.sv }
        patterns:
          - include: "#clocking-event"
          - begin: \b(disable)\b\s+\b(iff)\b\s*(?:(\()\s*)?
            end: (\))\s*|${bracketsFailSafe}
            beginCaptures:
              "1": { name: keyword.control.disable.sv }
              "2": { name: keyword.control.iff.sv }
              "3": { name: punctuation.section.group.begin.sv }
            endCaptures:
              "1": { name: punctuation.section.group.end.sv }
            patterns:
              - include: "#expression-or-dist"
          - include: "#sequence-expr"
  restrict-property-statement:
    patterns:
      - begin: \b(restrict)\b\s*(?:\b(property)\b\s*)?(?:(\()\s*)?
        end: (\))\s*|${blocksFailSafe}
        beginCaptures:
          "1": { name: keyword.control.restrict.sv }
          "2": { name: keyword.control.property.sv }
          "3": { name: punctuation.section.group.begin.sv }
        endCaptures:
          "1": { name: punctuation.section.group.end.sv }
        patterns:
          - include: "#property-spec"
      - include: "#semicolon"
  property-instance:
    patterns:
      - include: "#ps-or-hierarchical-property-identifier"
      - name: meta.property-instance.sv
        begin: (\()\s*
        end: (\))\s*|${bracketsFailSafe}
        beginCaptures:
          "1": { name: punctuation.section.group.begin.sv }
        endCaptures:
          "1": { name: punctuation.section.group.end.sv }
        patterns:
          - include: "#property-list-of-arguments"
  property-list-of-arguments:
    patterns:
      - begin: (\.)\s*(${identifier})\s*(\()\s*
        end: (\))\s*|${bracketsFailSafe}
        beginCaptures:
          "1": { name: punctuation.separator.dot.sv }
          "2": { name: entity.name.function.$2.sv }
          "3": { name: punctuation.section.group.begin.sv }
        endCaptures:
          "1": { name: punctuation.section.group.end.sv }
        patterns:
          - include: "#property-actual-arg"
      - include: "#property-actual-arg"
      - include: "#comma"
  property-actual-arg:
    patterns:
      - include: "#property-expr"
      - include: "#sequence-actual-arg"
  assertion-item-declaration:
    patterns:
      - include: "#property-declaration"
      - include: "#sequence-declaration"
      - include: "#let-declaration"
  property-declaration:
    begin: (?=\b(property)\b\s*)
    end: \b(endproperty)\b\s*(?:(\:)\s*(${identifier})\s*)?|${blocksFailSafe}
    endCaptures:
      "1": { name: storage.type.property.sv }
      "2": { name: punctuation.separator.colon.sv }
      "3": { name: entity.name.type.property.sv }
    patterns:
      - name: meta.property-declaration-header.sv
        begin: \b(property)\b\s*
        end: (?=\;)|${blocksFailSafe}
        beginCaptures:
          "1": { name: storage.type.$1.sv }
        patterns:
          - include: "#property-identifier"
          - begin: (\()\s*
            end: (\))\s*|${bracketsFailSafe}
            beginCaptures:
              "1": { name: punctuation.section.group.begin.sv }
            endCaptures:
              "1": { name: punctuation.section.group.end.sv }
            patterns:
              - include: "#property-port-list"
      - name: meta.property-declaration-body.sv
        begin: (\;)\s*
        end: (?=\b(endproperty)\b\s*)|${blocksFailSafe}
        beginCaptures:
          "1": { name: punctuation.terminator.semicolon.sv }
        patterns:
          - include: "#assertion-variable-declaration"
          - include: "#property-spec"
          - include: "#semicolon"
  property-port-list:
    patterns:
      - include: "#comma"
      - include: "#property-port-item"
  property-port-item:
    patterns:
      - include: "#attribute-instance"
      - match: \b(local)\b\s*
        captures:
          "1": { name: storage.modifier.local.sv }
      - include: "#property-lvar-port-direction"
      - include: "#formal-port-identifier"
      - include: "#variable-dimension"
      - begin: (\=)\s*(?!\=)
        end: (?=\,|\))
        beginCaptures:
          "1": { name: keyword.operator.assignment.sv }
        patterns:
          - include: "#property-actual-arg"
      - include: "#property-formal-type"
  property-lvar-port-direction:
    match: \b(input)\b\s*
    captures:
      "1": { name: storage.modifier.input.sv }
  property-formal-type:
    patterns:
      - include: "#sequence-formal-type"
      - match: \b(property)\b\s*
        captures:
          "1": { name: entity.name.type.$1.sv }
  property-spec:
    patterns:
      - name: meta.property-spec.sv
        begin: \b(disable)\b\s+\b(iff)\b\s*(\()\s*
        end: (\))\s*|${bracketsFailSafe}
        beginCaptures:
          "1": { name: keyword.control.disable.sv }
          "2": { name: keyword.control.iff.sv }
          "3": { name: punctuation.section.group.begin.sv }
        endCaptures:
          "1": { name: punctuation.section.group.end.sv }
        patterns:
          - include: "#expression-or-dist"
      - include: "#clocking-event"
      - include: "#property-expr"
  property-expr:
    patterns:
      - include: "#sequence-expr"
      - begin: \b(strong)\b\s*(\()\s*
        end: (\))\s*|${bracketsFailSafe}
        beginCaptures:
          "1": { name: keyword.operator.strong.sv }
          "2": { name: punctuation.section.braces.begin.sv }
        endCaptures:
          "1": { name: punctuation.section.braces.end.sv }
        patterns:
          - include: "#sequence-expr"
      - begin: \b(weak)\b\s*(\()\s*
        end: (\))\s*|${bracketsFailSafe}
        beginCaptures:
          "1": { name: keyword.operator.weak.sv }
          "2": { name: punctuation.section.braces.begin.sv }
        endCaptures:
          "1": { name: punctuation.section.braces.end.sv }
        patterns:
          - include: "#sequence-expr"
      - begin: (\()\s*
        end: (\))\s*|${bracketsFailSafe}
        beginCaptures:
          "1": { name: punctuation.section.group.begin.sv }
        endCaptures:
          "1": { name: punctuation.section.group.end.sv }
        patterns:
          - include: "#property-expr"
      - match: \b(not)\b\s*
        captures:
          "1": { name: keyword.other.logical.sv }
      - match: \b(or)\b\s*
        captures:
          "1": { name: keyword.other.logical.sv }
      - match: \b(and)\b\s*
        captures:
          "1": { name: keyword.other.logical.sv }
      - match: (\|->)\s*
        captures:
          "1": { name: keyword.operator.property.sv }
      - match: (\|=>)\s*
        captures:
          "1": { name: keyword.operator.property.sv }
      - begin: \b(if)\b\s*(\()\s*
        end: (\))\s*|${bracketsFailSafe}
        beginCaptures:
          "1": { name: keyword.control.$1.sv }
          "2": { name: punctuation.section.group.begin.sv }
        endCaptures:
          "1": { name: punctuation.section.group.end.sv }
        patterns:
          - include: "#expression-or-dist"
      - match: \b(else)\b\s*
        captures:
          "1": { name: keyword.control.$1.sv }
      - begin: (?=\b(case)\b\s*(\()\s*)
        end: \b(endcase)\b\s*
        beginCaptures:
          "1": { name: keyword.control.$1.sv }
          "2": { name: punctuation.section.group.begin.sv }
        endCaptures:
          "1": { name: keyword.control.endcase.sv }
        patterns:
          - begin: \b(case)\b\s*(\()\s*
            end: (?=\))
            beginCaptures:
              "1": { name: keyword.control.$1.sv }
              "2": { name: punctuation.section.group.begin.sv }
            patterns:
              - include: "#expression-or-dist"
          - begin: (\))\s*|${bracketsFailSafe}
            end: (?=\b(endcase)\b)
            beginCaptures:
              "1": { name: punctuation.section.group.end.sv }
            patterns:
              - include: "#property-case-item"
      - match: (#-#)\s*
        captures:
          "1": { name: keyword.operator.property.sv }
      - match: (#=#)\s*
        captures:
          "1": { name: keyword.operator.property.sv }
      - begin: \b(nexttime)\b\s*(\[)\s*
        end: (\])\s*|${bracketsFailSafe}
        beginCaptures:
          "1": { name: keyword.other.nexttime.sv }
          "2": { name: punctuation.section.brackets.begin.sv }
        endCaptures:
          "1": { name: punctuation.section.brackets.end.sv }
        patterns:
          - include: "#constant-expression"
      - match: \b(nexttime)\b\s*
        captures:
          "1": { name: keyword.other.nexttime.sv }
      - begin: \b(s_nexttime)\b\s*(\[)\s*
        end: (\])\s*|${bracketsFailSafe}
        beginCaptures:
          "1": { name: keyword.other.s_nexttime.sv }
          "2": { name: punctuation.section.brackets.begin.sv }
        endCaptures:
          "1": { name: punctuation.section.brackets.end.sv }
        patterns:
          - include: "#constant-expression"
      - match: \b(s_nexttime)\b\s*
        captures:
          "1": { name: keyword.other.s_nexttime.sv }
      - begin: \b(always)\b\s*(\[)\s*
        end: (\])\s*|${bracketsFailSafe}
        beginCaptures:
          "1": { name: keyword.other.always.sv }
          "2": { name: punctuation.section.brackets.begin.sv }
        endCaptures:
          "1": { name: punctuation.section.brackets.end.sv }
        patterns:
          - include: "#cycle-delay-const-range-expression"
      - match: \b(always)\b\s*
        captures:
          "1": { name: keyword.other.always.sv }
      - begin: \b(s_always)\b\s*(\[)\s*
        end: (\])\s*|${bracketsFailSafe}
        beginCaptures:
          "1": { name: keyword.other.s_always.sv }
          "2": { name: punctuation.section.brackets.begin.sv }
        endCaptures:
          "1": { name: punctuation.section.brackets.end.sv }
        patterns:
          - include: "#constant-range"
      - begin: \b(s_eventually)\b\s*(\[)\s*
        end: (\])\s*|${bracketsFailSafe}
        beginCaptures:
          "1": { name: keyword.other.s_eventually.sv }
          "2": { name: punctuation.section.brackets.begin.sv }
        endCaptures:
          "1": { name: punctuation.section.brackets.end.sv }
        patterns:
          - include: "#cycle-delay-const-range-expression"
      - match: \b(eventually)\b\s*
        captures:
          "1": { name: keyword.other.eventually.sv }
      - begin: \b(eventually)\b\s*(\[)\s*
        end: (\])\s*|${bracketsFailSafe}
        beginCaptures:
          "1": { name: keyword.other.eventually.sv }
          "2": { name: punctuation.section.brackets.begin.sv }
        endCaptures:
          "1": { name: punctuation.section.brackets.end.sv }
        patterns:
          - include: "#constant-range"
      - match: \b(until)\b\s*
        captures:
          "1": { name: keyword.control.until.sv }
      - match: \b(s_until)\b\s*
        captures:
          "1": { name: keyword.control.s_until.sv }
      - match: \b(until_with)\b\s*
        captures:
          "1": { name: keyword.control.until_with.sv }
      - match: \b(s_until_with)\b\s*
        captures:
          "1": { name: keyword.control.s_until_with.sv }
      - match: \b(implies)\b\s*
        captures:
          "1": { name: keyword.control.implies.sv }
      - match: \b(iff)\b\s*
        captures:
          "1": { name: keyword.control.iff.sv }
      - begin: \b(accept_on)\b\s*(\()\s*
        end: (\))\s*|${bracketsFailSafe}
        beginCaptures:
          "1": { name: keyword.control.accept_on.sv }
          "2": { name: punctuation.section.group.begin.sv }
        endCaptures:
          "1": { name: punctuation.section.group.end.sv }
        patterns:
          - include: "#expression-or-dist"
      - begin: \b(reject_on)\b\s*(\()\s*
        end: (\))\s*|${bracketsFailSafe}
        beginCaptures:
          "1": { name: keyword.control.reject_on.sv }
          "2": { name: punctuation.section.group.begin.sv }
        endCaptures:
          "1": { name: punctuation.section.group.end.sv }
        patterns:
          - include: "#expression-or-dist"
      - begin: \b(sync_accept_on)\b\s*(\()\s*
        end: (\))\s*|${bracketsFailSafe}
        beginCaptures:
          "1": { name: keyword.control.sync_accept_on.sv }
          "2": { name: punctuation.section.group.begin.sv }
        endCaptures:
          "1": { name: punctuation.section.group.end.sv }
        patterns:
          - include: "#expression-or-dist"
      - begin: \b(sync_reject_on)\b\s*(\()\s*
        end: (\))\s*|${bracketsFailSafe}
        beginCaptures:
          "1": { name: keyword.control.sync_reject_on.sv }
          "2": { name: punctuation.section.group.begin.sv }
        endCaptures:
          "1": { name: punctuation.section.group.end.sv }
        patterns:
          - include: "#expression-or-dist"
      - include: "#property-instance"
      - include: "#clocking-event"
  property-case-item:
    patterns:
      - begin: (\:)\s*
        end: (\;)\s*
        beginCaptures:
          "1": { name: punctuation.separator.colon.sv }
        endCaptures:
          "1": { name: punctuation.terminator.semicolon.sv }
        patterns:
          - include: "#property-expr"
      - include: "#expression-or-dist"
      - include: "#comma"
      - match: \b(default)\b\s*
        captures:
          "1": { name: keyword.control.default.sv }
  sequence-declaration:
    begin: (?=\b(sequence)\b\s*)
    end: \b(endsequence)\b\s*(?:(\:)\s*(${identifier})\s*)?|${blocksFailSafe}
    endCaptures:
      "1": { name: storage.type.sequence.sv }
      "2": { name: punctuation.separator.colon.sv }
      "3": { name: entity.name.type.sv }
    patterns:
      - name: meta.sequence-declaration-header.sv
        begin: \b(sequence)\b\s*
        end: (?=\;)|${blocksFailSafe}
        beginCaptures:
          "1": { name: storage.type.$1.sv }
        patterns:
          - include: "#sequence-identifier"
          - begin: (\()\s*
            end: (\))\s*|${bracketsFailSafe}
            beginCaptures:
              "1": { name: punctuation.section.group.begin.sv }
            endCaptures:
              "1": { name: punctuation.section.group.end.sv }
            patterns:
              - include: "#sequence-port-list"
      - name: meta.sequence-declaration-body.sv
        begin: (\;)\s*
        end: (?=\b(endsequence)\b\s*)|${blocksFailSafe}
        beginCaptures:
          "1": { name: punctuation.terminator.semicolon.sv }
        patterns:
          - include: "#sequence-expr"
          - include: "#assertion-variable-declaration"
          - include: "#semicolon"
  sequence-port-list:
    patterns:
      - include: "#comma"
      - include: "#sequence-port-item"
  sequence-port-item:
    patterns:
      - include: "#attribute-instance"
      - match: \b(local)\b\s*
        captures:
          "1": { name: storage.modifier.local.sv }
      - include: "#sequence-lvar-port-direction"
      - include: "#formal-port-identifier"
      - include: "#variable-dimension"
      - begin: (\=)\s*(?!\=)
        end: (?=\,|\))
        beginCaptures:
          "1": { name: keyword.operator.assignment.sv }
        patterns:
          - include: "#sequence-actual-arg"
      - include: "#sequence-formal-type"
  sequence-lvar-port-direction:
    match: \b(input|inout|output)\b\s*
    captures:
      "1": { name: storage.modifier.$1.sv }
  sequence-formal-type:
    patterns:
      - match: \b(sequence)\b\s*
        captures:
          "1": { name: entity.name.type.$1.sv }
      - match: \b(untyped)\b\s*
        captures:
          "1": { name: storage.modifier.$1.sv }
      - include: "#data-type-or-implicit"
  sequence-expr:
    patterns:
      - name: meta.sequence-expr-parenthesis.sv
        begin: (\()\s*
        end: (\))\s*|${bracketsFailSafe}
        beginCaptures:
          "1": { name: punctuation.section.group.begin.sv }
        endCaptures:
          "1": { name: punctuation.section.group.end.sv }
        patterns:
          - include: "#sequence-expr"
          - include: "#comma"
      - match: \b(and)\b\s*
        captures:
          "1": { name: keyword.other.and.sv }
      - match: \b(intersect)\b\s*
        captures:
          "1": { name: keyword.other.intersect.sv }
      - match: \b(or)\b\s*
        captures:
          "1": { name: keyword.other.or.sv }
      - begin: \b(first_match)\b\s*(\()\s*
        end: (\))\s*|${bracketsFailSafe}
        beginCaptures:
          "1": { name: keyword.other.first_match.sv }
          "2": { name: punctuation.section.group.begin.sv }
        endCaptures:
          "1": { name: punctuation.section.group.end.sv }
        patterns:
          - include: "#sequence-expr"
          - include: "#comma"
      - match: \b(throughout)\b\s*
        captures:
          "1": { name: keyword.other.throughout.sv }
      - match: \b(within)\b\s*
        captures:
          "1": { name: keyword.other.within.sv }
      - include: "#boolean-abbrev"
      - include: "#cycle-delay-range"
      - include: "#expression-or-dist"
      - include: "#sequence-instance"
      - include: "#sequence-abbrev"
      - include: "#clocking-event"
  cycle-delay-range:
    patterns:
      - begin: (\#\#)\s*(\[)\s*
        end: (\])\s*|${bracketsFailSafe}
        beginCaptures:
          "1": { name: keyword.operator.cycle-delay.sv }
          "2": { name: punctuation.section.brackets.begin.sv }
        endCaptures:
          "1": { name: punctuation.section.brackets.end.sv }
        patterns:
          - include: "#cycle-delay-const-range-expression"
          - match: (\*)\s*
            captures:
              "1": { name: keyword.operator.cycle-delay.sv }
          - match: (\+)\s*
            captures:
              "1": { name: keyword.operator.cycle-delay.sv }
      - match: (\#\#)\s*
        captures:
          "1": { name: keyword.operator.cycle-delay.sv }
      - include: "#constant-primary"
  sequence-method-call:
    patterns:
      - include: "#sequence-instance"
      - include: "#dot"
      - include: "#method-identifier"
  sequence-match-item:
    patterns:
      - include: "#operator-assignment"
      - include: "#inc-or-dec-expression"
      - include: "#subroutine-call"
  sequence-instance:
    patterns:
      - include: "#ps-or-hierarchical-sequence-identifier"
      - name: meta.sequence-instance.sv
        begin: (\()\s*
        end: (\))\s*|${bracketsFailSafe}
        beginCaptures:
          "1": { name: punctuation.section.group.begin.sv }
        endCaptures:
          "1": { name: punctuation.section.group.end.sv }
        patterns:
          - include: "#sequence-list-of-arguments"
  sequence-list-of-arguments:
    patterns:
      - begin: (\.)\s*(${identifier})\s*(\()\s*
        end: (\))\s*|${bracketsFailSafe}
        beginCaptures:
          "1": { name: punctuation.definition.named-parameter-assignment.sv }
          "2": { name: variable.parameter.sv }
          "3": { name: punctuation.section.group.begin.sv }
        endCaptures:
          "1": { name: punctuation.section.group.end.sv }
        patterns:
          - include: "#sequence-actual-arg"
      - include: "#sequence-actual-arg"
      - include: "#comma"
  sequence-actual-arg:
    patterns:
      - include: "#event-expression"
      - include: "#sequence-expr"
  boolean-abbrev:
    patterns:
      - include: "#consecutive-repetition"
      - include: "#non-consecutive-repetition"
      - include: "#goto-repetition"
  sequence-abbrev:
    patterns:
      - include: "#consecutive-repetition"
  consecutive-repetition:
    patterns:
      - name: meta.consecutive-repetition.sv
        match: (\[)\s*(\*)\s*(\])\s*
        captures:
          "1": { name: punctuation.section.brackets.begin.sv }
          "2": { name: keyword.operator.consecutive-repetition.sv }
          "3": { name: punctuation.section.brackets.end.sv }
      - name: meta.consecutive-repetition.sv
        match: (\[)\s*(\+)\s*(\])\s*
        captures:
          "1": { name: punctuation.section.brackets.begin.sv }
          "2": { name: keyword.operator.consecutive-repetition.sv }
          "3": { name: punctuation.section.brackets.end.sv }
      - name: meta.consecutive-repetition.sv
        begin: (\[)\s*(\*)\s*
        end: (\])\s*|${bracketsFailSafe}
        beginCaptures:
          "1": { name: punctuation.section.brackets.begin.sv }
          "2": { name: keyword.operator.consecutive-repetition.sv }
        endCaptures:
          "1": { name: punctuation.section.brackets.end.sv }
        patterns:
          - include: "#const-or-range-expression"
  non-consecutive-repetition:
    patterns:
      - name: meta.non-consecutive-repetition.sv
        begin: (\[)\s*(\=)\s*
        end: (\])\s*|${bracketsFailSafe}
        beginCaptures:
          "1": { name: punctuation.section.brackets.begin.sv }
          "2": { name: keyword.operator.non-consecutive-repetition.sv }
        endCaptures:
          "1": { name: punctuation.section.brackets.end.sv }
        patterns:
          - include: "#const-or-range-expression"
  goto-repetition:
    patterns:
      - name: meta.goto-repetition.sv
        begin: (\[)\s*(\-\>)\s*
        end: (\])\s*|${bracketsFailSafe}
        beginCaptures:
          "1": { name: punctuation.section.brackets.begin.sv }
          "2": { name: keyword.operator.goto-repetition.sv }
        endCaptures:
          "1": { name: punctuation.section.brackets.end.sv }
        patterns:
          - include: "#const-or-range-expression"
  const-or-range-expression:
    patterns:
      - include: "#constant-expression"
      - include: "#cycle-delay-const-range-expression"
  cycle-delay-const-range-expression:
    patterns:
      - match: (\:)\s*
        captures:
          "1": { name: punctuation.separator.colon.sv }
      - match: (\$)\s*
        captures:
          "1": { name: keyword.operator.cycle-delay.sv }
      - include: "#constant-expression"
  expression-or-dist:
    patterns:
      - include: "#expression"
      - begin: \b(dist)\b\s*(\{)\s*
        end: (\})\s*|${bracketsFailSafe}
        beginCaptures:
          "1": { name: keyword.other.dist.sv }
          "2": { name: punctuation.section.braces.begin.sv }
        endCaptures:
          "1": { name: punctuation.section.braces.end.sv }
        patterns:
          - include: "#dist-list"
  assertion-variable-declaration:
    patterns:
      - include: "#list-of-variable-decl-assignments"
      - include: "#var-data-type"
      - include: "#semicolon"
  # A.2.11 Covergroup declarations
  covergroup-declaration:
    name: meta.covergroup-declaration.sv
    begin: (?=\b(covergroup)\b\s*)
    end: \b(endgroup)\b\s*(?:(\:)\s*(${identifier})\s*)?|${blocksFailSafe}
    endCaptures:
      "1": { name: storage.type.covergroup.sv }
      "2": { name: punctuation.separator.colon.sv }
      "3": { name: entity.name.type.covergroup.sv }
    patterns:
      - name: meta.covergroup-declaration-header.sv
        begin: \b(covergroup)\b\s*(?:(${identifier})\s*)?|${blocksFailSafe}
        end: (?=\;)|${blocksFailSafe}
        beginCaptures:
          "1": { name: storage.type.$1.sv }
          "2": { name: entity.name.type.sv }
        patterns:
          - include: "#covergroup-identifier"
          - begin: (\()\s*
            end: (\))\s*|${bracketsFailSafe}
            beginCaptures:
              "1": { name: punctuation.section.group.begin.sv }
            endCaptures:
              "1": { name: punctuation.section.group.end.sv }
            patterns:
              - include: "#tf-port-list"
          - include: "#coverage-event"
      - name: meta.covergroup-declaration-body.sv
        begin: (\;)\s*
        end: (?=\b(endgroup)\b\s*)|${blocksFailSafe}
        beginCaptures:
          "1": { name: punctuation.terminator.semicolon.sv }
        patterns:
          - include: "#coverage-spec-or-option"
          - include: "#semicolon"
  coverage-spec-or-option:
    patterns:
      - include: "#attribute-instance"
      - include: "#coverage-option"
      - include: "#coverage-spec"
      - include: "#semicolon"
  coverage-option:
    patterns:
      - name: meta.coverage-option.sv
        begin: \b(option)\b\s*(\.)\s*(${identifier})\s*(\=)\s*
        end: (?=\;)
        beginCaptures:
          "1": { name: variable.language.option.sv }
          "2": { name: punctuation.accessor.dot.sv }
          "3": { name: variable.other.sv }
          "4": { name: keyword.operator.assignment.sv }
        patterns:
          - include: "#expression"
      - name: meta.coverage-option.sv
        begin: \b(type_option)\b\s*(\.)\s*(${identifier})\s*(\=)\s*
        end: (?=\;)
        beginCaptures:
          "1": { name: variable.language.option.sv }
          "2": { name: punctuation.accessor.dot.sv }
          "3": { name: variable.other.sv }
          "4": { name: keyword.operator.assignment.sv }
        patterns:
          - include: "#constant-expression"
  coverage-spec:
    patterns:
      - include: "#cover-point"
      - include: "#cover-cross"
  coverage-event:
    patterns:
      - include: "#clocking-event"
      - begin: \b(with)\b\s+\b(function)\b\s+\b(sample)\b\s*(\()\s*
        end: (\))\s*|${bracketsFailSafe}
        beginCaptures:
          "1": { name: keyword.control.with.sv }
          "2": { name: storage.type.function.sv }
          "3": { name: entity.name.function.sv }
          "4": { name: punctuation.section.group.begin.sv }
        endCaptures:
          "1": { name: punctuation.section.group.end.sv }
        patterns:
          - include: "#tf-port-list"
      - begin: (\@\@)\s*(\()\s*
        end: (\))\s*|${bracketsFailSafe}
        beginCaptures:
          "1": { name: punctuation.definition.block-event.sv }
          "2": { name: punctuation.section.group.begin.sv }
        endCaptures:
          "1": { name: punctuation.section.group.end.sv }
        patterns:
          - include: "#block-event-expression"
  block-event-expression:
    patterns:
      - match: \b(or)\b\s*
        captures:
          "1": { name: keyword.other.logical.sv }
      - match: \b(begin)\b\s*
        captures:
          "1": { name: keyword.control.begin.sv }
      - match: \b(end)\b\s*
        captures:
          "1": { name: keyword.control.end.sv }
      - include: "#hierarchical-btf-identifier"
  hierarchical-btf-identifier:
    patterns:
      - include: "#hierarchical-tf-identifier"
      - include: "#hierarchical-block-identifier"
      - include: "#method-identifier"
      - include: "#class-scope"
      - include: "#hierarchical-identifier"
      - include: "#dot"
  cover-point:
    patterns:
      - match: (${identifier})\s*(\:)\s*
        captures:
          "1": { name: variable.other.sv }
          "2": { name: punctuation.separator.colon.sv }
      - name: meta.cover-point.sv
        begin: \b(coverpoint)\b\s*
        end: (?<=\;|\})|(?=\b(coverpoint|cross|endgroup)\b)|(?=${identifier}\s*\:)|${blocksFailSafe}
        beginCaptures:
          "1": { name: storage.type.coverpoint.sv }
        patterns:
          - begin: \b(iff)\b\s*(\()\s*
            end: (\))\s*|${bracketsFailSafe}
            beginCaptures:
              "1": { name: keyword.control.iff.sv }
              "2": { name: punctuation.section.group.begin.sv }
            endCaptures:
              "1": { name: punctuation.section.group.end.sv }
            patterns:
              - include: "#expression"
          - include: "#expression"
          - include: "#bins-or-empty"
      - include: "#data-type-or-implicit"
  bins-or-empty:
    patterns:
      - name: meta.bins-or-empty.sv
        begin: (\{)\s*
        end: (\})\s*|${bracketsFailSafe}
        beginCaptures:
          "1": { name: punctuation.section.braces.begin.sv }
        endCaptures:
          "1": { name: punctuation.section.braces.end.sv }
        patterns:
          - include: "#attribute-instance"
          - include: "#bins-or-options"
          - include: "#semicolon"
      - include: "#semicolon"
  bins-or-options:
    patterns:
      - include: "#coverage-option"
      - name: meta.bins.sv
        begin: (?=(?:\b(wildcard)\b\s*)?\b(bins|illegal_bins|ignore_bins)\b)
        end: (\;)\s*
        endCaptures:
          "1": { name: punctuation.terminator.semicolon.sv }
        patterns:
          - name: meta.bins-header.sv
            begin: (?:\b(wildcard)\b\s*)?\b(bins|illegal_bins|ignore_bins)\b\s*(${identifier})\s*
            end: (?=\=)
            beginCaptures:
              "1": { name: storage.modifier.$1.sv }
              "2": { name: storage.type.$2.sv }
              "3": { name: variable.other.sv }
              "4": { name: keyword.operator.assignment.sv }
            patterns:
              - begin: (\[)\s*
                end: (\])\s*|${bracketsFailSafe}
                beginCaptures:
                  "1": { name: punctuation.section.brackets.begin.sv }
                endCaptures:
                  "1": { name: punctuation.section.brackets.end.sv }
                patterns:
                  - include: "#covergroup-expression"
          - name: meta.bins-body.sv
            begin: (\=)\s*
            end: (?=\;)
            beginCaptures:
              "1": { name: keyword.operator.assignment.sv }
            patterns:
              - name: meta.covergroup-range-list.sv
                begin: (\{)\s*
                end: (\})\s*|${bracketsFailSafe}
                beginCaptures:
                  "1": { name: punctuation.section.braces.begin.sv }
                endCaptures:
                  "1": { name: punctuation.section.braces.end.sv }
                patterns:
                  - include: "#covergroup-range-list"
              - include: "#coverpoint-identifier"
              - include: "#trans-list"
              - match: \b(default)\b\s*(?:\b(sequence)\b)?\s*
                captures:
                  "1": { name: keyword.control.default.sv }
                  "2": { name: keyword.control.sequence.sv }
              - begin: \b(with)\b\s*(\()\s*
                end: (\))\s*|${bracketsFailSafe}
                beginCaptures:
                  "1": { name: keyword.control.with.sv }
                  "2": { name: punctuation.section.group.begin.sv }
                endCaptures:
                  "1": { name: punctuation.section.group.end.sv }
                patterns:
                  - include: "#with-covergroup-expression"
              - begin: \b(iff)\b\s*(\()\s*
                end: (\))\s*|${bracketsFailSafe}
                beginCaptures:
                  "1": { name: keyword.control.iff.sv }
                  "2": { name: punctuation.section.group.begin.sv }
                endCaptures:
                  "1": { name: punctuation.section.group.end.sv }
                patterns:
                  - include: "#expression"
  bins-keyword:
    match: \b(bins|illegal_bins|ignore_bins)\b\s*
    captures:
      "1": { name: storage.type.$1.sv }
  trans-list:
    patterns:
      - begin: (\()\s*
        end: (\))\s*|${bracketsFailSafe}
        beginCaptures:
          "1": { name: punctuation.section.group.begin.sv }
        endCaptures:
          "1": { name: punctuation.section.group.end.sv }
        patterns:
          - include: "#trans-set"
      - include: "#comma"
  trans-set:
    patterns:
      - include: "#trans-range-list"
      - match: (\=\>)\s*
        captures:
          "1": { name: keyword.operator.trans-set.sv }
  trans-range-list:
    patterns:
      - begin: (\[)\s*(\*)\s*
        end: (\])\s*|${bracketsFailSafe}
        beginCaptures:
          "1": { name: punctuation.section.brackets.begin.sv }
          "2": { name: keyword.operator.trans-range.sv }
        endCaptures:
          "1": { name: punctuation.section.brackets.end.sv }
        patterns:
          - include: "#repeat-range"
      - begin: (\[)\s*(\-\>)\s*
        end: (\])\s*|${bracketsFailSafe}
        beginCaptures:
          "1": { name: punctuation.section.brackets.begin.sv }
          "2": { name: keyword.operator.trans-range.sv }
        endCaptures:
          "1": { name: punctuation.section.brackets.end.sv }
        patterns:
          - include: "#repeat-range"
      - begin: (\[)\s*(\=)\s*
        end: (\])\s*|${bracketsFailSafe}
        beginCaptures:
          "1": { name: punctuation.section.brackets.begin.sv }
          "2": { name: keyword.operator.trans-range.sv }
        endCaptures:
          "1": { name: punctuation.section.brackets.end.sv }
        patterns:
          - include: "#repeat-range"
      - include: "#trans-item"
  trans-item:
    patterns:
      - include: "#covergroup-range-list"
  repeat-range:
    patterns:
      - include: "#colon"
      - include: "#covergroup-expression"
  cover-cross:
    patterns:
      - begin: \b(cross)\b\s*
        end: (?<=\;|\})|(?=\b(coverpoint|cross|endgroup)\b)|(?=${identifier}\s*\:)
        beginCaptures:
          "1": { name: storage.type.cross.sv }
        patterns:
          - include: "#list-of-cross-items"
          - begin: \b(iff)\b\s*(\()\s*
            end: (\))\s*|${bracketsFailSafe}
            beginCaptures:
              "1": { name: keyword.control.iff.sv }
              "2": { name: punctuation.section.group.begin.sv }
            endCaptures:
              "1": { name: punctuation.section.group.end.sv }
            patterns:
              - include: "#expression"
          - include: "#cross-body"
      - include: "#cross-identifier"
      - include: "#colon"
  list-of-cross-items:
    patterns:
      - include: "#cross-item"
      - include: "#comma"
  cross-item:
    patterns:
      - include: "#cover-point-identifier"
      - include: "#variable-identifier"
  cross-body:
    patterns:
      - name: meta.cross-body.sv
        begin: (\{)\s*
        end: (\})\s*|${bracketsFailSafe}
        beginCaptures:
          "1": { name: punctuation.section.braces.begin.sv }
        endCaptures:
          "1": { name: punctuation.section.braces.end.sv }
        patterns:
          - include: "#cross-body-item"
          - include: "#semicolon"
      - include: "#semicolon"
  cross-body-item:
    patterns:
      - include: "#function-declaration"
      - include: "#bins-selection-or-option"
      - include: "#semicolon"
  bins-selection-or-option:
    patterns:
      - include: "#attribute-instance"
      - include: "#coverage-option"
      - include: "#bins-selection"
  bins-selection:
    patterns:
      - include: "#bins-keyword"
      - include: "#bin-identifier"
      - include: "#equal"
      - include: "#select-expression"
      - begin: \b(iff)\b\s*(\()\s*
        end: (\))\s*|${bracketsFailSafe}
        beginCaptures:
          "1": { name: keyword.control.iff.sv }
          "2": { name: punctuation.section.group.begin.sv }
        endCaptures:
          "1": { name: punctuation.section.group.end.sv }
        patterns:
          - include: "#expression"
  select-expression:
    patterns:
      - include: "#select-condition"
      - match: (\!)\s*
        captures:
          "1": { name: keyword.operator.unary.sv }
      - match: (\&\&)\s*
        captures:
          "1": { name: keyword.operator.binary.sv }
      - match: (\|\|)\s*
        captures:
          "1": { name: keyword.operator.binary.sv }
      - begin: (\()\s*
        end: (\))\s*|${bracketsFailSafe}
        beginCaptures:
          "1": { name: punctuation.section.group.begin.sv }
        endCaptures:
          "1": { name: punctuation.section.group.end.sv }
        patterns:
          - include: "#select-expression"
      - begin: \b(with)\b\s*(\()\s*
        end: (\))\s*|${bracketsFailSafe}
        beginCaptures:
          "1": { name: keyword.control.with.sv }
          "2": { name: punctuation.section.group.begin.sv }
        endCaptures:
          "1": { name: punctuation.section.group.end.sv }
        patterns:
          - include: "#with-covergroup-expression"
      - begin: \b(matches)\b\s*
        end: (?=\;)
        beginCaptures:
          "1": { name: keyword.control.matches.sv }
        patterns:
          - include: "#integer-covergroup-expression"
      - include: "#cross-identifier"
      - include: "#cross-set-expression"
  select-condition:
    patterns:
      - begin: \b(binsof)\b\s*(\()\s*
        end: (\))\s*|${bracketsFailSafe}
        beginCaptures:
          "1": { name: keyword.control.binsof.sv }
          "2": { name: punctuation.section.group.begin.sv }
        endCaptures:
          "1": { name: punctuation.section.group.end.sv }
        patterns:
          - include: "#bins-expression"
      - begin: \b(intersect)\b\s*(\{)\s*
        end: (\})\s*|${bracketsFailSafe}
        beginCaptures:
          "1": { name: keyword.other.intersect.sv }
          "2": { name: punctuation.section.braces.begin.sv }
        endCaptures:
          "1": { name: punctuation.section.braces.end.sv }
        patterns:
          - include: "#covergroup-range-list"
  bins-expression:
    patterns:
      - include: "#variable-identifier"
      - include: "#cover-point-identifier"
      - include: "#dot"
      - include: "#bin-identifier"
  covergroup-range-list:
    patterns:
      - include: "#covergroup-value-range"
      - include: "#comma"
  covergroup-value-range:
    patterns:
      - include: "#covergroup-expression"
      - begin: (\[)\s*
        end: (\])\s*|${bracketsFailSafe}
        beginCaptures:
          "1": { name: punctuation.section.brackets.begin.sv }
        endCaptures:
          "1": { name: punctuation.section.brackets.end.sv }
        patterns:
          - include: "#colon"
          - include: "#covergroup-expression"
  with-covergroup-expression:
    patterns:
      - include: "#covergroup-expression"
  set-covergroup-expression:
    patterns:
      - include: "#covergroup-expression"
  integer-covergroup-expression:
    patterns:
      - include: "#covergroup-expression"
  cross-set-expression:
    patterns:
      - include: "#covergroup-expression"
  covergroup-expression:
    patterns:
      - include: "#expression"
  # A.2.12 Let declarations
  let-declaration:
    name: meta.let-declaration.sv
    begin: \b(let)\b\s*
    end: (\;)\s*
    beginCaptures:
      "1": { name: storage.type.$1.sv }
    endCaptures:
      "1": { name: punctuation.terminator.semicolon.sv }
    patterns:
      - name: meta.let-declaration-header.sv
        begin: (\()\s*
        end: (\))\s*|${bracketsFailSafe}
        beginCaptures:
          "1": { name: punctuation.section.group.begin.sv }
        endCaptures:
          "1": { name: punctuation.section.group.end.sv }
        patterns:
          - include: "#let-port-list"
      - begin: (\=)\s*(?!\=)
        end: (?=\;)
        beginCaptures:
          "1": { name: keyword.operator.assignment.sv }
        patterns:
          - include: "#expression"
      - include: "#let-identifier"
  let-identifier:
    match: ${functionIdentifierStart}(${functionIdentifier})\s*(?=\()
    captures:
      "1": { name: entity.name.function.sv }
  let-port-list:
    patterns:
      - include: "#comma"
      - include: "#let-port-item"
  let-port-item:
    patterns:
      - include: "#attribute-instance"
      - begin: (\=)\s*(?!\=)
        end: (?=\,|\))
        beginCaptures:
          "1": { name: keyword.operator.assignment.sv }
        patterns:
          - include: "#expression"
      - include: "#variable-dimension"
      - include: "#formal-port-identifier"
      - include: "#let-formal-type"
  let-formal-type:
    patterns:
      - match: \b(untyped)\b\s*
        captures:
          "1": { name: storage.modifier.$1.sv }
      - include: "#data-type-or-implicit"
  let-expression:
    patterns:
      - include: "#package-scope"
      - include: "#let-identifier"
      - name: meta.let-expression.sv
        begin: (\()\s*
        end: (\))\s*|${bracketsFailSafe}
        beginCaptures:
          "1": { name: punctuation.section.group.begin.sv }
        endCaptures:
          "1": { name: punctuation.section.group.end.sv }
        patterns:
          - include: "#let-list-of-arguments"
  let-list-of-arguments:
    patterns:
      - begin: (?<!\w)(\.)\s*(${identifier})\s*(\()\s*
        end: (\))\s*|${bracketsFailSafe}
        beginCaptures:
          "1": { name: punctuation.definition.named-parameter-assignment.sv }
          "2": { name: variable.parameter.sv }
          "3": { name: punctuation.section.group.begin.sv }
        endCaptures:
          "1": { name: punctuation.section.group.end.sv }
        patterns:
          - include: "#let-actual-arg"
      - include: "#comma"
      - include: "#let-actual-arg"
  let-actual-arg:
    patterns:
      - include: "#expression"
  # A.3 Primitive instances
  # A.3.1 Primitive instantiation and instances
  gate-instantiation:
    patterns:
      - begin: \b(cmos|rcmos)\b\s*
        end: (\;)\s*
        beginCaptures:
          "1": { name: entity.name.type.sv }
        endCaptures:
          "1": { name: punctuation.terminator.semicolon.sv }
        patterns:
          - include: "#delay3"
          - include: "#cmos-switch-instance"
          - include: "#comma"
      - begin: \b(bufif0|bufif1|notif0|notif1)\b\s*
        end: (\;)\s*
        beginCaptures:
          "1": { name: entity.name.type.sv }
        endCaptures:
          "1": { name: punctuation.terminator.semicolon.sv }
        patterns:
          - include: "#drive-strength"
          - include: "#delay3"
          - include: "#enable-gate-instance"
          - include: "#comma"
      - begin: \b(nmos|pmos|rnmos|rpmos)\b\s*
        end: (\;)\s*
        beginCaptures:
          "1": { name: entity.name.type.sv }
        endCaptures:
          "1": { name: punctuation.terminator.semicolon.sv }
        patterns:
          - include: "#delay3"
          - include: "#mos-switch-instance"
          - include: "#comma"
      - begin: \b(and|nand|or|nor|xor|xnor)\b\s*
        end: (\;)\s*
        beginCaptures:
          "1": { name: entity.name.type.sv }
        endCaptures:
          "1": { name: punctuation.terminator.semicolon.sv }
        patterns:
          - include: "#drive-strength"
          - include: "#delay2"
          - include: "#n-input-gate-instance"
          - include: "#comma"
      - begin: \b(buf|not)\b\s*
        end: (\;)\s*
        beginCaptures:
          "1": { name: entity.name.type.sv }
        endCaptures:
          "1": { name: punctuation.terminator.semicolon.sv }
        patterns:
          - include: "#drive-strength"
          - include: "#delay2"
          - include: "#n-output-gate-instance"
          - include: "#comma"
      - begin: \b(tranif0|tranif1|rtranif1|rtranif0)\b\s*
        end: (\;)\s*
        beginCaptures:
          "1": { name: entity.name.type.sv }
        endCaptures:
          "1": { name: punctuation.terminator.semicolon.sv }
        patterns:
          - include: "#delay2"
          - include: "#pass-enable-switch-instance"
          - include: "#comma"
      - begin: \b(tran|rtran)\b\s*
        end: (\;)\s*
        beginCaptures:
          "1": { name: entity.name.type.sv }
        endCaptures:
          "1": { name: punctuation.terminator.semicolon.sv }
        patterns:
          - include: "#pass-switch-instance"
          - include: "#comma"
      - begin: \b(pulldown)\b\s*
        end: (\;)\s*
        beginCaptures:
          "1": { name: entity.name.type.sv }
        endCaptures:
          "1": { name: punctuation.terminator.semicolon.sv }
        patterns:
          - include: "#pulldown-strength"
          - include: "#pull-gate-instance"
          - include: "#comma"
      - begin: \b(pullup)\b\s*
        end: (\;)\s*
        beginCaptures:
          "1": { name: entity.name.type.sv }
        endCaptures:
          "1": { name: punctuation.terminator.semicolon.sv }
        patterns:
          - include: "#pullup-strength"
          - include: "#pull-gate-instance"
          - include: "#comma"
  cmos-switch-instance:
    patterns:
      - include: "#name-of-instance"
      - begin: (\()\s*
        end: (\))\s*|${bracketsFailSafe}
        beginCaptures:
          "1": { name: punctuation.section.group.begin.sv }
        endCaptures:
          "1": { name: punctuation.section.group.end.sv }
        patterns:
          - include: "#comma"
          - include: "#output-terminal"
          - include: "#input-terminal"
          - include: "#ncontrol-terminal"
          - include: "#pcontrol-terminal"
  enable-gate-instance:
    patterns:
      - include: "#name-of-instance"
      - begin: (\()\s*
        end: (\))\s*|${bracketsFailSafe}
        beginCaptures:
          "1": { name: punctuation.section.group.begin.sv }
        endCaptures:
          "1": { name: punctuation.section.group.end.sv }
        patterns:
          - include: "#comma"
          - include: "#output-terminal"
          - include: "#input-terminal"
          - include: "#enable-terminal"
  mos-switch-instance:
    patterns:
      - include: "#name-of-instance"
      - begin: (\()\s*
        end: (\))\s*|${bracketsFailSafe}
        beginCaptures:
          "1": { name: punctuation.section.group.begin.sv }
        endCaptures:
          "1": { name: punctuation.section.group.end.sv }
        patterns:
          - include: "#comma"
          - include: "#output-terminal"
          - include: "#input-terminal"
          - include: "#enable-terminal"
  n-input-gate-instance:
    patterns:
      - include: "#name-of-instance"
      - begin: (\()\s*
        end: (\))\s*|${bracketsFailSafe}
        beginCaptures:
          "1": { name: punctuation.section.group.begin.sv }
        endCaptures:
          "1": { name: punctuation.section.group.end.sv }
        patterns:
          - include: "#comma"
          - include: "#output-terminal"
          - include: "#input-terminal"
  n-output-gate-instance:
    patterns:
      - include: "#name-of-instance"
      - begin: (\()\s*
        end: (\))\s*|${bracketsFailSafe}
        beginCaptures:
          "1": { name: punctuation.section.group.begin.sv }
        endCaptures:
          "1": { name: punctuation.section.group.end.sv }
        patterns:
          - include: "#comma"
          - include: "#output-terminal"
          - include: "#input-terminal"
  pass-switch-instance:
    patterns:
      - include: "#name-of-instance"
      - begin: (\()\s*
        end: (\))\s*|${bracketsFailSafe}
        beginCaptures:
          "1": { name: punctuation.section.group.begin.sv }
        endCaptures:
          "1": { name: punctuation.section.group.end.sv }
        patterns:
          - include: "#comma"
          - include: "#inout-terminal"
  pass-enable-switch-instance:
    patterns:
      - include: "#name-of-instance"
      - begin: (\()\s*
        end: (\))\s*|${bracketsFailSafe}
        beginCaptures:
          "1": { name: punctuation.section.group.begin.sv }
        endCaptures:
          "1": { name: punctuation.section.group.end.sv }
        patterns:
          - include: "#comma"
          - include: "#inout-terminal"
          - include: "#enable-terminal"
  pull-gate-instance:
    patterns:
      - include: "#name-of-instance"
      - begin: (\()\s*
        end: (\))\s*|${bracketsFailSafe}
        beginCaptures:
          "1": { name: punctuation.section.group.begin.sv }
        endCaptures:
          "1": { name: punctuation.section.group.end.sv }
        patterns:
          - include: "#output-terminal"
  # A.3.2 Primitive strengths
  pulldown-strength:
    patterns:
      - match: (\()\s*\b(supply0|strong0|pull0|weak0)\b\s*(,)\s*\b(supply1|strong1|pull1|weak1)\b\s*(\))\s*
        captures:
          "1": { name: punctuation.section.group.begin.sv }
          "2": { name: storage.modifier.strength.sv }
          "3": { name: punctuation.separator.comma.sv }
          "4": { name: storage.modifier.strength.sv }
          "5": { name: punctuation.section.group.end.sv }
      - match: (\()\s*\b(supply1|strong1|pull1|weak1)\b\s*(,)\s*\b(supply0|strong0|pull0|weak0)\b\s*(\))\s*
        captures:
          "1": { name: punctuation.section.group.begin.sv }
          "2": { name: storage.modifier.strength.sv }
          "3": { name: punctuation.separator.comma.sv }
          "4": { name: storage.modifier.strength.sv }
          "5": { name: punctuation.section.group.end.sv }
      - match: (\()\s*\b(supply0|strong0|pull0|weak0)\b\s*(\))\s*
        captures:
          "1": { name: punctuation.section.group.begin.sv }
          "2": { name: storage.modifier.strength.sv }
          "3": { name: punctuation.section.group.end.sv }
  pullup-strength:
    patterns:
      - match: (\()\s*\b(supply0|strong0|pull0|weak0)\b\s*(,)\s*\b(supply1|strong1|pull1|weak1)\b\s*(\))\s*
        captures:
          "1": { name: punctuation.section.group.begin.sv }
          "2": { name: storage.modifier.strength.sv }
          "3": { name: punctuation.separator.comma.sv }
          "4": { name: storage.modifier.strength.sv }
          "5": { name: punctuation.section.group.end.sv }
      - match: (\()\s*\b(supply1|strong1|pull1|weak1)\b\s*(,)\s*\b(supply0|strong0|pull0|weak0)\b\s*(\))\s*
        captures:
          "1": { name: punctuation.section.group.begin.sv }
          "2": { name: storage.modifier.strength.sv }
          "3": { name: punctuation.separator.comma.sv }
          "4": { name: storage.modifier.strength.sv }
          "5": { name: punctuation.section.group.end.sv }
      - match: (\()\s*\b(supply1|strong1|pull1|weak1)\b\s*(\))\s*
        captures:
          "1": { name: punctuation.section.group.begin.sv }
          "2": { name: storage.modifier.strength.sv }
          "3": { name: punctuation.section.group.end.sv }
  # A.3.3 Primitive terminals
  enable-terminal:
    patterns:
      - include: "#expression"
  inout-terminal:
    patterns:
      - include: "#net-lvalue"
  input-terminal:
    patterns:
      - include: "#expression"
  nc-ontrol-terminal:
    patterns:
      - include: "#expression"
  output-terminal:
    patterns:
      - include: "#net-lvalue"
  pc-ontrol-terminal:
    patterns:
      - include: "#expression"
  # A.3.4 Primitive gate and switch types
  cmos-switchtype:
    match: \b(cmos|rcmos)\b\s*
    captures:
      "1": { name: entity.name.type.sv }
  enable-gatetype:
    match: \b(bufif0|bufif1|notif0|notif1)\b\s*
    captures:
      "1": { name: entity.name.type.sv }
  mos-switchtype:
    match: \b(nmos|pmos|rnmos|rpmos)\b\s*
    captures:
      "1": { name: entity.name.type.sv }
  n-input-gatetype:
    match: \b(and|nand|or|nor|xor|xnor)\b\s*
    captures:
      "1": { name: entity.name.type.sv }
  n-output-gatetype:
    match: \b(buf|not)\b\s*
    captures:
      "1": { name: entity.name.type.sv }
  pass-en-switchtype:
    match: \b(tranif0|tranif1|rtranif1|rtranif0)\b\s*
    captures:
      "1": { name: entity.name.type.sv }
  pass-switchtype:
    match: \b(tran|rtran)\b\s*
    captures:
      "1": { name: entity.name.type.sv }
  # A.4 Instantiations
  # A.4.1 Instantiation
  # A.4.1.1 Module instantiation
  module-instantiation:
    # 1. module_identifier # ...
    # 2. module_identifier name_of_instance ( ...
    patterns:
      - name: meta.module-instantiation.sv
        begin: (${identifier})\s*(?=\#)
        end: (\;)\s*|${itemsFailSafe}
        beginCaptures:
          "1": { name: entity.name.type.sv }
        endCaptures:
          "1": { name: punctuation.terminator.semicolon.sv }
        patterns:
          - include: "#parameter-value-assignment"
          - include: "#hierarchical-instance"
          - include: "#comma"
      - name: meta.module-instantiation.sv
        begin: (${identifier})\s*(?=${identifier}\s*\()
        end: (\;)\s*|${bracketsFailSafe}
        beginCaptures:
          "1": { name: entity.name.type.sv }
        endCaptures:
          "1": { name: punctuation.terminator.semicolon.sv }
        patterns:
          - include: "#hierarchical-instance"
          - include: "#comma"
  parameter-value-assignment:
    begin: (\#)\s*(\()
    end: (\))\s*|${bracketsFailSafe}
    beginCaptures:
      "1": { name: punctuation.definition.parameter-assignment-or-delay.sv }
      "2": { name: punctuation.section.group.begin.sv }
    endCaptures:
      "1": { name: punctuation.section.group.end.sv }
    patterns:
      - include: "#list-of-parameter-assignments"
  list-of-parameter-assignments:
    patterns:
      - include: "#named-parameter-assignment"
      - include: "#ordered-parameter-assignment"
      - include: "#comma"
  ordered-parameter-assignment:
    patterns:
      - include: "#param-expression"
  named-parameter-assignment:
    name: meta.named-parameter-assignment.sv
    begin: (?<!\w)(\.)\s*(${identifier})\s*
    end: (?=\)|,)
    beginCaptures:
      "1": { name: punctuation.definition.named-parameter-assignment.sv }
      "2": { name: variable.parameter.sv }
    patterns:
      - name: meta.named-parameter-assignment.sv
        begin: (\()\s*
        end: (\))\s*|${bracketsFailSafe}
        beginCaptures:
          "1": { name: punctuation.section.group.begin.sv }
        endCaptures:
          "1": { name: punctuation.section.group.end.sv }
        patterns:
          - include: "#param-expression"
  hierarchical-instance:
    name: meta.hierarchical-instance.sv
    begin: (?<!\.\s*)(${identifier})\s*(\()\s*
    end: (\))\s*|${bracketsFailSafe}
    beginCaptures:
      "1": { name: variable.other.sv }
      "2": { name: punctuation.section.group.begin.sv }
    endCaptures:
      "1": { name: punctuation.section.group.end.sv }
    patterns:
      - include: "#list-of-port-connections"
      - include: "#module-instantiation"
  name-of-instance:
    patterns:
      - include: "#instance-identifier"
      - include: "#dimension"
  list-of-port-connections:
    patterns:
      - include: "#named-port-connection"
      - include: "#ordered-port-connection"
      - include: "#comma"
  ordered-port-connection:
    patterns:
      - include: "#attribute-instance"
      - include: "#expression"
  named-port-connection:
    name: meta.named-port-connection.sv
    begin: (\.)\s*(${identifier})\s*
    end: (?=\)|,)
    beginCaptures:
      "1": { name: punctuation.definition.named-port-connection.sv }
      "2": { name: variable.parameter.sv }
    patterns:
      - name: meta.named-port-connection.sv
        begin: (\()\s*
        end: (\))\s*|${bracketsFailSafe}
        beginCaptures:
          "1": { name: punctuation.section.group.begin.sv }
        endCaptures:
          "1": { name: punctuation.section.group.end.sv }
        patterns:
          - include: "#expression"
  # A.4.2 Generated instantiation
  generate-region:
    name: meta.generate-region.sv
    begin: \b(generate)\b\s*
    end: \b(endgenerate)\b\s*|${blocksFailSafe}
    beginCaptures:
      "1": { name: keyword.control.$1.sv }
    endCaptures:
      "1": { name: keyword.control.$1.sv }
    patterns:
      - include: "#generate-item"
  loop-generate-construct:
    patterns:
      - name: meta.loop-generate-construct.sv
        begin: \b(for)\b\s*(\()\s*
        end: (\))\s*|${bracketsFailSafe}
        beginCaptures:
          "1": { name: keyword.control.for.sv }
          "2": { name: punctuation.section.group.begin.sv }
        endCaptures:
          "1": { name: punctuation.section.group.end.sv }
        patterns:
          - include: "#genvar-initialization"
          - include: "#genvar-expression"
          - include: "#genvar-iteration"
          - include: "#semicolon"
  genvar-initialization:
    patterns:
      - match: \b(genvar)\b\s*
        captures:
          "1": { name: entity.name.type.$1.sv }
      - include: "#genvar-identifier"
  genvar-iteration:
    patterns:
      - include: "#genvar-identifier"
      - include: "#assignment-operator"
      - include: "#genvar-expression"
      - include: "#inc-or-dec-operator"
  conditional-generate-construct:
    patterns:
      - include: "#if-generate-construct"
      - include: "#case-generate-construct"
  if-generate-construct:
    patterns:
      - begin: \b(if)\b\s*(\()\s*
        end: (\))\s*|${bracketsFailSafe}
        beginCaptures:
          "1": { name: keyword.control.$1.sv }
          "2": { name: punctuation.section.group.begin.sv }
        endCaptures:
          "1": { name: punctuation.section.group.end.sv }
        patterns:
          - include: "#constant-expression"
      - match: \b(else)\b\s*
        captures:
          "1": { name: keyword.control.$1.sv }
  case-generate-construct:
    begin: (?=\b(case)\b)
    end: \b(endcase)\b\s*
    endCaptures:
      "1": { name: keyword.control.$1.sv }
    patterns:
      # Header
      - name: meta.case-generate-construct-header.sv
        begin: \b(case)\b\s*(\()\s*
        end: (?=\))
        beginCaptures:
          "1": { name: keyword.control.$1.sv }
          "2": { name: punctuation.section.group.begin.sv }
        patterns:
          - include: "#constant-expression"
      # Body
      - name: meta.case-generate-construct-body.sv
        begin: (\))\s*|${bracketsFailSafe}
        end: (?=\b(endcase)\b)
        beginCaptures:
          "1": { name: punctuation.section.group.end.sv }
        patterns:
          - include: "#case-generate-item"
  case-generate-item:
    patterns:
      - include: "#constant-expression"
      - include: "#colon"
      - include: "#generate-block"
      - match: \b(default)\b\s*
        captures:
          "1": { name: keyword.control.$1.sv }
  generate-block:
    patterns:
      # The seq-block and generate-block have the same beginning ('begin'). Therefore, include 'generate-item' in seq-block.
      - include: "#generate-item"
      - match: \b(${identifier})\s*(\:)\s*
        captures:
          "1": { name: variable.other.block.sv }
          "2": { name: punctuation.separator.colon.sv }
      - match: \b(begin)\b\s*
        captures:
          "1": { name: keyword.control.begin.sv }
      - match: \b(end)\b\s*
        captures:
          "1": { name: keyword.control.end.sv }
      - match: (\:)\s*(${identifier})\s*
        captures:
          "1": { name: punctuation.separator.colon.sv }
          "2": { name: variable.other.block.sv }
  generate-item:
    patterns:
      - include: "#module-or-generate-item"
      - include: "#interface-or-generate-item"
      - include: "#checker-or-generate-item"
  # A.6 Behavioral statements
  # A.6.1 Continuous assignment and net alias statements
  continuous-assign:
    patterns:
      - match: \b(assign)\b\s*
        captures:
          "1": { name: keyword.control.assign.sv }
      - include: "#drive-strength"
      - include: "#delay3"
      - include: "#delay-control"
      - include: "#list-of-net-assignments"
      - include: "#list-of-variable-assignments"
  # A.6.2 Procedural blocks and assignments
  initial-construct:
    patterns:
      - match: \b(initial)\b\s*
        captures:
          "1": { name: keyword.control.initial.sv }
      - include: "#statement-or-null"
  always-construct:
    patterns:
      - match: \b(always|always_comb|always_latch|always_ff)\b\s*
        captures:
          "1": { name: keyword.control.$1.sv }
      - include: "#statement"
  final-construct:
    patterns:
      - match: \b(final)\b\s*
        captures:
          "1": { name: keyword.control.final.sv }
      - include: "#function_statement"
  blocking-assignment:
    patterns:
      - include: "#equals"
      - include: "#assignment-operator"
  assignment-operator:
    patterns:
      - match: (=|\+=|-=|\*=|\/=|%=|&=|\|=|\^=|<<=|>>=|<<<=|>>>=)\s*(?!\=)
        captures:
          "1": { name: keyword.operator.assignment.sv }
  operator-assignment:
    patterns:
      - include: "#assignment-operator"
      - include: "#variable-lvalue"
      - include: "#expression"
  nonblocking-assignment:
    patterns:
      - match: (\<=)\s*
        captures:
          "1": { name: keyword.operator.assignment.sv }
  procedural-continuous-assignment:
    patterns:
      - match: \b(assign)\b\s*
        captures:
          "1": { name: keyword.control.assign.sv }
      - match: \b(deassign)\b\s*
        captures:
          "1": { name: keyword.control.deassign.sv }
      - match: \b(force)\b\s*
        captures:
          "1": { name: keyword.control.force.sv }
      - match: \b(release)\b\s*
        captures:
          "1": { name: keyword.control.release.sv }
      - include: "#variable-assignment"
      - include: "#net-assignment"
      - include: "#variable-lvalue"
      - include: "#net-lvalue"
  variable-assignment:
    patterns:
      - include: "#variable-lvalue"
      - include: "#equals"
      - include: "#expression"
  # A.6.3 Parallel and sequential blocks
  action-block:
    patterns:
      - match: \b(else)\b\s*
        captures:
          "1": { name: keyword.control.$1.sv }
  seq-block:
    name: meta.seq-block.sv
    begin: \b(begin)\b\s*(?:(\:)\s*(${identifier})\s*)?
    end: \b(end)\b\s*(?:(\:)\s*(${identifier})\s*)?|${itemsFailSafe}
    beginCaptures:
      "1": { name: keyword.control.begin.sv }
      "2": { name: punctuation.separator.colon.sv }
      "3": { name: variable.other.block.sv }
    endCaptures:
      "1": { name: keyword.control.end.sv }
      "2": { name: punctuation.separator.colon.sv }
      "3": { name: variable.other.block.sv }
    patterns:
      - include: "#generate-item"
      - include: "#block-item-declaration"
      - include: "#statement-or-null"
  par-block:
    begin: \b(fork)\b\s*(?:(\:)\s*(${identifier})\s*)?
    end: \b(join|join_any|join_none)\b\s*(?:(\:)\s*(${identifier})\s*)?|${itemsFailSafe}
    beginCaptures:
      "1": { name: keyword.control.fork.sv }
      "2": { name: punctuation.separator.colon.sv }
      "3": { name: variable.other.block.sv }
    endCaptures:
      "1": { name: keyword.control.$1.sv }
      "2": { name: punctuation.separator.colon.sv }
      "3": { name: variable.other.block.sv }
    patterns:
      - include: "#block-item-declaration"
      - include: "#statement-or-null"
  # A.6.4 Statements
  statement-or-null:
    patterns:
      - include: "#statement"
      - include: "#attribute-instance"
      - match: \;
        name: punctuation.terminator.semicolon.sv
  statement:
    patterns:
      - match: (?<!\.)(${identifier})\s*(\:)\s*
        captures:
          "1":
            patterns:
              - include: "#block-identifier"
          "2": { name: punctuation.separator.colon.sv }
      - include: "#attribute-instance"
      - include: "#statement-item"
  statement-item:
    patterns:
      - include: "#semicolon"
      - name: meta.assignments.sv
        begin: (\=)\s*(?!\=)
        end: ${assignmentEnd}
        beginCaptures:
          "1": { name: keyword.operator.assignment.sv }
        patterns:
          - include: "#expression"
          - include: "#dynamic-array-new"
          - include: "#class-new"
          - include: "#delay-or-event-control"
      - include: "#event-trigger"
      - include: "#blocking-assignment"
      - include: "#nonblocking-assignment"
      - include: "#procedural-continuous-assignment"
      - include: "#case-statement"
      - include: "#conditional-statement"
      - include: "#inc-or-dec-expression"
      - include: "#subroutine-call-statement"
      - include: "#disable-statement"
      # Conflict: The 'generate for' and 'for' statements have the same beginning. Therefore, they are combined here:
      - name: meta.for.sv
        begin: \b(for)\b\s*(\()\s*
        end: (\))\s*|${bracketsFailSafe}
        beginCaptures:
          "1": { name: keyword.control.for.sv }
          "2": { name: punctuation.section.group.begin.sv }
        endCaptures:
          "1": { name: punctuation.section.group.end.sv }
        patterns:
          - include: "#genvar-initialization"
          - include: "#genvar-iteration"
          - include: "#genvar-expression"
          - include: "#semicolon"
          - include: "#for-initialization"
          - include: "#for-step"
          - include: "#expression"
      - include: "#loop-statement"
      - include: "#jump-statement"
      - include: "#par-block"
      - include: "#procedural-timing-control-statement"
      - include: "#seq-block"
      - include: "#wait-statement"
      - include: "#procedural-assertion-statement"
      - include: "#clocking-drive"
      - include: "#randsequence-statement"
      - include: "#randcase-statement"
      - include: "#expect-property-statement"
      - include: "#expression"
  function-statement:
    patterns:
      - include: "#statement"
  function-statement-or-null:
    patterns:
      - include: "#function-statement"
      - include: "#attribute-instance"
      - include: "#semicolon"
  variable-identifier-list:
    patterns:
      - include: "#variable-identifier"
      - include: "#comma"
  # A.6.5 Timing control statements
  procedural-timing-control-statement:
    patterns:
      - include: "#delay-or-event-control"
  delay-or-event-control:
    patterns:
      - include: "#delay-control"
      - include: "#event-control"
      - begin: \b(repeat)\b\s*(\()\s*
        end: (\))\s*|${bracketsFailSafe}
        beginCaptures:
          "1": { name: keyword.control.$1.sv }
          "2": { name: punctuation.section.group.begin.sv }
        endCaptures:
          "1": { name: punctuation.section.group.end.sv }
        patterns:
          - include: "#expression"
  delay-control:
    patterns:
      - name: meta.delay-control.sv
        begin: (\#)\s*(\()\s*
        end: (\))\s*|${bracketsFailSafe}
        beginCaptures:
          "1": { name: punctuation.definition.parameter-assignment-or-delay.sv }
          "2": { name: punctuation.section.group.begin.sv }
        endCaptures:
          "1": { name: punctuation.section.group.end.sv }
        patterns:
          - include: "#list-of-parameter-assignments"
          - include: "#mintypmax-expression"
      - match: (\#)\s*
        captures:
          "1": { name: punctuation.definition.delay.sv }
      - include: "#delay-value"
  event-control:
    patterns:
      - name: meta.event-control.sv
        match: (\@)\s*(\*)\s*
        captures:
          "1": { name: punctuation.definition.event.sv }
          "2": { name: keyword.operator.wildcard.sv }
      - name: meta.event-control.sv
        match: (\@)\s*(\()\s*(\*)\s*(\))\s*
        captures:
          "1": { name: punctuation.definition.event.sv }
          "2": { name: punctuation.section.group.begin.sv }
          "3": { name: keyword.operator.wildcard.sv }
          "4": { name: punctuation.section.group.end.sv }
      - name: meta.event-control.sv
        begin: (\@)\s*(\()\s*
        end: (\))\s*|${bracketsFailSafe}
        beginCaptures:
          "1": { name: punctuation.definition.event.sv }
          "2": { name: punctuation.section.group.begin.sv }
        endCaptures:
          "1": { name: punctuation.section.group.end.sv }
        patterns:
          - include: "#event-expression"
      - match: (\@)\s*(${identifier})\s*
        captures:
          "1": { name: punctuation.definition.event.sv }
          "2": { name: variable.other.sv }
      - match: (\@)\s*
        captures:
          "1": { name: punctuation.definition.event.sv }
      - include: "#hierarchical-event-identifier"
      - include: "#ps-or-hierarchical-sequence-identifier"
  event-expression:
    patterns:
      - include: "#edge-identifier"
      - include: "#expression"
      - match: \b(iff)\b\s*
        captures:
          "1": { name: keyword.control.iff.sv }
      - include: "#sequence-instance"
      - match: \b(or)\b\s*
        captures:
          "1": { name: keyword.other.logical.sv }
      - include: "#comma"
      - begin: \(\s*
        end: \)\s*
        beginCaptures:
          "0": { name: punctuation.section.group.begin.sv }
        endCaptures:
          "0": { name: punctuation.section.group.end.sv }
        patterns:
          - include: "#event-expression"
  procedural-timing-control:
    patterns:
      - include: "#delay-control"
      - include: "#event-control"
      - include: "#cycle-delay"
  jump-statement:
    patterns:
      - match: \b(return)\b\s*
        captures:
          "1": { name: keyword.control.$1.sv }
      - include: "#expression"
      - match: \b(break|continue)\b\s*
        captures:
          "1": { name: keyword.control.$1.sv }
      - include: "#semicolon"
  wait-statement:
    patterns:
      - match: \b(wait)\b\s*\b(fork)\b\s*
        captures:
          "1": { name: keyword.control.$1.sv }
          "2": { name: keyword.control.$2.sv }
      - begin: \b(wait)\b\s*(?:(\()\s*)?
        end: (\))\s*|${bracketsFailSafe}
        beginCaptures:
          "1": { name: keyword.control.$1.sv }
          "2": { name: punctuation.section.group.begin.sv }
        endCaptures:
          "1": { name: punctuation.section.group.end.sv }
        patterns:
          - include: "#expression"
      - begin: \b(wait_order)\b\s*(?:(\()\s*)?
        end: (\))\s*|${bracketsFailSafe}
        beginCaptures:
          "1": { name: keyword.control.$1.sv }
          "2": { name: punctuation.section.group.begin.sv }
        endCaptures:
          "1": { name: punctuation.section.group.end.sv }
        patterns:
          - include: "#hierarchical-identifier"
          - include: "#comma"
      - include: "#action-block"
  event-trigger:
    patterns:
      - begin: (\-\>\>)\s*
        end: (\;)\s*|${itemsFailSafe}
        beginCaptures:
          "1": { name: punctuation.definition.event-trigger.sv }
        endCaptures:
          "1": { name: punctuation.terminator.semicolon.sv }
        patterns:
          - include: "#delay-or-event-control"
          - include: "#hierarchical-event-identifier"
      - begin: (\-\>)\s*
        end: (\;)\s*|${itemsFailSafe}
        beginCaptures:
          "1": { name: punctuation.definition.event-trigger.sv }
        endCaptures:
          "1": { name: punctuation.terminator.semicolon.sv }
        patterns:
          - include: "#hierarchical-event-identifier"
  disable-statement:
    patterns:
      - begin: \b(disable)\b\s*(?!\s*\biff\b)
        end: (\;)\s*|${statementsFailSafe}
        beginCaptures:
          "1": { name: keyword.control.disable.sv }
        endCaptures:
          "1": { name: punctuation.terminator.semicolon.sv }
        patterns:
          - match: \b(fork)\b\s*
            captures:
              "1": { name: keyword.control.$1.sv }
          - include: "#hierarchical-task-identifier"
          - include: "#hierarchical-block-identifier"
  # A.6.6 Conditional statements
  conditional-statement:
    patterns:
      - include: "#unique-priority"
      - name: meta.conditional-statement.sv
        begin: \b(if)\b\s*(?:(\()\s*)?
        beginCaptures:
          "1": { name: keyword.control.$1.sv }
          "2": { name: punctuation.section.group.begin.sv }
        end: (\))\s*|${bracketsFailSafe}
        endCaptures:
          "1": { name: punctuation.section.group.end.sv }
        patterns:
          - include: "#cond-predicate"
          - include: "#expression"
      - match: \b(else)\b\s*
        captures:
          "1": { name: keyword.control.$1.sv }
  unique-priority:
    match: (?<!\.)\b(unique|unique0|priority)\b\s*
    captures:
      "1": { name: keyword.control.$1.sv }
  cond-predicate:
    patterns:
      - match: (\&\&\&)\s*
        captures:
          "1": { name: keyword.operator.andandand.sv }
      - include: "#expression-or-cond-pattern"
  expression-or-cond-pattern:
    patterns:
      - include: "#cond-pattern"
  cond-pattern:
    name: meta.cond-pattern.sv
    begin: \b(matches)\b\s*
    end: (?=\&\&\&|\)|\?)
    beginCaptures:
      "1": { name: keyword.control.matches.sv }
    patterns:
      - include: "#pattern"
  # A.6.7 Case statements
  case-statement:
    patterns:
      - include: "#unique-priority"
      - name: meta.case-statement.sv
        begin: (?=\b(case|casex|casez)\b)
        end: \b(endcase)\b\s*|${itemsFailSafe}
        endCaptures:
          "1": { name: keyword.control.$1.sv }
        patterns:
          # Header
          - begin: \b(case|casex|casez)\b\s*(?:(\()\s*)?
            end: (?=\))|${bracketsFailSafe}
            beginCaptures:
              "1": { name: keyword.control.$1.sv }
              "2": { name: punctuation.section.group.begin.sv }
            patterns:
              - include: "#case-expression"
          # Body
          - begin: (\))\s*|${bracketsFailSafe}
            beginCaptures:
              "1": { name: punctuation.section.group.end.sv }
            end: (?=\b(endcase)\b)|${itemsFailSafe}
            patterns:
              - match: \b(matches)\b\s*
                captures:
                  "1": { name: keyword.control.matches.sv }
              - match: \b(inside)\b\s*
                captures:
                  "1": { name: keyword.control.$1.sv }
              - include: "#case-pattern-item"
              - include: "#case-item"
              - include: "#case-inside-item"
  case-keyword:
    match: \b(case|casex|casez)\b\s*
    captures:
      "1": { name: keyword.control.$1.sv }
  case-expression:
    patterns:
      - include: "#expression"
  case-item:
    patterns:
      - include: "#colon"
      - include: "#comma"
      - match: \b(default)\b\s*
        captures:
          "1": { name: keyword.control.$1.sv }
      - include: "#case-item-expression"
      - include: "#statement-or-null"
  case-pattern-item:
    patterns:
      - match: (\&\&\&)\s*
        captures:
          "1": { name: keyword.operator.andandand.sv }
      - include: "#colon"
      - match: \b(default)\b\s*
        captures:
          "1": { name: keyword.control.$1.sv }
      - include: "#pattern"
      - include: "#expression"
      - include: "#statement-or-null"
  case-inside-item:
    patterns:
      - include: "#colon"
      - match: \b(default)\b\s*
        captures:
          "1": { name: keyword.control.$1.sv }
      - include: "#open-range-list"
      - include: "#statement-or-null"
  case-item-expression:
    patterns:
      - include: "#expression"
  randcase-statement:
    begin: \b(randcase)\b\s*
    end: \b(endcase)\b\s*|${itemsFailSafe}
    beginCaptures:
      "1": { name: keyword.control.$1.sv }
    endCaptures:
      "1": { name: keyword.control.$1.sv }
    patterns:
      - include: "#randcase-item"
  randcase-item:
    patterns:
      - include: "#colon"
      - include: "#expression"
      - include: "#statement-or-null"
  open-range-list:
    patterns:
      - include: "#comma"
      - include: "#open-value-range"
  open-value-range:
    patterns:
      - include: "#value-range"
  # A.6.7.1 Patterns
  pattern:
    patterns:
      - match: (\.)\s*(${identifier})\s*
        captures:
          "1": { name: punctuation.definition.pattern.sv }
          "2": { name: variable.other.sv }
      - match: (\.\*)
        captures:
          "1": { name: punctuation.definition.wildcard.sv }
      - include: "#constant-expression"
      - match: \b(tagged)\b\s+(${identifier})\s*
        captures:
          "1": { name: keyword.other.tagged.sv }
          "2": { name: variable.other.enummember.sv }
      - include: "#assignment-pattern"
  assignment-pattern:
    name: meta.pattern.sv
    begin: (\'\{)\s*
    end: (\})\s*|${bracketsFailSafe}
    beginCaptures:
      "1": { name: punctuation.section.braces.begin.sv }
    endCaptures:
      "1": { name: punctuation.section.braces.end.sv }
    patterns:
      - include: "#pattern"
      # Replication case
      - name: meta.assignment-pattern-replication.sv
        begin: (?<=[^{,'\s])\s*(\{)\s*
        end: (\})\s*|${bracketsFailSafe}
        beginCaptures:
          "1": { name: punctuation.section.braces.begin.sv }
        endCaptures:
          "1": { name: punctuation.section.braces.end.sv }
        patterns:
          - include: "#comma"
          - include: "#expression"
      - name: meta.assignment-pattern-key-value.sv
        begin: (\:)\s*
        end: (?=\}|,)
        beginCaptures:
          "1": { name: punctuation.separator.colon.sv }
        patterns:
          - include: "#expression"
      # Special case for member identifier
      - match: (${identifier})\s*(?=\:)
        captures:
          "1": { name: variable.other.member.sv }
      - include: "#comma"
      - include: "#expression"
      - include: "#structure-pattern-key"
      - include: "#array-pattern-key"
  structure-pattern-key:
    patterns:
      - include: "#member-identifier"
      - include: "#assignment-pattern-key"
  array-pattern-key:
    patterns:
      - include: "#constant-expression"
      - include: "#assignment-pattern-key"
  assignment-pattern-key:
    patterns:
      - match: \b(default)\b
        name: keyword.other.default.sv
      - include: "#simple-type"
  assignment-pattern-expression:
    patterns:
      - include: "#assignment-pattern-expression-type"
      - include: "#assignment-pattern"
  assignment-pattern-expression-type:
    patterns:
      - include: "#ps-type-identifier"
      - include: "#ps-parameter-identifier"
      - include: "#integer-atom-type"
      - include: "#type-reference"
  constant-assignment-pattern-expression:
    patterns:
      - include: "#assignment-pattern-expression"
  assignment-pattern-net-lvalue:
    patterns:
      - name: meta.assignment-pattern-net-lvalue.sv
        begin: (\'\{)\s*
        end: (\})\s*|${bracketsFailSafe}
        beginCaptures:
          "1": { name: punctuation.section.braces.begin.sv }
        endCaptures:
          "1": { name: punctuation.section.braces.end.sv }
        patterns:
          - include: "#net-lvalue"
          - include: "#comma"
  assignment-pattern-variable-lvalue:
    patterns:
      - name: meta.assignment-pattern-variable-lvalue.sv
        begin: (\'\{)\s*
        end: (\})\s*|${bracketsFailSafe}
        beginCaptures:
          "0": { name: punctuation.section.braces.begin.sv }
        endCaptures:
          "0": { name: punctuation.section.braces.end.sv }
        patterns:
          - include: "#variable-lvalue"
          - include: "#comma"
  # A.6.8 Looping statements
  loop-statement:
    patterns:
      - match: \b(forever)\b\s*
        captures:
          "1": { name: keyword.control.$1.sv }
      - name: meta.loop-statement.sv
        begin: \b(repeat)\b\s*(?:(\()\s*)?
        end: (\))\s*|${bracketsFailSafe}
        beginCaptures:
          "1": { name: keyword.control.$1.sv }
          "2": { name: punctuation.section.group.begin.sv }
        endCaptures:
          "1": { name: punctuation.section.group.end.sv }
        patterns:
          - include: "#expression"
      - name: meta.loop-statement.sv
        begin: \b(while)\b\s*(?:(\()\s*)?
        end: (\))\s*|${bracketsFailSafe}
        beginCaptures:
          "1": { name: keyword.control.$1.sv }
          "2": { name: punctuation.section.group.begin.sv }
        endCaptures:
          "1": { name: punctuation.section.group.end.sv }
        patterns:
          - include: "#expression"
      - name: meta.loop-statement.sv
        begin: \b(for)\b\s*(?:(\()\s*)?
        end: (\))\s*|${bracketsFailSafe}
        beginCaptures:
          "1": { name: keyword.control.$1.sv }
          "2": { name: punctuation.section.group.begin.sv }
        endCaptures:
          "1": { name: punctuation.section.group.end.sv }
        patterns:
          - include: "#for-initialization"
          - include: "#expression"
          - include: "#for-step"
          - include: "#semicolon"
      - match: \b(do)\b\s*
        captures:
          "1": { name: keyword.control.$1.sv }
      - name: meta.loop-statement.sv
        begin: \b(foreach)\b\s*(?:(\()\s*)?
        end: (\))\s*|${bracketsFailSafe}
        beginCaptures:
          "1": { name: keyword.control.$1.sv }
          "2": { name: punctuation.section.group.begin.sv }
        endCaptures:
          "1": { name: punctuation.section.group.end.sv }
        patterns:
          - include: "#ps-or-hierarchical-array-identifier"
          - include: "#dimension"
  for-initialization:
    patterns:
      - include: "#list-of-variable-assignments"
      - include: "#for-variable-declaration"
  for-variable-declaration:
    patterns:
      - match: \b(var)\b\s*
        captures:
          "1": { name: storage.modifier.var.sv }
      - include: "#equals"
      - include: "#expression"
      - include: "#variable-identifier"
      - include: "#data-type"
      - include: "#comma"
  for-step:
    patterns:
      - include: "#for-step-assignment"
      - include: "#comma"
  for-step-assignment:
    patterns:
      - include: "#operator-assignment"
      - include: "#inc-or-dec-expression"
      - include: "#function-subroutine-call"
  loop-variables:
    patterns:
      - include: "#index-variable-identifier"
      - include: "#comma"
  # A.6.9 Subroutine call statements
  subroutine-call-statement:
    patterns:
      - include: "#subroutine-call"
  # A.6.10 Assertion statements
  assertion-item:
    patterns:
      - include: "#concurrent-assertion-item"
      - include: "#deferred-immediate-assertion-item"
  deferred-immediate-assertion-item:
    patterns:
      - match: (?<!\.)(${identifier})\s*(\:)\s*
        captures:
          "1": { name: variable.other.block.sv }
          "2": { name: punctuation.separator.colon.sv }
      - include: "#deferred-immediate-assertion-statement"
  procedural-assertion-statement:
    patterns:
      - include: "#concurrent-assertion-statement"
      - include: "#immediate-assertion-statement"
      - include: "#checker-instantiation"
  immediate-assertion-statement:
    patterns:
      - include: "#simple-immediate-assertion-statement"
      - include: "#deferred-immediate-assertion-statement"
  simple-immediate-assertion-statement:
    patterns:
      - include: "#simple-immediate-assert-statement"
      - include: "#simple-immediate-assume-statement"
      - include: "#simple-immediate-cover-statement"
  simple-immediate-assert-statement:
    patterns:
      - name: meta.assertion-statement.sv
        begin: \b(assert)\b\s*(?:(\()\s*)?
        end: (\))\s*|${bracketsFailSafe}
        beginCaptures:
          "1": { name: keyword.control.$1.sv }
          "2": { name: punctuation.section.group.begin.sv }
        endCaptures:
          "1": { name: punctuation.section.group.end.sv }
        patterns:
          - include: "#expression"
      - include: "#action-block"
  simple-immediate-assume-statement:
    patterns:
      - name: meta.assumption-statement.sv
        begin: \b(assume)\b\s*(?:(\()\s*)?
        end: (\))\s*|${bracketsFailSafe}
        beginCaptures:
          "1": { name: keyword.control.$1.sv }
          "2": { name: punctuation.section.group.begin.sv }
        endCaptures:
          "1": { name: punctuation.section.group.end.sv }
        patterns:
          - include: "#expression"
      - include: "#action-block"
  simple-immediate-cover-statement:
    patterns:
      - name: meta.cover-statement.sv
        begin: \b(cover)\b\s*(?:(\()\s*)?
        end: (\))\s*|${bracketsFailSafe}
        beginCaptures:
          "1": { name: keyword.control.$1.sv }
          "2": { name: punctuation.section.group.begin.sv }
        endCaptures:
          "1": { name: punctuation.section.group.end.sv }
        patterns:
          - include: "#expression"
  deferred-immediate-assertion-statement:
    patterns:
      - include: "#deferred-immediate-assert-statement"
      - include: "#deferred-immediate-assume-statement"
      - include: "#deferred-immediate-cover-statement"
  deferred-immediate-assert-statement:
    patterns:
      - name: meta.assertion-statement.sv
        begin: \b(assert)\b\s*(\#)\s*(0)\s*(?:(\()\s*)?
        end: (\))\s*|${bracketsFailSafe}
        beginCaptures:
          "1": { name: keyword.control.assert.sv }
          "2": { name: punctuation.definition.delay.sv }
          "3": { name: constant.numeric.integer.sv }
          "4": { name: punctuation.section.group.begin.sv }
        endCaptures:
          "1": { name: punctuation.section.group.end.sv }
        patterns:
          - include: "#expression"
      - name: meta.assertion-statement.sv
        begin: \b(assert)\b\s*\b(final)\b\s*(?:(\()\s*)?
        end: (\))\s*|${bracketsFailSafe}
        beginCaptures:
          "1": { name: keyword.control.assert.sv }
          "2": { name: keyword.control.final.sv }
          "3": { name: punctuation.section.group.begin.sv }
        endCaptures:
          "1": { name: punctuation.section.group.end.sv }
        patterns:
          - include: "#expression"
      - include: "#action-block"
  deferred-immediate-assume-statement:
    patterns:
      - name: meta.assumption-statement.sv
        begin: \b(assume)\b\s*(\#)\s*(0)\s*(?:(\()\s*)?
        end: (\))\s*|${bracketsFailSafe}
        beginCaptures:
          "1": { name: keyword.control.assume.sv }
          "2": { name: punctuation.definition.delay.sv }
          "3": { name: constant.numeric.integer.sv }
          "4": { name: punctuation.section.group.begin.sv }
        endCaptures:
          "1": { name: punctuation.section.group.end.sv }
        patterns:
          - include: "#expression"
      - name: meta.assumption-statement.sv
        begin: \b(assume)\b\s*\b(final)\b\s*(?:(\()\s*)?
        end: (\))\s*|${bracketsFailSafe}
        beginCaptures:
          "1": { name: keyword.control.assume.sv }
          "2": { name: keyword.control.final.sv }
          "3": { name: punctuation.section.group.begin.sv }
        endCaptures:
          "1": { name: punctuation.section.group.end.sv }
        patterns:
          - include: "#expression"
      - include: "#action-block"
  deferred-immediate-cover-statement:
    patterns:
      - name: meta.cover-statement.sv
        begin: \b(cover)\b\s*(\#)\s*(0)\s*(?:(\()\s*)?
        end: (\))\s*|${bracketsFailSafe}
        beginCaptures:
          "1": { name: keyword.control.cover.sv }
          "2": { name: punctuation.definition.delay.sv }
          "3": { name: constant.numeric.integer.sv }
          "4": { name: punctuation.section.group.begin.sv }
        endCaptures:
          "1": { name: punctuation.section.group.end.sv }
        patterns:
          - include: "#expression"
      - name: meta.cover-statement.sv
        begin: \b(cover)\b\s*\b(final)\b\s*(?:(\()\s*)?
        end: (\))\s*|${bracketsFailSafe}
        beginCaptures:
          "1": { name: keyword.control.cover.sv }
          "2": { name: keyword.control.final.sv }
          "3": { name: punctuation.section.group.begin.sv }
        endCaptures:
          "1": { name: punctuation.section.group.end.sv }
        patterns:
          - include: "#expression"
  # A.6.11 Clocking block
  clocking-declaration:
    name: meta.clocking-declaration.sv
    begin: (?:\b(default|global)\b\s+)?\b(clocking)\b\s*(?:(\b${identifier}\b)\s*)?
    end: \b(endclocking)\b\s*(?:(\:)\s*(${identifier})\s*)?|${blocksFailSafe}
    beginCaptures:
      "1": { name: storage.modifier.$1.sv }
      "2": { name: storage.type.clocking.sv }
      "3": { name: entity.name.type.sv }
    endCaptures:
      "1": { name: storage.type.clocking.sv }
      "2": { name: punctuation.separator.colon.sv }
      "3": { name: entity.name.type.sv }
    patterns:
      - include: "#clocking-event"
      - include: "#clocking-item"
  clocking-event:
    patterns:
      - name: meta.clocking-event.sv
        match: (\@)\s*(${identifier})\s*
        captures:
          "1": { name: punctuation.definition.event.sv }
          "2": { name: variable.other.sv }
      - name: meta.clocking-event.sv
        begin: (\@)\s*(\()\s*
        end: (\))\s*|${bracketsFailSafe}
        beginCaptures:
          "1": { name: punctuation.definition.event.sv }
          "2": { name: punctuation.section.group.begin.sv }
        endCaptures:
          "1": { name: punctuation.section.group.end.sv }
        patterns:
          - include: "#event-expression"
  clocking-item:
    patterns:
      - begin: \b(default)\b\s*
        end: (\;)\s*
        beginCaptures:
          "1": { name: storage.modifier.default.sv }
        endCaptures:
          "1": { name: punctuation.terminator.semicolon.sv }
        patterns:
          - include: "#default-skew"
      - include: "#clocking-direction"
      - include: "#list-of-clocking-decl-assign"
      - include: "#attribute-instance"
      - include: "#assertion-item-declaration"
      - include: "#semicolon"
  default-skew:
    patterns:
      - match: \b(input|output)\b\s*
        captures:
          "1": { name: storage.modifier.$1.sv }
      - include: "#clocking-skew"
  clocking-direction:
    patterns:
      - match: \b(inout)\b\s*
        captures:
          "1": { name: storage.modifier.$1.sv }
      - match: \b(input|output)\b\s*
        captures:
          "1": { name: storage.modifier.$1.sv }
      - include: "#clocking-skew"
  list-of-clocking-decl-assign:
    patterns:
      - include: "#clocking-decl-assign"
      - include: "#comma"
  clocking-decl-assign:
    patterns:
      - include: "#signal-identifier"
      - begin: (\=)\s*
        end: (?=\,|\;)
        beginCaptures:
          "1": { name: keyword.operator.assignment.sv }
        patterns:
          - include: "#expression"
  clocking-skew:
    patterns:
      - include: "#edge-identifier"
      - include: "#delay-control"
  clocking-drive:
    patterns:
      - include: "#clockvar-expression"
      - begin: (\<\=)\s*
        end: (?=\;)
        beginCaptures:
          "1": { name: keyword.operator.assignment.sv }
        patterns:
          - include: "#cycle-delay"
          - include: "#expression"
  cycle-delay:
    patterns:
      - match: (\#\#)\s*
        captures:
          "1": { name: keyword.operator.cycle-delay.sv }
      - include: "#integral-number"
      - include: "#identifier"
      - begin: (\#\#)\s*(\()\s*
        end: (\))\s*|${bracketsFailSafe}
        beginCaptures:
          "1": { name: keyword.operator.cycle-delay.sv }
          "2": { name: punctuation.section.group.begin.sv }
        endCaptures:
          "1": { name: punctuation.section.group.end.sv }
        patterns:
          - include: "#expression"
  clockvar:
    patterns:
      - include: "#hierarchical-identifier"
  clockvar-expression:
    patterns:
      - include: "#clockvar"
      - include: "#select"
  # A.6.12 Randsequence
  randsequence-statement:
    begin: (?=\b(randsequence)\b)
    end: \b(endsequence)\b\s*|${itemsFailSafe}
    endCaptures:
      "1": { name: keyword.control.$1.sv }
    patterns:
      - begin: \b(randsequence)\b\s*(?:(\()\s*)?
        end: (?=\))|${bracketsFailSafe}
        beginCaptures:
          "1": { name: keyword.control.$1.sv }
          "2": { name: punctuation.section.group.begin.sv }
        patterns:
          - include: "#production-identifier"
      - begin: (\))\s*|${bracketsFailSafe}
        end: (?=\b(endsequence)\b)|${itemsFailSafe}
        beginCaptures:
          "1": { name: punctuation.section.group.end.sv }
        patterns:
          - include: "#production"
  production:
    patterns:
      - begin: (\:)\s*
        end: (\;)\s*
        beginCaptures:
          "1": { name: punctuation.separator.colon.sv }
        endCaptures:
          "1": { name: punctuation.terminator.semicolon.sv }
        patterns:
          - match: (\|)\s*
            captures:
              "1": { name: punctuation.separator.bar.sv }
          - include: "#rs-rule"
      - begin: (\()\s*
        end: (\))\s*|${bracketsFailSafe}
        beginCaptures:
          "1": { name: punctuation.section.group.begin.sv }
        endCaptures:
          "1": { name: punctuation.section.group.end.sv }
        patterns:
          - include: "#tf-port-list"
      - include: "#production-identifier"
      - include: "#data-type-or-void"
  rs-rule:
    patterns:
      - begin: (\:=)\s*
        end: (?=\;|\|)
        beginCaptures:
          "1": { name: keyword.operator.assignment.sv }
        patterns:
          - include: "#weight-specification"
          - include: "#rs-code-block"
      - include: "#rs-production-list"
  rs-production-list:
    patterns:
      - match: \b(rand)\b\s+\b(join)\b\s*
        captures:
          "1": { name: keyword.control.rand.sv }
          "2": { name: keyword.control.join.sv }
      - include: "#rs-prod"
      - begin: (\()\s*
        end: (\))\s*|${bracketsFailSafe}
        beginCaptures:
          "1": { name: punctuation.section.group.begin.sv }
        endCaptures:
          "1": { name: punctuation.section.group.end.sv }
        patterns:
          - include: "#expression"
      - include: "#production-item"
  weight-specification:
    patterns:
      - include: "#integral-number"
      - include: "#ps-identifier"
      - begin: (\()\s*
        end: (\))\s*|${bracketsFailSafe}
        beginCaptures:
          "1": { name: punctuation.section.group.begin.sv }
        endCaptures:
          "1": { name: punctuation.section.group.end.sv }
        patterns:
          - include: "#expression"
  rs-code-block:
    patterns:
      # RS code block might contain statements. Cannot use bracketsFailSafe
      - begin: (\{)\s*
        end: (\})\s*|${itemsFailSafe}
        beginCaptures:
          "1": { name: punctuation.section.braces.begin.sv }
        endCaptures:
          "1": { name: punctuation.section.braces.end.sv }
        patterns:
          - include: "#data-declaration"
          - include: "#statement-or-null"
  rs-prod:
    patterns:
      - include: "#production-item"
      - include: "#rs-code-block"
      - include: "#rs-if-else"
      - include: "#rs-repeat"
      - include: "#rs-case"
  production-item:
    patterns:
      - include: "#production-identifier"
      - begin: (\()\s*
        end: (\))\s*|${bracketsFailSafe}
        beginCaptures:
          "1": { name: punctuation.section.group.begin.sv }
        endCaptures:
          "1": { name: punctuation.section.group.end.sv }
        patterns:
          - include: "#list-of-arguments"
  rs-if-else:
    patterns:
      - name: meta.rs-if-else.sv
        begin: \b(if)\b\s*(\()\s*
        end: (\))\s*|${bracketsFailSafe}
        beginCaptures:
          "1": { name: keyword.control.$1.sv }
          "2": { name: punctuation.section.group.begin.sv }
        endCaptures:
          "1": { name: punctuation.section.group.end.sv }
        patterns:
          - include: "#expression"
      - include: "#production-item"
      - match: \b(else)\b\s*
        captures:
          "1": { name: keyword.control.$1.sv }
      - include: "#production-item"
  rs-repeat:
    patterns:
      - name: meta.rs-repeat.sv
        begin: \b(repeat)\b\s*(?:(\()\s*)?
        end: (\))\s*|${bracketsFailSafe}
        beginCaptures:
          "1": { name: keyword.control.$1.sv }
          "2": { name: punctuation.section.group.begin.sv }
        endCaptures:
          "1": { name: punctuation.section.group.end.sv }
        patterns:
          - include: "#expression"
      - include: "#production-item"
  rs-case:
    begin: (?=\b(case)\b)
    end: \b(endcase)\b\s*
    endCaptures:
      "1": { name: keyword.control.$1.sv }
    patterns:
      - begin: \b(case)\b\s*(\()\s*
        end: (?=\))
        beginCaptures:
          "1": { name: keyword.control.$1.sv }
          "2": { name: punctuation.section.group.begin.sv }
        patterns:
          - include: "#case-expression"
      - begin: (\))\s*|${bracketsFailSafe}
        end: (?=\b(endcase)\b)
        beginCaptures:
          "1": { name: punctuation.section.group.end.sv }
        patterns:
          - include: "#rs-case-item"
  rs-case-item:
    patterns:
      - begin: (\:)\s*
        end: (\;)\s*
        beginCaptures:
          "1": { name: punctuation.separator.colon.sv }
        endCaptures:
          "1": { name: punctuation.terminator.semicolon.sv }
        patterns:
          - include: "#production-item"
      - match: \b(default)\b\s*
        captures:
          "1": { name: keyword.control.$1.sv }
      - include: "#case-item-expression"
  # A.7.4 Specify path delays
  edge-identifier:
    match: \b(posedge|negedge|edge)\b\s*
    captures:
      "1": { name: keyword.other.$1.sv }
  # A.8 Expressions
  # A.8.1 Concatenations
  concatenation:
    name: meta.concatenation.sv
    begin: (\{)\s*
    end: (\})\s*|${bracketsFailSafe}
    beginCaptures:
      "1": { name: punctuation.section.braces.begin.sv }
    endCaptures:
      "1": { name: punctuation.section.braces.end.sv }
    patterns:
      - include: "#bins-or-options"
      - include: "#stream-operator"
      - include: "#expression"
      - include: "#constant-expression"
      - include: "#slice-size"
      - include: "#stream-concatenation"
      - include: "#comma"
      - include: "#semicolon"
      - include: "#expression-or-dist"
      - include: "#covergroup-range-list"
  constant-concatenation:
    patterns:
      - include: "#concatenation"
  constant-multiple-concatenation:
    patterns:
      - include: "#constant-concatenation"
  module-path-concatenation:
    begin: (\{)\s*
    end: (\})\s*|${bracketsFailSafe}
    beginCaptures:
      "1": { name: punctuation.section.braces.begin.sv }
    endCaptures:
      "1": { name: punctuation.section.braces.end.sv }
    patterns:
      - include: "#module-path-expression"
      - include: "#comma"
  module-path-multiple-concatenation:
    patterns:
      - include: "#constant-expression"
      - include: "#module-path-concatenation"
  multiple-concatenation:
    patterns:
      - include: "#concatenation"
  streaming-concatenation:
    patterns:
      - include: "#concatenation"
  stream-operator:
    match: (>>|<<)\s*
    captures:
      "1": { name: keyword.operator.stream.sv }
  slice-size:
    patterns:
      - include: "#simple-type"
      - include: "#constant-expression"
  stream-concatenation:
    patterns:
      - include: "#stream-expression"
      - include: "#comma"
  stream-expression:
    patterns:
      - include: "#array-range-expression"
      - include: "#expression"
      - match: \b(with)\b\s*
        captures:
          "1": { name: keyword.control.with.sv }
  array-range-expression:
    patterns:
      - include: "#expression"
      - match: (\:)\s*
        captures:
          "1": { name: punctuation.separator.colon.sv }
      - match: (\+\:)\s*
        captures:
          "1": { name: punctuation.separator.pluscolon.sv }
      - match: (\-\:)\s*
        captures:
          "1": { name: punctuation.separator.minuscolon.sv }
  empty-unpacked-array-concatenation:
    patterns:
      - include: "#concatenation"
  # A.8.2 Subroutine calls
  constant-function-call:
    patterns:
      - include: "#function-subroutine-call"
  tf-call:
    name: meta.tf-call.sv
    begin: (?<!(?:${simpleIdentifier}|\))\s+)(${functionIdentifier}|\bnew\b)\s*(\()\s*
    end: (\))\s*|${bracketsFailSafe}
    beginCaptures:
      "1": { name: entity.name.function.sv }
      "2": { name: punctuation.section.group.begin.sv }
    endCaptures:
      "1": { name: punctuation.section.group.end.sv }
    patterns:
      - include: "#let-list-of-arguments"
      - include: "#list-of-arguments"
  system-tf-call:
    patterns:
      - name: meta.system-tf-call.sv
        begin: (\$[a-zA-Z0-9_\$]+)\b(\()\s*
        end: (\))\s*|{bracketsFailSafe}
        beginCaptures:
          "1": { name: entity.name.function.sv }
          "2": { name: punctuation.section.group.begin.sv }
        endCaptures:
          "1": { name: punctuation.section.group.end.sv }
        patterns:
          - include: "#list-of-arguments"
      - match: (\$[a-zA-Z0-9_\$]+)\b
        captures:
          "1": { name: entity.name.function.sv }
  subroutine-call:
    patterns:
      - include: "#system-tf-call"
      - include: "#tf-call"
      - include: "#method-call"
      - match: \b(std)\b\s*(\:\:)\s*
        captures:
          "1": { name: entity.name.function.sv }
          "2": { name: punctuation.separator.scope-resolution.sv }
      - include: "#randomize-call"
  function-subroutine-call:
    patterns:
      - include: "#subroutine-call"
  list-of-arguments:
    patterns:
      - begin: (?<!\w)(\.)\s*(${identifier})\s*(\()\s*
        end: (\))\s*|${bracketsFailSafe}
        beginCaptures:
          "1": { name: punctuation.definition.named-parameter-assignment.sv }
          "2": { name: variable.other.member.sv }
          "3": { name: punctuation.section.group.begin.sv }
        endCaptures:
          "1": { name: punctuation.section.group.end.sv }
        patterns:
          - include: "#expression"
      - include: "#comma"
      - include: "#expression"
      - include: "#data-type"
  method-call:
    patterns:
      - include: "#method-call-root"
      - include: "#dot"
      - include: "#method-call-body"
  method-call-body:
    patterns:
      - include: "#built-in-method-call"
  built-in-method-call:
    patterns:
      - include: "#array-manipulation-call"
      - include: "#randomize-call"
  array-manipulation-call:
    patterns:
      - begin: (${functionIdentifier}|\b(?:unique|and|or|xor))\b\s*(\()\s*
        end: (\))\s*|${bracketsFailSafe}
        beginCaptures:
          "1": { name: entity.name.function.sv }
          "2": { name: punctuation.section.group.begin.sv }
        endCaptures:
          "1": { name: punctuation.section.group.end.sv }
        patterns:
          - include: "#list-of-arguments"
      # - match: (${functionIdentifier}|\b(?:unique|and|or|xor))\b\s*(?=\bwith\b)
      #   captures:
      #     "1": { name: entity.name.function.sv }
      - begin: \b(with)\b\s*(\()\s*
        end: (\))\s*|${bracketsFailSafe}
        beginCaptures:
          "1": { name: keyword.control.with.sv }
          "2": { name: punctuation.section.group.begin.sv }
        endCaptures:
          "1": { name: punctuation.section.group.end.sv }
        patterns:
          - include: "#expression"
  randomize-call:
    patterns:
      - begin: \b(randomize)\b\s*(\()\s*
        end: (\))\s*|${bracketsFailSafe}
        beginCaptures:
          "1": { name: entity.name.function.sv }
          "2": { name: punctuation.section.group.begin.sv }
        endCaptures:
          "1": { name: punctuation.section.group.end.sv }
        patterns:
          - include: "#variable-identifier-list"
          - match: \b(null)\b\s*
            captures:
              "1": { name: constant.language.null.sv }
      - begin: \b(with)\b\s*(\()\s*
        end: (\))\s*|${bracketsFailSafe}
        beginCaptures:
          "1": { name: keyword.control.with.sv }
          "2": { name: punctuation.section.group.begin.sv }
        endCaptures:
          "1": { name: punctuation.section.group.end.sv }
        patterns:
          - include: "#identifier-list"
      - match: \b(with)\b\s*(?=\{)
        captures:
          "1": { name: keyword.control.with.sv }
      - include: "#constraint-block"
  method-call-root:
    patterns:
      - include: "#implicit-class-handle"
  array-method-name:
    match: \b(unique|and|or|xor|${functionIdentifier})\b\s*
    captures:
      "1": { name: entity.name.function.sv }
  # A.8.3 Expressions
  inc-or-dec-expression:
    patterns:
      - include: "#attribute-instance"
      - include: "#inc-or-dec-operator"
      - include: "#variable-lvalue"
  conditional-expression:
    patterns:
      - include: "#cond-predicate"
      - match: (\?)\s*
        captures:
          "1": { name: keyword.operator.ternary.sv }
      - include: "#attribute-instance"
      - match: (\:)\s*
        captures:
          "1": { name: punctuation.separator.colon.sv }
      - include: "#attribute-instance"
  constant-expression:
    patterns:
      - match: (\?)\s*
        captures:
          "1": { name: keyword.operator.ternary.sv }
      - match: (\:)\s*
        captures:
          "1": { name: punctuation.separator.colon.sv }
      - include: "#attribute-instance"
      - include: "#constant-primary"
      - include: "#binary-operator"
      - include: "#unary-operator"
      - include: "#attribute-instance"
  constant-mintypmax-expression:
    patterns:
      - match: (\:)\s*
        captures:
          "1": { name: punctuation.separator.colon.sv }
      - include: "#constant-expression"
  constant-param-expression:
    patterns:
      - match: (\$)\s*(?!\w)
        captures:
          "1": { name: variable.language.dollar.sv }
      - include: "#constant-mintypmax-expression"
      - include: "#data-type"
  param-expression:
    patterns:
      - match: (\$)\s*(?!\w)
        captures:
          "1": { name: variable.language.dollar.sv }
      - include: "#mintypmax-expression"
      - include: "#data-type"
  constant-range-expression:
    patterns:
      - include: "#constant-part-select-range"
      - include: "#constant-expression"
  constant-part-select-range:
    patterns:
      - include: "#constant-indexed-range"
      - include: "#constant-range"
  constant-range:
    patterns:
      - match: (\:)\s*
        captures:
          "1": { name: punctuation.separator.colon.sv }
      - include: "#constant-expression"
  constant-indexed-range:
    patterns:
      - match: (\+\:)\s*
        captures:
          "1": { name: punctuation.separator.pluscolon.sv }
      - match: (\-\:)\s*
        captures:
          "1": { name: punctuation.separator.minuscolon.sv }
      - include: "#constant-expression"
  expression:
    patterns:
      # This section of code handles the expression in different types of declarations,
      # such as data declaration and net declaration. By moving this code here, it
      # improves the organization of the syntax file.
      - name: meta.parenthesis.sv
        begin: (\()\s*(?!\s*\*)
        end: (\))\s*|${bracketsFailSafe}
        beginCaptures:
          "1": { name: punctuation.section.group.begin.sv }
        endCaptures:
          "1": { name: punctuation.section.group.end.sv }
        patterns:
          - include: "#list-of-arguments"
          - include: "#operator-assignment"
          - include: "#expression"
      - include: "#inc-or-dec-expression"
      - include: "#binary-operator"
      - include: "#unary-operator"
      - include: "#attribute-instance"
      - include: "#primary"
      - include: "#conditional-expression"
      - include: "#inside-expression"
      - include: "#tagged-union-expression"
  tagged-union-expression:
    match: \b(tagged)\b\s+(${identifier})\s*
    captures:
      "1": { name: keyword.other.tagged.sv }
      "2": { name: variable.other.enummember.sv }
  inside-expression:
    patterns:
      - match: \b(inside)\b\s*
        captures:
          "1": { name: keyword.other.inside.sv }
      - include: "#open-range-list"
  value-range:
    patterns:
      # - include: "#expression"
      - include: "#dimension"
  mintypmax-expression:
    patterns:
      - include: "#expression"
      - include: "#colon"
  module-path-conditional-expression:
    patterns:
      - match: (\?)\s*
        captures:
          "1": { name: keyword.operator.ternary.sv }
      - include: "#attribute-instance"
      - match: (\:)\s*
        captures:
          "1": { name: punctuation.separator.colon.sv }
      - include: "#module-path-expression"
  module-path-expression:
    patterns:
      - include: "#module-path-primary"
      - include: "#unary-module-path-operator"
      - include: "#binary-module-path-operator"
      - include: "#module-path-conditional-expression"
      - include: "#attribute-instance"
  module-path-mintypmax-expression:
    patterns:
      - include: "#module-path-expression"
      - include: "#colon"
  part-select-range:
    patterns:
      - include: "#constant-indexed-range"
      - include: "#constant-range"
  indexed-range:
    patterns:
      - match: (\+\:)\s*
        captures:
          "1": { name: punctuation.separator.pluscolon.sv }
      - match: (\-\:)\s*
        captures:
          "1": { name: punctuation.separator.minuscolon.sv }
      - include: "#constant-expression"
  genvar-expression:
    patterns:
      - include: "#constant-expression"
  # A.8.4 Primaries
  constant-primary:
    patterns:
      # Two special identifier for type casting:
      # 1. If the identifier starts with an uppercase letter, we guess it is a parameter name
      # 2. Otherwise, we guess it is a type name
      - match: (\b[A-Z][a-zA-Z0-9_\$]*)\s*(?=\')
        captures:
          "1": { name: variable.other.constant.sv }
      - match: (${simpleIdentifier})\s*(?=\')
        captures:
          "1": { name: entity.name.type.sv }
      - include: "#primary-literal"
      - include: "#ps-parameter-identifier"
      - include: "#constant-select"
      - include: "#specparam-identifier"
      - include: "#dimension"
      - include: "#genvar-identifier"
      - include: "#formal-port-identifier"
      - include: "#package-scope"
      - include: "#class-scope"
      - include: "#enum-identifier"
      - include: "#constant-concatenation"
      - include: "#constant-multiple-concatenation"
      - include: "#constant-function-call"
      - include: "#constant-let-expression"
      - begin: \(\s*
        end: \)\s*
        beginCaptures:
          "0": { name: punctuation.section.group.begin.sv }
        endCaptures:
          "0": { name: punctuation.section.group.end.sv }
        patterns:
          - include: "#constant-mintypmax-expression"
      - include: "#constant-cast"
      - include: "#constant-assignment-pattern-expression"
      - include: "#type-reference"
      - match: \b(null)\b\s*
        captures:
          "1": { name: constant.language.null.sv }
  module-path-primary:
    patterns:
      - include: "#number"
      - include: "#identifier"
      - include: "#module-path-concatenation"
      - include: "#module-path-multiple-concatenation"
      - include: "#function-subroutine-call"
      - begin: \(\s*
        end: \)\s*
        beginCaptures:
          "0": { name: punctuation.section.group.begin.sv }
        endCaptures:
          "0": { name: punctuation.section.group.end.sv }
        patterns:
          - include: "#module-path-mintypmax-expression"
  primary:
    patterns:
      # Two special identifier for type casting:
      # 1. If the identifier starts with an uppercase letter, we guess it is a parameter name
      # 2. Otherwise, we guess it is a type name
      - match: (\b[A-Z][a-zA-Z0-9_\$]*)\s*(?=\')
        captures:
          "1": { name: variable.other.constant.sv }
      - match: (${simpleIdentifier})\s*(?=\')
        captures:
          "1": { name: entity.name.type.sv }
      - include: "#primary-literal"
      - include: "#class-qualifier"
      - include: "#package-scope"
      - include: "#hierarchical-identifier"
      - include: "#select"
      - include: "#empty-unpacked-array-concatenation"
      - include: "#concatenation"
      - begin: (\[)\s*
        end: (\])\s*|${bracketsFailSafe}
        beginCaptures:
          "1": { name: punctuation.section.brackets.begin.sv }
        endCaptures:
          "1": { name: punctuation.section.brackets.end.sv }
        patterns:
          - include: "#range-expression"
      - include: "#function-subroutine-call"
      - include: "#let-expression"
      - begin: \(\s*
        end: \)\s*
        beginCaptures:
          "0": { name: punctuation.section.group.begin.sv }
        endCaptures:
          "0": { name: punctuation.section.group.end.sv }
        patterns:
          - include: "#mintypmax-expression"
      - include: "#cast"
      - include: "#assignment-pattern-expression"
      - include: "#streaming-concatenation"
      - include: "#sequence-method-call"
      - match: \b(this)\b\s*
        captures:
          "1": { name: variable.language.this.sv }
      - match: (\$)\s*(?!\w)
        captures:
          "1": { name: variable.language.dollar.sv }
      - match: \b(null)\b\s*
        captures:
          "1": { name: constant.language.null.sv }
  class-qualifier:
    patterns:
      - match: \b(local)\b\s*
        captures:
          "1": { name: entity.name.namespace.sv }
      - match: (\:\:)\s*
        captures:
          "1": { name: punctuation.separator.scope-resolution.sv }
      - include: "#dot"
      - include: "#implicit-class-handle"
      - include: "#class-scope"
  range-expression:
    patterns:
      - include: "#part-select-range"
      - include: "#expression"
  primary-literal:
    patterns:
      - include: "#string-literal"
      - include: "#time-literal"
      - include: "#unbased-unsized-literal"
      - include: "#number"
  time-literal:
    patterns:
      - name: meta.time-literal.sv
        match: \b([0-9][0-9_]*)\s*(s|ms|us|ns|ps|fs)\b
        captures:
          "1": { name: constant.numeric.integer.sv }
          "2": { name: constant.numeric.time-unit.sv }
      - name: meta.time-literal.sv
        match: \b([0-9_]+\.[0-9_]+)\s*(s|ms|us|ns|ps|fs)\b
        captures:
          "1": { name: constant.numeric.real.sv }
          "2": { name: constant.numeric.time-unit.sv }
      - include: "#number"
  time-unit:
    name: constant.numeric.time-unit.sv
    match: (?<=[0-9][0-9_]*\s*)(s|ms|us|ns|ps|fs)\b
  implicit-class-handle:
    match: \b(this|super)\b\s*
    captures:
      "1": { name: variable.language.$1.sv }
  bit-select:
    patterns:
      - include: "#dimension"
  select:
    patterns:
      - include: "#bit-select"
      - include: "#dimension"
      - include: "#dot"
      - include: "#member-identifier"
  nonrange-select:
    patterns:
      - include: "#bit-select"
      - include: "#dot"
      - include: "#member-identifier"
  constant-bit-select:
    patterns:
      - include: "#dimension"
  constant-select:
    patterns:
      - include: "#constant-bit-select"
      - include: "#dimension"
      - include: "#dot"
      - include: "#member-identifier"
  constant-cast:
    patterns:
      - include: "#casting-type"
      - begin: (\')\s*(\()\s*
        end: (\))\s*|${bracketsFailSafe}
        beginCaptures:
          "1": { name: punctuation.definition.casting.sv }
          "2": { name: punctuation.section.group.begin.sv }
        endCaptures:
          "1": { name: punctuation.section.group.end.sv }
        patterns:
          - include: "#constant-expression"
  constant-let-expression:
    patterns:
      - include: "#let-expression"
  cast:
    patterns:
      - include: "#casting-type"
      - begin: (\')\s*(\()\s*
        end: (\))\s*|${bracketsFailSafe}
        beginCaptures:
          "1": { name: punctuation.definition.casting.sv }
          "2": { name: punctuation.section.group.begin.sv }
        endCaptures:
          "1": { name: punctuation.section.group.end.sv }
        patterns:
          - include: "#expression"
  # A.8.6 Operators
  unary-operator:
    match: (~\^|\^~|~&|~\||\+|\-|!|~|&|\||\^)\s*(?!(\+|\-|\=))
    captures:
      "1": { name: keyword.operator.unary.sv }
  binary-operator:
    match: (?<!^|(?:\(|\:|=)\s*)(===|!==|==\?|==|!=\?|!=|&&|\|\||\*\*|<=|>=|\^~|~\^|\^~|>>>|<<<|>>|<<|->|<->|\+|\-|\*|\/|%|<|>|&|\||\^)\s*(?!(\+|\-|\=))
    captures:
      "1": { name: keyword.operator.binary.sv }
  inc-or-dec-operator:
    match: (\+\+|--)\s*
    captures:
      "1": { name: keyword.operator.incdec.sv }
  unary-module-path-operator:
    match: (~&|~\||~\^|\^~|!|~|&|\||\^)\s*
    captures:
      "1": { name: keyword.operator.unary.sv }
  binary-module-path-operator:
    match: (==|!=|&&|\|\||\^~|~\^|&|\||\^)\s*
    captures:
      "1": { name: keyword.operator.binary.sv }
  # A.8.7 Numbers
  number:
    name: meta.number.sv
    patterns:
      - include: "#integral-number"
      - include: "#real-number"
  integral-number:
    name: meta.integral-number.sv
    patterns:
      - include: "#octal-number"
      - include: "#binary-number"
      - include: "#hex-number"
      - include: "#decimal-number"
  decimal-number:
    patterns:
      - match: (\b[1-9][0-9_]*)?\s*(\')[sS]?[dD]\s*([0-9_xXzZ\?]+)
        name: constant.numeric.decimal.sv
      - match: (?<!\.)\b([0-9_]+)\b(?!\.)
        name: constant.numeric.integer.sv
  binary-number:
    match: (\b[1-9][0-9_]*)?\s*(\')[sS]?[bB]\s*([0-1_xXzZ\?]+)
    name: constant.numeric.binary.sv
  octal-number:
    match: (\b[1-9][0-9_]*)?\s*(\')[sS]?[oO]\s*([0-7_xXzZ\?]+)
    name: constant.numeric.octal.sv
  hex-number:
    match: (\b[1-9][0-9_]*)?\s*(\')[sS]?[hH]\s*([0-9a-fA-F_xXzZ\?]+)
    name: constant.numeric.hex.sv
  real-number:
    name: meta.real-number.sv
    patterns:
      - include: "#fixed-point-number"
      - match: (?<!\.)\b[0-9_]+(\.[0-9_]+)?[eE][+-]?[0-9_]+
        name: constant.numeric.real.sv
  fixed-point-number:
    match: \b[0-9_]+\.[0-9_]+\b
    name: constant.numeric.real.sv
  unbased-unsized-literal:
    match: (\'[01xXzZ])\b
    name: constant.numeric.unbased-unsized.sv
  # A.9 General
  # A.9.1 Attributes
  attribute-instance:
    name: meta.attribute-instance.sv
    begin: \(\*
    end: \*\)
    beginCaptures:
      "0": { name: punctuation.definition.attribute.begin.sv }
    endCaptures:
      "0": { name: punctuation.definition.attribute.end.sv }
    patterns:
      - include: "#att-spec"
      - include: "#comma"
  att-spec:
    name: meta.att-spec.sv
    begin: \b([a-zA-Z_][a-zA-Z0-9_]*)\s*(\=)?
    end: (?=(\*\))|\,)\s*
    beginCaptures:
      "1": { name: entity.other.attribute-name.sv }
      "2": { name: keyword.operator.assignment.sv }
    patterns:
      - include: "#constant-expression"
  # A.8.8 Strings
  string-literal:
    name: string.quoted.double.sv
    begin: \"
    end: \"
    beginCaptures:
      "0": { name: punctuation.definition.string.begin.sv }
    endCaptures:
      "0": { name: punctuation.definition.string.end.sv }
    patterns:
      - match: (?:\\u[0-9a-fA-F]{4}|\\U[0-9a-fA-F]{8})
        name: constant.character.escape.sv
      - match: (?:\\[abfnrtv\\\"\'\?])
        name: constant.character.escape.sv
      - match: (?:\\[0-7]{1,3})
        name: constant.character.escape.sv
      - match: (?:\\x[0-9a-fA-F]{1,2})
        name: constant.character.escape.sv
      - match: \%(\d+\$)?[#0\- +']*[,;:_]?((-?\d+)|\*(-?\d+\$)?)?(\.((-?\d+)|\*(-?\d+\$)?)?)?(hh|h|ll|l|j|t|z|q|L|vh|vl|v|hv|hl)?[hHxXdDoObBcClLvVmMpPsStTuUzZieEfFgGaAn%]
        name: constant.other.placeholder.sv
      - match: \\\n
        name: punctuation.separator.continuation.sv
  # A.9.2 Comments
  comment:
    patterns:
      - include: "#line-comment"
      - include: "#block-comment"
  line-comment:
    name: comment.line.sv
    match: (//)(.*)
    captures:
      "1": { name: punctuation.definition.comment.sv }
  block-comment:
    name: comment.block.sv
    begin: /\*
    end: \*/
    beginCaptures:
      "0": { name: punctuation.definition.comment.sv }
    endCaptures:
      "0": { name: punctuation.definition.comment.sv }
  # A.9.3 Identifiers
  array-identifier:
    patterns:
      - include: "#identifier"
  block-identifier:
    patterns:
      - include: "#identifier"
  bin-identifier:
    patterns:
      - include: "#identifier"
  c-identifier:
    match: \b([a-zA-Z_][a-zA-Z0-9_]*)\b\s*
    captures:
      "1": { name: variable.other.sv }
  cell-identifier:
    patterns:
      - include: "#identifier"
  checker-identifier:
    patterns:
      - include: "#identifier"
  class-identifier:
    match: ${classIdentifierStart}(${identifier})\s*${classIdentifierEnd}
    captures:
      "1": { name: entity.name.type.sv }
  class-variable-identifier:
    patterns:
      - include: "#variable-identifier"
  clocking-identifier:
    patterns:
      - include: "#identifier"
  config-identifier:
    patterns:
      - include: "#identifier"
  const-identifier:
    patterns:
      - include: "#identifier"
  constraint-identifier:
    patterns:
      - include: "#identifier"
  covergroup-identifier:
    match: ${typeIdentifierStart}(${identifier})\s*${typeIdentifierEnd}
    captures:
      "1": { name: entity.name.type.sv }
  covergroup-variable-identifier:
    patterns:
      - include: "#variable-identifier"
  cover-point-identifier:
    patterns:
      - include: "#identifier"
  cross-identifier:
    patterns:
      - include: "#identifier"
  dynamic-array-variable-identifier:
    patterns:
      - include: "#variable-identifier"
  enum-identifier:
    patterns:
      - include: "#identifier"
  escaped-identifier:
    match: \\[^\s]+\s*
    name: variable.other.sv
  formal-identifier:
    patterns:
      - include: "#identifier"
  formal-port-identifier:
    patterns:
      - include: "#identifier"
  function-identifier:
    match: (${functionIdentifier})\s*${functionIdentifierEnd}
    captures:
      "1": { name: entity.name.function.sv }
  generate-block-identifier:
    patterns:
      - include: "#identifier"
  genvar-identifier:
    patterns:
      - include: "#identifier"
  hierarchical-array-identifier:
    patterns:
      - include: "#hierarchical-identifier"
  hierarchical-block-identifier:
    patterns:
      - include: "#hierarchical-identifier"
  hierarchical-event-identifier:
    patterns:
      - include: "#hierarchical-identifier"
  hierarchical-identifier:
    patterns:
      - match: (\$root)\s*(\.)\s*
        captures:
          "1": { name: variable.language.root.sv }
          "2": { name: punctuation.accessor.dot.sv }
      - match: (\$root)\s*
        captures:
          "1": { name: variable.language.root.sv }
      - include: "#dot"
      - include: "#identifier"
  hierarchical-net-identifier:
    patterns:
      - include: "#hierarchical-identifier"
  hierarchical-parameter-identifier:
    patterns:
      - include: "#hierarchical-identifier"
  hierarchical-property-identifier:
    patterns:
      - include: "#hierarchical-identifier"
  hierarchical-sequence-identifier:
    patterns:
      - include: "#hierarchical-identifier"
  hierarchical-task-identifier:
    patterns:
      - include: "#hierarchical-identifier"
  hierarchical-tf-identifier:
    patterns:
      - include: "#hierarchical-identifier"
  hierarchical-variable-identifier:
    patterns:
      - include: "#hierarchical-identifier"
  identifier:
    patterns:
      # For built-in methods, we use an educated guess to highlight them as functions
      # 1. Associative array methods: num, size, delete, exists, first, last, next, prev
      # 2. Queue: size, insert, delete, pop_front, pop_back, push_front, push_back
      # 3. Array locator: find, find_index, find_first, find_first_index, find_last, find_last_index, min, max, unique, unique_index
      # 4. Array ordering: reverse, sort, rsort, shuffle
      # 5. Array reduction: sum, product, and, or, xor
      # 6. Iterator index querying: index
      # 7. randomize method: randomize, pre_randomize, post_randomize, rand_mode, constraint_mode, srandom, get_randstate, set_randstate
      - match: (?<=\.)\b(num|size|delete|exists|first|last|next|prev|insert|pop_front|pop_back|push_front|push_back|find|find_index|find_first|find_first_index|find_last|find_last_index|min|max|unique|unique_index|reverse|sort|rsort|shuffle|sum|product|and|or|xor|index|randomize|pre_randomize|post_randomize|rand_mode|constraint_mode|srandom|get_randstate|set_randstate)\b(?!\s*\=)
        captures:
          "1": { name: entity.name.function.sv }
      - match: \b([A-Z][a-zA-Z0-9_$]*)\b\s*${identifierEnd}
        captures:
          "1": { name: variable.other.constant.sv }
      - match: \b(t_[a-zA-Z0-9_]*|e_[a-zA-Z0-9_]*|[a-zA-Z0-9_]*_t|[a-zA-Z0-9_]*_e)\b\s*
        captures:
          "1": { name: entity.name.type.sv }
      - match: (${identifier})\s*${identifierEnd}
        captures:
          "1": { name: variable.other.sv }
  index-variable-identifier:
    patterns:
      - include: "#identifier"
  interface-instance-identifier:
    patterns:
      - include: "#identifier"
  interface-identifier:
    patterns:
      - include: "#identifier"
  inout-port-identifier:
    patterns:
      - include: "#identifier"
  input-port-identifier:
    patterns:
      - include: "#identifier"
  instance-identifier:
    match: (${identifier})\s*
    captures:
      "1": { name: variable.other.sv }
  library-identifier:
    patterns:
      - include: "#identifier"
  member-identifier:
    patterns:
      - include: "#identifier"
  method-identifier:
    patterns:
      - include: "#identifier"
  modport-identifier:
    patterns:
      - include: "#identifier"
  module-identifier:
    match: (?<!\#\s*)(${identifier})(?=\s+${identifier})
    captures:
      "1": { name: entity.name.type.sv }
  net-identifier:
    patterns:
      - include: "#identifier"
  net-type-identifier:
    match: ${typeIdentifierStart}(${identifier})\s*${typeIdentifierEnd}
    captures:
      "1": { name: entity.name.type.sv }
  output-port-identifier:
    patterns:
      - include: "#identifier"
  package-identifier:
    patterns:
      - include: "#identifier"
  package-scope:
    patterns:
      - match: (\$unit)\s*
        captures:
          "1": { name: entity.name.namespace.sv }
      - match: (${identifier})\s*(::)\s*
        captures:
          "1": { name: entity.name.namespace.sv }
          "2": { name: punctuation.separator.scope-resolution.sv }
  parameter-identifier:
    match: (${identifier})\s*${identifierEnd}
    captures:
      "1": { name: variable.other.constant.sv }
  port-identifier:
    patterns:
      - include: "#identifier"
  production-identifier:
    patterns:
      - match: (${identifier})\s*(?=\()
        name: entity.name.function.sv
      - match: (${identifier})\s*
        name: variable.other.sv
  program-identifier:
    patterns:
      - include: "#type-identifier"
  property-identifier:
    patterns:
      - include: "#type-identifier"
  ps-class-identifier:
    patterns:
      - include: "#package-scope"
      - include: "#class-identifier"
  ps-covergroup-identifier:
    patterns:
      - include: "#package-scope"
      - include: "#covergroup-identifier"
  ps-checker-identifier:
    patterns:
      - include: "#package-scope"
      - include: "#checker-identifier"
  ps-identifier:
    patterns:
      - include: "#package-scope"
      - include: "#identifier"
  ps-or-hierarchical-array-identifier:
    patterns:
      - include: "#implicit-class-handle"
      - include: "#dot"
      - include: "#class-scope"
      - include: "#package-scope"
      - include: "#hierarchical-array-identifier"
  ps-or-hierarchical-net-identifier:
    patterns:
      - include: "#package-scope"
      - include: "#net-identifier"
      - include: "#hierarchical-net-identifier"
  ps-or-hierarchical-property-identifier:
    patterns:
      - include: "#package-scope"
      - include: "#property-identifier"
      - include: "#hierarchical-property-identifier"
  ps-or-hierarchical-sequence-identifier:
    patterns:
      - include: "#package-scope"
      - include: "#sequence-identifier"
      - include: "#hierarchical-sequence-identifier"
  ps-or-hierarchical-tf-identifier:
    patterns:
      - include: "#package-scope"
      - include: "#tf-identifier"
      - include: "#hierarchical-tf-identifier"
  ps-parameter-identifier:
    patterns:
      - include: "#package-scope"
      - include: "#class-scope"
      - include: "#generate-block-identifier"
      - include: "#dimension"
      - include: "#dot"
      - include: "#parameter-identifier"
  ps-type-identifier:
    patterns:
      - match: (\b(local)\b)\s*(::)\s*
        captures:
          "1": { name: keyword.other.local.sv }
          "2": { name: punctuation.separator.scope-resolution.sv }
      - include: "#package-scope"
      - include: "#class-scope"
      - include: "#type-identifier"
  sequence-identifier:
    patterns:
      - include: "#type-identifier"
  signal-identifier:
    patterns:
      - include: "#identifier"
  simple-identifier:
    name: variable.other.sv
    match: ${simpleIdentifier}
  specparam-identifier:
    patterns:
      - include: "#parameter-identifier"
  system-tf-identifier:
    match: (\$[a-zA-Z0-9_\$]+)\b
    captures:
      "1": { name: entity.name.function.sv }
  task-identifier:
    match: (${functionIdentifier})\s*${functionIdentifierEnd}
    captures:
      "1": { name: entity.name.function.sv }
  tf-identifier:
    match: (${functionIdentifier})\s*${functionIdentifierEnd}
    captures:
      "1": { name: entity.name.function.sv }
  terminal-identifier:
    patterns:
      - include: "#identifier"
  topmodule-identifier:
    patterns:
      - include: "#identifier"
  type-identifier:
    match: ${typeIdentifierStart}(${identifier})\s*${typeIdentifierEnd}
    captures:
      "1": { name: entity.name.type.sv }
  udp-identifier:
    patterns:
      - include: "#identifier"
  variable-identifier:
    patterns:
      - include: "#identifier"
  # Compiler directives
  compiler-directive:
    patterns:
      - include: "#macro-resetall"
      - include: "#macro-include"
      - include: "#macro-define"
      - include: "#macro-undefineall"
      - include: "#macro-undef"
      - include: "#macro-ifdef"
      - include: "#macro-elsif"
      - include: "#macro-else"
      - include: "#macro-ifndef"
      - include: "#macro-endif"
      - include: "#macro-timescale"
      - include: "#macro-default-nettype"
      - include: "#macro-unconnected-drive"
      - include: "#macro-nounconnected-drive"
      - include: "#macro-celldefine"
      - include: "#macro-endcelldefine"
      - include: "#macro-pragma"
      - include: "#macro-line"
      - include: "#macro-begin-keywords"
      - include: "#macro-end-keywords"
      - include: "#macro-__line__"
      - include: "#macro-__file__"
      - include: "#text-macro-usage"
  macro-resetall:
    match: (`resetall)\b
    name: keyword.control.resetall.sv
  macro-include:
    begin: (`include)\b\s*
    end: $
    beginCaptures:
      "1": { name: keyword.control.include.sv }
    patterns:
      - match: ("[^"]*")
        name: string.quoted.double.sv
      - match: (<[^>]*>)
        name: string.quoted.angle.include.sv
      - include: "#text-macro-usage"
      # Match and highlight variable names within the macro function
      - match: \b([a-zA-Z_][a-zA-Z0-9_$]*)\b
        name: variable.other.sv
  macro-define:
    patterns:
      # Oneline
      - name: meta.macro-definition.sv
        match: (`define)\b\s*\b([a-zA-Z_][a-zA-Z0-9_$]*)\b\s*([^\\]*[^\\ ])$
        captures:
          "1": { name: keyword.control.define.sv }
          "2": { name: meta.preprocessor.macro-name.sv }
          "3":
            patterns:
              - include: "#comment"
              - begin: (\()\s*
                end: (\))\s*|${bracketsFailSafe}
                beginCaptures:
                  "1": { name: punctuation.section.group.begin.sv }
                endCaptures:
                  "1": { name: punctuation.section.group.end.sv }
                patterns:
                  - include: "#formal-argument"
                  - include: "#comma"
              - include: "#macro-text"
              - include: "#compiler-directive"
      # Multiline
      - name: meta.macro-definition.sv
        begin: (`define)\b\s*\b([a-zA-Z_][a-zA-Z0-9_\$]*)\b\s*
        end: (?<!\\\s*)$
        beginCaptures:
          "1": { name: keyword.control.define.sv }
          "2": { name: meta.preprocessor.macro-name.sv }
        patterns:
          - begin: (\()\s*
            end: (\))\s*|${bracketsFailSafe}
            beginCaptures:
              "1": { name: punctuation.section.group.begin.sv }
            endCaptures:
              "1": { name: punctuation.section.group.end.sv }
            patterns:
              - include: "#formal-argument"
              - include: "#comma"
          - include: "#macro-continuation"
          - include: "#macro-text"
      - name: meta.macro-definition.sv
        match: (`define)\b\s*
        captures:
          "1": { name: keyword.control.define.sv }
  macro-continuation:
    match: \\
    name: punctuation.separator.continuation.sv
  macro-text:
    patterns:
      # Escaped quotation mark
      - name: string.quoted.macro.sv
        begin: \`\"
        end: \`\"
        beginCaptures:
          "0": { name: constant.character.escape.sv }
        endCaptures:
          "0": { name: constant.character.escape.sv }
        patterns:
          - match: \`\`
            name: constant.character.escape.sv
          - match: \`\\\`\"
            name: constant.character.escape.sv
          - match: (?:\\u[0-9a-fA-F]{4}|\\U[0-9a-fA-F]{8})
            name: constant.character.escape.sv
          - match: (?:\\[abfnrtv\\\"\'\?])
            name: constant.character.escape.sv
          - match: (?:\\[0-7]{1,3})
            name: constant.character.escape.sv
          - match: (?:\\x[0-9a-fA-F]{1,2})
            name: constant.character.escape.sv
          - match: \%(\d+\$)?[#0\- +']*[,;:_]?((-?\d+)|\*(-?\d+\$)?)?(\.((-?\d+)|\*(-?\d+\$)?)?)?(hh|h|ll|l|j|t|z|q|L|vh|vl|v|hv|hl)?[hHxXdDoObBcClLvVmMpPsStTuUzZieEfFgGaAn%]
            name: constant.other.placeholder.sv
          - match: \\\n
            name: punctuation.separator.continuation.sv
      - match: ((?<!\\|\$)\b[a-zA-Z_][`a-zA-Z0-9_\$]*\b|\\\S+(?=\s|$))(?<!\b(?:accept_on|alias|always|always_comb|always_ff|always_latch|and|assert|assign|assume|automatic|before|begin|bind|bins|binsof|bit|break|buf|bufif0|bufif1|byte|case|casex|casez|cell|chandle|checker|class|clocking|cmos|config|const|constraint|context|continue|cover|covergroup|coverpoint|cross|deassign|default|defparam|design|disable|dist|do|edge|else|end|endcase|endchecker|endclass|endclocking|endconfig|endfunction|endgenerate|endgroup|endinterface|endmodule|endpackage|endprimitive|endprogram|endproperty|endspecify|endsequence|endtable|endtask|enum|event|eventually|expect|export|extends|extern|final|first_match|for|force|foreach|forever|fork|forkjoin|function|generate|genvar|global|highz0|highz1|if|iff|ifnone|ignore_bins|illegal_bins|implements|implies|import|incdir|include|initial|inout|input|inside|instance|int|integer|interconnect|interface|intersect|join|join_any|join_none|large|let|liblist|library|local|localparam|logic|longint|macromodule|matches|medium|modport|module|nand|negedge|nettype|new|nexttime|nmos|nor|noshowcancelled|not|notif0|notif1|null|or|output|package|packed|parameter|pmos|posedge|primitive|priority|program|property|protected|pull0|pull1|pulldown|pullup|pulsestyle_ondetect|pulsestyle_onevent|pure|rand|randc|randcase|randsequence|rcmos|real|realtime|ref|reg|reject_on|release|repeat|restrict|return|rnmos|rpmos|rtran|rtranif0|rtranif1|s_always|s_eventually|s_nexttime|s_until|s_until_with|scalared|sequence|shortint|shortreal|showcancelled|signed|small|soft|solve|specify|specparam|static|string|strong|strong0|strong1|struct|super|supply0|supply1|sync_accept_on|sync_reject_on|table|tagged|task|this|throughout|time|timeprecision|timeunit|tran|tranif0|tranif1|tri|tri0|tri1|triand|trior|trireg|type|typedef|union|unique|unique0|unsigned|until|until_with|untyped|use|uwire|var|vectored|virtual|void|wait|wait_order|wand|weak|weak0|weak1|while|wildcard|wire|with|within|wor|xnor|xor)\b)
        captures:
          "1":
            name: variable.other.sv
            patterns:
              - match: \`\`
                name: constant.character.escape.sv
      - include: "#module-item"
      - include: "#interface-item"
      - include: "#program-item"
      - include: "#checker-item"
      - include: "#package-item"
      - include: "#class-item"
      - include: "#interface-class-item"
      - include: "#interface-item"
      - include: "#expression"
      - include: "#gate-instantiation"
  formal-argument:
    patterns:
      - match: \b([a-zA-Z_][a-zA-Z0-9_\$]*)\b
        name: variable.other.sv
      - include: "#equals"
      - include: "#expression"
  text-macro-usage:
    patterns:
      # Macro function
      - begin: (${macro})\s*(\()\s*
        end: (\))\s*|${bracketsFailSafe}
        beginCaptures:
          "1": { name: meta.preprocessor.macro-name.sv }
          "2": { name: punctuation.section.group.begin.sv }
        endCaptures:
          "1": { name: punctuation.section.group.end.sv }
        patterns:
          - include: "#expression"
          - include: "#comma"
      # Macro variable
      - match: (${macro})\s*(?!\s*[(])
        name: meta.preprocessor.text-macro-usage.sv meta.preprocessor.macro-name.sv
  macro-undef:
    match: (`undef)\b\s*(?:([a-zA-Z_][a-zA-Z0-9_\$]*)\s*)?
    captures:
      "1": { name: keyword.control.undef.sv }
      "2": { name: meta.preprocessor.macro-name.sv }
  macro-undefineall:
    match: (`undefineall)\b
    name: keyword.control.undefineall.sv
  macro-ifdef:
    match: (`ifdef)\b\s*(?:([a-zA-Z_][a-zA-Z0-9_\$]*)\s*)?
    captures:
      "1": { name: keyword.control.ifdef.sv }
      "2": { name: meta.preprocessor.macro-name.sv }
  macro-elsif:
    match: (`elsif)\b\s*(?:([a-zA-Z_][a-zA-Z0-9_\$]*)\s*)?
    captures:
      "1": { name: keyword.control.elsif.sv }
      "2": { name: meta.preprocessor.macro-name.sv }
  macro-else:
    match: (`else)\b
    name: keyword.control.else.sv
  macro-ifndef:
    match: (`ifndef)\b\s*(?:([a-zA-Z_][a-zA-Z0-9_\$]*)\s*)?
    captures:
      "1": { name: keyword.control.ifndef.sv }
      "2": { name: meta.preprocessor.macro-name.sv }
  macro-endif:
    match: (`endif)\b
    name: keyword.control.endif.sv
  macro-timescale:
    begin: (`timescale)\b\s*
    end: $
    beginCaptures:
      "1": { name: keyword.control.timescale.sv }
    patterns:
      - match: \/
        name: punctuation.separator.slash.sv
      - include: "#time-literal"
  macro-default-nettype:
    match: (`default_nettype)\b\s*(?:\b(wire|tri|tri0|tri1|wand|triand|wor|trior|trireg|uwire|none)\b)?
    captures:
      "1": { name: keyword.control.default-nettype.sv }
      "2": { name: entity.name.type.$2.sv }
  macro-nounconnected-drive:
    match: (`nounconnected_drive)\b\s*
    captures:
      "1": { name: keyword.control.nounconnected-drive.sv }
  macro-unconnected-drive:
    match: (`unconnected_drive)\b\s*(?:\b(pull0|pull1)\b)?\s*
    captures:
      "1": { name: keyword.control.unconnected-drive.sv }
      "2": { name: storage.modifier.$2.sv }
  macro-celldefine:
    match: (`celldefine)\b
    name: keyword.control.celldefine.sv
  macro-endcelldefine:
    match: (`endcelldefine)\b
    name: keyword.control.endcelldefine.sv
  macro-pragma:
    begin: (`pragma)\b\s*(?:\b([a-zA-Z_][a-zA-Z0-9_$]*)\b\s*)?
    beginCaptures:
      "1": { name: keyword.control.pragma.sv }
      "2": { name: entity.other.attribute-name.sv }
    end: $
    patterns:
      - include: "#comma"
      - include: "#pragma-expression"
  pragma-expression:
    patterns:
      - begin: (${simpleIdentifier})\s*(\=)\s*
        beginCaptures:
          "1": { name: entity.other.attribute-name.sv }
          "2": { name: keyword.operator.assignment.sv }
        end: (?=\,|\)|$)
        patterns:
          - include: "#pragma-value"
      - include: "#pragma-value"
  pragma-value:
    patterns:
      - begin: (\()\s*
        end: (\))\s*|${bracketsFailSafe}
        beginCaptures:
          "1": { name: punctuation.section.group.begin.sv }
        endCaptures:
          "1": { name: punctuation.section.group.end.sv }
        patterns:
          - include: "#comma"
          - include: "#pragma-expression"
      - include: "#number"
      - include: "#unary-operator"
      - include: "#string-literal"
      - include: "#simple-identifier"
  macro-line:
    patterns:
      - match: (`line)\b\s*(?:\b([0-9]+)\b\s*)?(?:([^"\s]+)\s*)?(?:\b([0-9]+)\b\s*)?
        captures:
          "1": { name: keyword.control.line.sv }
          "2": { name: constant.numeric.integer.sv }
          "3": { name: invalid.illegal.sv }
          "4": { name: constant.numeric.integer.sv }
      - match: (`line)\b\s*(?:(\-[0-9]+)\b\s*)?(?:(\"[^"]+\")\s*)?(?:\b([0-9]+)\b\s*)?
        captures:
          "1": { name: keyword.control.line.sv }
          "2": { name: invalid.illegal.sv }
          "3": { name: string.quoted.double.sv }
          "4": { name: constant.numeric.integer.sv }
      - match: (`line)\b\s*(?:\b([0-9]+)\b\s*)?(?:(\"[^"]+\")\s*)?(?:\b([0-9]+)\b\s*)?
        captures:
          "1": { name: keyword.control.line.sv }
          "2": { name: constant.numeric.integer.sv }
          "3": { name: string.quoted.double.sv }
          "4": { name: constant.numeric.integer.sv }
  macro-begin-keywords:
    match: (`begin_keywords)\b\s*(\"[^"]+\")?\s*
    captures:
      "1": { name: keyword.control.begin-keywords.sv }
      "2": { name: string.quoted.double.sv }
  macro-end-keywords:
    match: (`end_keywords)\b
    name: keyword.control.end-keywords.sv
  macro-__line__:
    match: (`__LINE__)\b
    name: meta.preprocessor.macro-name.sv
  macro-__file__:
    match: (`__FILE__)\b
    name: meta.preprocessor.macro-name.sv
  # Misc
  semicolon:
    match: (\;)[ \t]*
    captures:
      "1": { name: punctuation.terminator.semicolon.sv }
  comma:
    match: (\,)\s*
    captures:
      "1": { name: punctuation.separator.comma.sv }
  equals:
    match: (\=)\s*(?!\=)
    captures:
      "1": { name: keyword.operator.assignment.sv }
  colon:
    match: (\:)\s*
    captures:
      "1": { name: punctuation.separator.colon.sv }
  dot:
    match: (\.)\s*
    captures:
      "1": { name: punctuation.accessor.dot.sv }
